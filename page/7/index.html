<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.ashin.wang","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"algolia":{"appID":"S30ZCDT4BR","apiKey":"6988e9b27ba9570d9ed85020ebf48b01","indexName":"blog","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Ashin Wang&#39;s Blog">
<meta property="og:url" content="https://www.ashin.wang/page/7/index.html">
<meta property="og:site_name" content="Ashin Wang&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Ashin Wang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://www.ashin.wang/page/7/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Ashin Wang's Blog</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?1d0c251d59c914b8a773d2fd3302cc56";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Ashin Wang's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

      
    </div>
  </div>

</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.ashin.wang/hexo-github-coding-gitee/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://tva1.sinaimg.cn/large/006y8mN6ly1g74lvmm1zhj3074074q4r.jpg">
      <meta itemprop="name" content="Ashin Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ashin Wang's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/hexo-github-coding-gitee/" class="post-title-link" itemprop="url">Hexo同时部署在GitHub、Coding、Gitee</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-15 22:53:12" itemprop="dateCreated datePublished" datetime="2019-09-15T22:53:12+08:00">2019-09-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Blog/" itemprop="url" rel="index"><span itemprop="name">Blog</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>将Hexo同时部署在GitHub Pages、Coding Pages、Gitee Pages 上。</p>
<p>我太闲了:)</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/hexo-github-coding-gitee/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.ashin.wang/hexo-simplevaline/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://tva1.sinaimg.cn/large/006y8mN6ly1g74lvmm1zhj3074074q4r.jpg">
      <meta itemprop="name" content="Ashin Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ashin Wang's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/hexo-simplevaline/" class="post-title-link" itemprop="url">Hexo评论框架Valine简化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-12 17:37:36" itemprop="dateCreated datePublished" datetime="2019-09-12T17:37:36+08:00">2019-09-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Blog/" itemprop="url" rel="index"><span itemprop="name">Blog</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本站点评论框架采用 Valine，非常喜欢它来搭配 Hexo。</p>
<p>Valine的优点：</p>
<ul>
<li>不需要注册，支持匿名评论</li>
<li>基于 LeanCloud，无广告</li>
<li>支持邮件提醒</li>
<li>多个部署，调用同一个 LeanCloud</li>
</ul>
<p>针对 Valine，冒昧再次进行了简化，使其看起来更加简洁。<br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gbf0edy5igj31a00jgwfi.jpg"></p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/hexo-simplevaline/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.ashin.wang/hexo-accelerate/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://tva1.sinaimg.cn/large/006y8mN6ly1g74lvmm1zhj3074074q4r.jpg">
      <meta itemprop="name" content="Ashin Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ashin Wang's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/hexo-accelerate/" class="post-title-link" itemprop="url">Hexo优化加速</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-07 09:27:19" itemprop="dateCreated datePublished" datetime="2019-09-07T09:27:19+08:00">2019-09-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Blog/" itemprop="url" rel="index"><span itemprop="name">Blog</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>把Hexo托管在GH Pages上，每次full load速度都非常的慢。于是，我deploy到Coding Pages进行对比测试，发现Coding的服务器也全部在境外，速度不如GH且不稳定。</p>
<p>在网上疯狂搜索有关于Hexo加速教程，经过几番折腾，总结几点实用的。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/hexo-accelerate/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.ashin.wang/windows-skill/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://tva1.sinaimg.cn/large/006y8mN6ly1g74lvmm1zhj3074074q4r.jpg">
      <meta itemprop="name" content="Ashin Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ashin Wang's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/windows-skill/" class="post-title-link" itemprop="url">Windows使用技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-29 21:42:17" itemprop="dateCreated datePublished" datetime="2019-06-29T21:42:17+08:00">2019-06-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Windows/" itemprop="url" rel="index"><span itemprop="name">Windows</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Windows 平台下的一些快捷方式，和一些实用工具。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/windows-skill/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.ashin.wang/macos-skill/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://tva1.sinaimg.cn/large/006y8mN6ly1g74lvmm1zhj3074074q4r.jpg">
      <meta itemprop="name" content="Ashin Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ashin Wang's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/macos-skill/" class="post-title-link" itemprop="url">macOS使用技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-05-31 15:08:38" itemprop="dateCreated datePublished" datetime="2019-05-31T15:08:38+08:00">2019-05-31</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/macOS/" itemprop="url" rel="index"><span itemprop="name">macOS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>记录一些 Mac 的快捷方式，以及好用的软件。</p>
<p>不得不说，在MacBook上，使用触控板和快捷方式，有时候比起鼠标还要方便舒适。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/macos-skill/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.ashin.wang/hexo-build/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://tva1.sinaimg.cn/large/006y8mN6ly1g74lvmm1zhj3074074q4r.jpg">
      <meta itemprop="name" content="Ashin Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ashin Wang's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/hexo-build/" class="post-title-link" itemprop="url">Hexo框架搭建+GitHub托管笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-05-24 08:51:54" itemprop="dateCreated datePublished" datetime="2019-05-24T08:51:54+08:00">2019-05-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Blog/" itemprop="url" rel="index"><span itemprop="name">Blog</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>WordPress已闲置一年了，也不想再去维护。最近开始折腾起Hexo框架，发现它不仅符合我的需求（轻量、易用），而且还非常的成熟。托管在GitHub Pages，希望能长久坚持下去。</p>
<p>本次基于macOS，Windows平台的搭建的步骤相同。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/hexo-build/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.ashin.wang/sxf/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://tva1.sinaimg.cn/large/006y8mN6ly1g74lvmm1zhj3074074q4r.jpg">
      <meta itemprop="name" content="Ashin Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ashin Wang's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/sxf/" class="post-title-link" itemprop="url">sxf</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：1978-01-01 00:00:00" itemprop="dateCreated datePublished" datetime="1978-01-01T00:00:00+08:00">1978-01-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="笔试"><a href="#笔试" class="headerlink" title="笔试"></a>笔试</h1><h2 id="第一道编程题"><a href="#第一道编程题" class="headerlink" title="第一道编程题"></a>第一道编程题</h2><p>输入一个字符串，判断这个字符串是不是全对称字符串</p>
<h2 id="零钱兑换问题"><a href="#零钱兑换问题" class="headerlink" title="零钱兑换问题"></a>零钱兑换问题</h2><p>第二道编程题有很多种不同的木材，每种木材可以选取任意次，让你选择最少的木材数量，使得木材长度和刚好等于k</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">coinChange</span>(<span class="params">self, coins: List[<span class="built_in">int</span>], amount: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        </span><br><span class="line">        dp = [<span class="number">0</span>] + [<span class="number">10001</span>] * (amount)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(coin, amount + <span class="number">1</span>):</span><br><span class="line">                dp[j] = <span class="built_in">min</span>(dp[j], dp[j - coin] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>] <span class="keyword">if</span> dp[-<span class="number">1</span>] != <span class="number">10001</span> <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="旅行家问题"><a href="#旅行家问题" class="headerlink" title="旅行家问题"></a>旅行家问题</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mincostTickets</span>(<span class="params">self, days: List[<span class="built_in">int</span>], costs: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (days[-<span class="number">1</span>] + <span class="number">1</span>)</span><br><span class="line">        <span class="comment">#dp = [0 for _ in range(days[-1] + 1)]  # dp数组，每个元素代表到当前天数最少钱数，为下标方便对应，多加一个 0 位置</span></span><br><span class="line">        days_idx = <span class="number">0</span>  <span class="comment"># 设定一个days指标，标记应该处理 days 数组中哪一个元素</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(dp)):</span><br><span class="line">            <span class="keyword">if</span> i != days[days_idx]:  <span class="comment"># 若当前天数不是待处理天数，则其花费费用和前一天相同</span></span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 若 i 走到了待处理天数，则从三种方式中选一个最小的</span></span><br><span class="line">                dp[i] = <span class="built_in">min</span>(dp[<span class="built_in">max</span>(<span class="number">0</span>, i - <span class="number">1</span>)] + costs[<span class="number">0</span>],</span><br><span class="line">                            dp[<span class="built_in">max</span>(<span class="number">0</span>, i - <span class="number">7</span>)] + costs[<span class="number">1</span>],</span><br><span class="line">                            dp[<span class="built_in">max</span>(<span class="number">0</span>, i - <span class="number">30</span>)] + costs[<span class="number">2</span>])</span><br><span class="line">                days_idx += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]  <span class="comment"># 返回最后一天对应的费用即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 二分法 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mincostTickets</span>(<span class="params">self, days: List[<span class="built_in">int</span>], costs: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        ans = [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i, day <span class="keyword">in</span> <span class="built_in">enumerate</span>(days):</span><br><span class="line">            ans.append(<span class="built_in">min</span>(</span><br><span class="line">                ans[-<span class="number">1</span>] + costs[<span class="number">0</span>],</span><br><span class="line">                ans[bisect.bisect(days, day - <span class="number">7</span>)] + costs[<span class="number">1</span>],</span><br><span class="line">                ans[bisect.bisect(days, day - <span class="number">30</span>)] + costs[<span class="number">2</span>]</span><br><span class="line">            ))</span><br><span class="line">        <span class="keyword">return</span> ans[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h2 id="厨师做饭-LRU"><a href="#厨师做饭-LRU" class="headerlink" title="厨师做饭(LRU)"></a>厨师做饭(LRU)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSatisfaction</span>(<span class="params">self, satisfaction: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        satisfaction.sort(reverse=<span class="literal">True</span>)</span><br><span class="line">        presum, ans = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> si <span class="keyword">in</span> satisfaction:</span><br><span class="line">            <span class="keyword">if</span> presum + si &gt; <span class="number">0</span>:</span><br><span class="line">                presum += si</span><br><span class="line">                ans += presum</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="小机器人方案数"><a href="#小机器人方案数" class="headerlink" title="小机器人方案数"></a>小机器人方案数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">n, m, k, p = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">eps = <span class="number">1e9</span> + <span class="number">7</span></span><br><span class="line"></span><br><span class="line">last = [<span class="number">0</span>] * (n + <span class="number">2</span>)</span><br><span class="line">curr = [<span class="number">0</span>] * (n + <span class="number">2</span>)</span><br><span class="line">last[m] = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, k+<span class="number">1</span>):</span><br><span class="line">    l = <span class="built_in">max</span>(<span class="number">1</span>, m-i)</span><br><span class="line">    r = <span class="built_in">min</span>(n, m+i)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(l, r+<span class="number">1</span>):</span><br><span class="line">        curr[j] = (last[j-<span class="number">1</span>] + last[j + <span class="number">1</span>]) % eps</span><br><span class="line">    last[:] = curr[:]</span><br><span class="line">print(<span class="built_in">int</span>(curr[p]))</span><br></pre></td></tr></table></figure>

<h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-linked-list/">206. 反转链表</a></h2><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvylmn99ugj313e0i4whn.jpg" style="zoom:67%;" />

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        prev, curr = <span class="literal">None</span>, head</span><br><span class="line">        <span class="keyword">while</span> curr <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            nxt = curr.<span class="built_in">next</span> <span class="comment"># 移动指针</span></span><br><span class="line">            curr.<span class="built_in">next</span> = prev</span><br><span class="line">            prev = curr</span><br><span class="line">            curr = nxt <span class="comment"># 移动指针</span></span><br><span class="line">            <span class="keyword">return</span> prev</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">    <span class="comment"># 单个节点</span></span><br><span class="line">    <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    </span><br><span class="line">    p = self.reverseList(head.<span class="built_in">next</span>)</span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span> = head</span><br><span class="line">    head.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure>



<h2 id="列表分子"><a href="#列表分子" class="headerlink" title="列表分子"></a>列表分子</h2><p>k1 对应的 value 相同的放在同一列表里面</p>
<p>手撕代码：列表分子，k1 对应的value相同的放在同一列表里面 </p>
<p> 输入：[{‘k1’:1, ‘k2’:1},  {‘k1 ‘:2, ‘k2’:2}, {‘k1’:1, ‘k2’:2}] </p>
<p> 输出：[{‘k1’:1, ‘k2’:1}, {‘k1’, 1, ‘k2’: 2}], [{k1’: 2,’k2’: 2}] </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">arr = [&#123;<span class="string">&#x27;k1&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;k2&#x27;</span>:<span class="number">1</span>&#125;,  &#123;<span class="string">&#x27;k1&#x27;</span>:<span class="number">2</span>, <span class="string">&#x27;k2&#x27;</span>:<span class="number">2</span>&#125;, &#123;<span class="string">&#x27;k1&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;k2&#x27;</span>:<span class="number">2</span>&#125;, &#123;<span class="string">&#x27;k1&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;k2&#x27;</span>:<span class="number">2</span>&#125;]</span><br><span class="line"><span class="comment"># [&#123;&#x27;k1&#x27;:1, &#x27;k2&#x27;:1&#125;, &#123;&#x27;k1&#x27;, 1, &#x27;k2&#x27;: 2&#125;], [&#123;k1&#x27;: 2,&#x27;k2&#x27;: 2&#125;] </span></span><br><span class="line"></span><br><span class="line">res = []</span><br><span class="line">cnt = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)):</span><br><span class="line">    tmp = []</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, <span class="built_in">len</span>(arr)):</span><br><span class="line">        <span class="keyword">if</span> arr[j][<span class="string">&#x27;k1&#x27;</span>] == arr[i][<span class="string">&#x27;k1&#x27;</span>]:</span><br><span class="line">            tmp.append(arr[i])</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> cnt &lt;= <span class="built_in">len</span>(arr):</span><br><span class="line">        res.append(tmp)</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure>



<h2 id="撕代码，快速-排序"><a href="#撕代码，快速-排序" class="headerlink" title="撕代码，快速[排序]"></a>撕代码，快速[排序]</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span>(<span class="params">nums</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quick</span>(<span class="params">left, right</span>):</span></span><br><span class="line">        <span class="keyword">if</span> left &gt;= right:</span><br><span class="line">            <span class="keyword">return</span> nums</span><br><span class="line">        pivot = left <span class="comment"># 最左边</span></span><br><span class="line">        i = left</span><br><span class="line">        j = right</span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> nums[j] &gt; nums[pivot]:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> nums[i] &lt;= nums[pivot]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">        nums[pivot], nums[j] = nums[j], nums[pivot]</span><br><span class="line">        <span class="comment"># 分区</span></span><br><span class="line">        quick(left, j - <span class="number">1</span>)</span><br><span class="line">        quick(j + <span class="number">1</span>, right)</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    <span class="keyword">return</span> quick(<span class="number">0</span>, n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>



<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入<a href="">排序</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertion_sort</span>(<span class="params">nums</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        <span class="keyword">while</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i - <span class="number">1</span>] &gt; nums[i]:</span><br><span class="line">            nums[i - <span class="number">1</span>], nums[i] = nums[i], nums[i - <span class="number">1</span>] <span class="comment"># 交换</span></span><br><span class="line">            i -= <span class="number">1</span> <span class="comment"># 倒回去比较</span></span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>



<h2 id="回文数"><a href="#回文数" class="headerlink" title="回文数"></a>回文数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validPalindrome</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment">#lambda [arg1 [,arg2,.....argn]]:expression, x[start:end:span] 当 span&lt;0 时，列表翻转</span></span><br><span class="line">        isPalindrome = <span class="keyword">lambda</span> x : x == x[::-<span class="number">1</span>] <span class="comment"># isPalindrome 返回值就是 bool</span></span><br><span class="line"></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            <span class="keyword">if</span> s[left] == s[right]:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> isPalindrome(s[left + <span class="number">1</span> : right + <span class="number">1</span>]) <span class="keyword">or</span> isPalindrome(s[left: right])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> <span class="comment"># True</span></span><br></pre></td></tr></table></figure>



<h2 id="前中后序遍历"><a href="#前中后序遍历" class="headerlink" title="前中后序遍历"></a>前中后序遍历</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 递归1：二叉树遍历最易理解和实现版本</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="comment"># 前序递归</span></span><br><span class="line">        <span class="keyword">return</span> [root.val] + self.preorderTraversal(root.left) + self.preorderTraversal(root.right)</span><br><span class="line">        <span class="comment"># 中序递归 </span></span><br><span class="line">        <span class="keyword">return</span> self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)</span><br><span class="line">        <span class="comment"># 后序递归</span></span><br><span class="line">        <span class="keyword">return</span> self.postorderTraversal(root.left) + self.postorderTraversal(root.right) + [root.val]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归2：通用模板，可以适应不同的题目，添加参数、增加返回条件、修改进入递归条件、自定义返回值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">cur</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur:</span><br><span class="line">                <span class="keyword">return</span>      </span><br><span class="line">            <span class="comment"># 前序递归</span></span><br><span class="line">            res.append(cur.val)</span><br><span class="line">            dfs(cur.left)</span><br></pre></td></tr></table></figure>



<h2 id="类，读数据和写数据"><a href="#类，读数据和写数据" class="headerlink" title="类，读数据和写数据"></a>类，读数据和写数据</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadWrite</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, path</span>):</span></span><br><span class="line">        self.path = path</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read_data</span>(<span class="params">self</span>):</span></span><br><span class="line">        f = <span class="built_in">open</span>(self.path, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">        print(f)</span><br><span class="line">        <span class="keyword">return</span> f    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write_data</span>(<span class="params">self, content</span>):</span></span><br><span class="line">        file = self.read_data()</span><br><span class="line">        file.write(content)</span><br><span class="line">        file.close()</span><br><span class="line"></span><br><span class="line">rw = ReadWrite(<span class="string">&#x27;/Users/ashin/Desktop/test.py&#x27;</span>).write_data(content = <span class="string">&#x27;hello word&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h2 id="数组转换成链表再去重"><a href="#数组转换成链表再去重" class="headerlink" title="数组转换成链表再去重"></a>数组转换成<a href="">链表</a>再去重</h2><p>根据数组构造<a href="">链表</a>，然后删除其中重复数字（构造删除同时输出<a href="">链表</a>节点的值和地址）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val=<span class="literal">None</span>, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">list2link</span>(<span class="params">list_</span>):</span></span><br><span class="line">    head = Node(list_[<span class="number">0</span>])</span><br><span class="line">    p = head</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(list_)):</span><br><span class="line">        p.<span class="built_in">next</span> = Node(list_[i])</span><br><span class="line">        p = p.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span>(<span class="params">self, head</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    pre, cur = head, head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> cur:</span><br><span class="line">        <span class="keyword">if</span> pre.val == cur.val:</span><br><span class="line">            pre.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pre = cur</span><br><span class="line">        cur = cur.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicateNodes</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:<span class="comment">#如果head里本来就没东西，那就返回head本身</span></span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">        r = head <span class="comment">#r是head的代言人，负责迭代和更新，head负责原地不动</span></span><br><span class="line">        record = &#123;head.val&#125; <span class="comment">#record负责储存看见过的值。现在已经储存了第一个值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> r <span class="keyword">and</span> r.<span class="built_in">next</span>: <span class="comment">#只要r接下来还有东西，就看看下一个东西是不是已经在record当中 </span></span><br><span class="line">            <span class="comment">#这里判断时要同时符合这两个条件，因为如果r已经是None了，判断r.next会报错，所以每次得先判断r</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> r.<span class="built_in">next</span>.val <span class="keyword">not</span> <span class="keyword">in</span> record: <span class="comment">#如果下一环的值没被储存过,不用对head作任何修改</span></span><br><span class="line">                record.add(r.<span class="built_in">next</span>.val) <span class="comment">#在record中添加这个值</span></span><br><span class="line">                r = r.<span class="built_in">next</span> <span class="comment">#并且让r进入下一环</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span>: <span class="comment">#如果下一环的值已经见过了</span></span><br><span class="line">                r.<span class="built_in">next</span> = r.<span class="built_in">next</span>.<span class="built_in">next</span> <span class="comment">#直接让r的下一环变为下下环，即把r.next这一环删了</span></span><br><span class="line">                <span class="comment">#这里不用再写&quot;r=r.next&quot;让r进入下一环，原因是r.next已经更改了，要重新进入loop判断现在的r.next(即原来的r.next.next)是否已经遇见过</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>



<h2 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line">        size = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="comment"># 特殊处理</span></span><br><span class="line">        <span class="keyword">if</span> size == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        <span class="comment"># 创建动态规划dynamic programing表</span></span><br><span class="line">        dp = [[<span class="literal">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size)]</span><br><span class="line">        <span class="comment"># 初始长度为1，这样万一不存在回文，就返回第一个值（初始条件设置的时候一定要考虑输出）</span></span><br><span class="line">        max_len = <span class="number">1</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, size):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(j):</span><br><span class="line">                <span class="comment"># 边界条件：</span></span><br><span class="line">                <span class="comment"># 只要头尾相等（s[i]==s[j]）就能返回True</span></span><br><span class="line">                <span class="keyword">if</span> j - i &lt;= <span class="number">2</span>:</span><br><span class="line">                    <span class="keyword">if</span> s[i] == s[j]:</span><br><span class="line">                        dp[i][j] = <span class="literal">True</span></span><br><span class="line">                        cur_len = j - i + <span class="number">1</span></span><br><span class="line">                <span class="comment"># 状态转移方程 </span></span><br><span class="line">                <span class="comment"># 当前dp[i][j]状态：头尾相等（s[i]==s[j]）</span></span><br><span class="line">                <span class="comment"># 过去dp[i][j]状态：去掉头尾之后还是一个回文（dp[i+1][j-1] is True）</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> s[i] == s[j] <span class="keyword">and</span> dp[i + <span class="number">1</span>][j - <span class="number">1</span>]:</span><br><span class="line">                        dp[i][j] = <span class="literal">True</span></span><br><span class="line">                        cur_len = j - i + <span class="number">1</span></span><br><span class="line">                <span class="comment"># 出现回文更新输出</span></span><br><span class="line">                <span class="keyword">if</span> dp[i][j]:</span><br><span class="line">                    <span class="keyword">if</span> cur_len &gt; max_len:</span><br><span class="line">                        max_len = cur_len</span><br><span class="line">                        start = i</span><br><span class="line">        <span class="keyword">return</span> s[start: start + max_len]</span><br></pre></td></tr></table></figure>



<h2 id="不用＋号实现a-b"><a href="#不用＋号实现a-b" class="headerlink" title="不用＋号实现a+b"></a>不用＋号实现a+b</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 位运算</span></span><br><span class="line"><span class="comment"># ^ 异或 操作实现无进位加法</span></span><br><span class="line"><span class="comment"># &amp; 与 实现进位</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getSum</span>(<span class="params">self, a: <span class="built_in">int</span>, b: <span class="built_in">int</span></span>) -&gt; int:</span> <span class="comment">#a=-2, b=3</span></span><br><span class="line">        a &amp;= <span class="number">0xFFFFFFFF</span> <span class="comment"># a=1110 --&gt; 14</span></span><br><span class="line">        b &amp;= <span class="number">0xFFFFFFFF</span> <span class="comment"># b=3</span></span><br><span class="line">        <span class="keyword">while</span> b:</span><br><span class="line">            carry = a &amp; b</span><br><span class="line">            a ^= b </span><br><span class="line">            b = ((carry) &lt;&lt; <span class="number">1</span>) &amp; <span class="number">0xFFFFFFFF</span> <span class="comment"># 左移动</span></span><br><span class="line">            <span class="comment"># print((a, b))</span></span><br><span class="line">        <span class="keyword">return</span> a <span class="keyword">if</span> a &lt; <span class="number">0x80000000</span> <span class="keyword">else</span> ~(a^<span class="number">0xFFFFFFFF</span>)</span><br></pre></td></tr></table></figure>



<h2 id="链表结构，链表排序"><a href="#链表结构，链表排序" class="headerlink" title="链表结构，链表排序"></a><a href="">链表</a>结构，<a href="">链表</a><a href="">排序</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 归并排序</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>: <span class="keyword">return</span> head</span><br><span class="line">        left_end = self.find_mid(head)</span><br><span class="line">        mid = left_end.<span class="built_in">next</span> </span><br><span class="line">        left_end.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        left, right = self.sortList(head), self.sortList(mid)</span><br><span class="line">        <span class="keyword">return</span> self.merged(left, right)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 快慢指针查找链表中点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_mid</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>: <span class="keyword">return</span> head</span><br><span class="line">        slow,fast = head, head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> fast.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            slow=slow.<span class="built_in">next</span></span><br><span class="line">            fast=fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 合并有序链表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merged</span>(<span class="params">self, left, right</span>):</span></span><br><span class="line">        res = ListNode()</span><br><span class="line">        h = res</span><br><span class="line">        <span class="keyword">while</span> left <span class="keyword">and</span> right:</span><br><span class="line">            <span class="keyword">if</span> left.val &lt; right.val: </span><br><span class="line">                h.<span class="built_in">next</span>, left = left, left.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                h.<span class="built_in">next</span>, right = right, right.<span class="built_in">next</span></span><br><span class="line">            h = h.<span class="built_in">next</span></span><br><span class="line">        h.<span class="built_in">next</span> = left <span class="keyword">if</span> left <span class="keyword">else</span> right</span><br><span class="line">        <span class="keyword">return</span> res.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>



<h2 id="写一个装饰器"><a href="#写一个装饰器" class="headerlink" title="写一个装饰器"></a>写一个装饰器</h2><p>装饰器（Decorators） 是 Python 的一个重要部分。简单地说：他们是修改其他函数的功能的函数。是一种函数的函数，因为装饰器传入的参数就是一个函数，然后通过实现各种功能来对这个函数的功能进行增强。</p>
<p>简洁明了</p>
<p><strong>@wraps</strong>接受一个函数来进行装饰，并加入了复制函数名称、注释文档、参数列表等等的功能。这可以让我们在装饰器里面访问在装饰之前的函数的属性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator_name</span>(<span class="params">f</span>):</span></span><br><span class="line"><span class="meta">    @wraps(<span class="params">f</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorated</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> can_run:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Function will not run&quot;</span></span><br><span class="line">        <span class="keyword">return</span> f(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> decorated</span><br><span class="line"> </span><br><span class="line"><span class="meta">@decorator_name</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">    <span class="keyword">return</span>(<span class="string">&quot;Function is running&quot;</span>)</span><br><span class="line"> </span><br><span class="line">can_run = <span class="literal">True</span></span><br><span class="line">print(func())</span><br><span class="line"><span class="comment"># Output: Function is running</span></span><br><span class="line"> </span><br><span class="line">can_run = <span class="literal">False</span></span><br><span class="line">print(func())</span><br><span class="line"><span class="comment"># Output: Function will not run</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Flask</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">requires_auth</span>(<span class="params">f</span>):</span></span><br><span class="line"><span class="meta">    @wraps(<span class="params">f</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorated</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        auth = request.authorization</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> auth <span class="keyword">or</span> <span class="keyword">not</span> check_auth(auth.username, auth.password):</span><br><span class="line">            authenticate()</span><br><span class="line">        <span class="keyword">return</span> f(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> decorated</span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logit</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">with_logging</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        print(func.__name__ + <span class="string">&quot; was called&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> with_logging</span><br><span class="line"> </span><br><span class="line"><span class="meta">@logit</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addition_func</span>(<span class="params">x</span>):</span></span><br><span class="line">   <span class="string">&quot;&quot;&quot;Do some math.&quot;&quot;&quot;</span></span><br><span class="line">   <span class="keyword">return</span> x + x</span><br><span class="line"> </span><br><span class="line">result = addition_func(<span class="number">4</span>)</span><br><span class="line"><span class="comment"># Output: addition_func was called</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 装饰器类</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">logit</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, logfile=<span class="string">&#x27;out.log&#x27;</span></span>):</span></span><br><span class="line">        self.logfile = logfile</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, func</span>):</span></span><br><span class="line"><span class="meta">        @wraps(<span class="params">func</span>)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapped_function</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">            log_string = func.__name__ + <span class="string">&quot; was called&quot;</span></span><br><span class="line">            print(log_string)</span><br><span class="line">            <span class="comment"># 打开logfile并写入</span></span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(self.logfile, <span class="string">&#x27;a&#x27;</span>) <span class="keyword">as</span> opened_file:</span><br><span class="line">                <span class="comment"># 现在将日志打到指定的文件</span></span><br><span class="line">                opened_file.write(log_string + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            <span class="comment"># 现在，发送一个通知</span></span><br><span class="line">            self.notify()</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> wrapped_function</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">notify</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># logit只打日志，不做别的</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment"># 时间</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func_timer</span>(<span class="params">function</span>):</span></span><br><span class="line"><span class="meta">  @wraps(<span class="params">function</span>)</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">function_timer</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">    start = time.time()</span><br><span class="line">    result = function(*args, **kwargs)</span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;函数%s总运行时间: %s s&quot;</span> %(function.__name__, <span class="built_in">str</span>(end - start)))</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  <span class="keyword">return</span> function_timer</span><br></pre></td></tr></table></figure>



<h2 id="146-LRU-缓存机制"><a href="#146-LRU-缓存机制" class="headerlink" title="146. LRU 缓存机制"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lru-cache/">146. LRU 缓存机制</a></h2><p>LRU：least recently used，最近最少使用算法。其实就是按使用时间倒排序，然后从尾部删除元素。它的使用场景是：在有限的空间中存储对象时，当空间满时，会按一定的原则删除原有的对象，常用的原则（算法）有 LRU，FIFO，LFU 等。在计算机的 Cache 硬件，以及主存到虚拟内存的页面置换，还有Redis缓存系统中都用到了该算法。我在一次面试和一个笔试时，也遇到过这个问题。</p>
<p> LRU的算法是比较简单的，当对key进行访问时（一般有查询，更新，增加，在get()和set()两个方法中实现即可）时，将该key放到队列的最前端（或最后端）就行了，这样就实现了对key按其<strong>最后一次访问的时间</strong>降序（或升序）排列，当向空间中增加新对象时，如果空间满了，删除队尾（或队首）的对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">哈希表 + 双向链表</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">哈希表用于满足题目时间复杂度O(1)的要求，双向链表用于存储顺序</span></span><br><span class="line"><span class="string">哈希表键值类型：&lt;Integer, ListNode&gt;，哈希表的键用于存储输入的 key，哈希表的值用于存储双向链表的节点</span></span><br><span class="line"><span class="string">双向链表的节点中除了 value 外还需要包含 key，因为在删除最久未使用的数据时，需要通过链表来定位 hashmap 中应当删除的键值对</span></span><br><span class="line"><span class="string">一些操作：双向链表中，在后面的节点表示被最近访问</span></span><br><span class="line"><span class="string">i. 新加入的节点放在链表末尾，addNodeToLast(node)</span></span><br><span class="line"><span class="string">ii. 若容量达到上限，去除最久未使用的数据，removeNode(head.next)</span></span><br><span class="line"><span class="string">iii. 若数据新被访问过，比如被get了或被put了新值，把该节点挪到链表末尾，moveNodeToLast(node)</span></span><br><span class="line"><span class="string">为了操作的方便，在双向链表头和尾分别定义一个head和tail节点。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, key = <span class="number">0</span>, val = <span class="number">0</span></span>):</span></span><br><span class="line">        self.key = key</span><br><span class="line">        self.val = val</span><br><span class="line">        self.prev = <span class="literal">None</span></span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, capacity: <span class="built_in">int</span></span>):</span></span><br><span class="line">        self.capacity = capacity</span><br><span class="line">        self.hashmap = &#123;&#125;</span><br><span class="line">        self.head = ListNode()</span><br><span class="line">        self.tail = ListNode()</span><br><span class="line">        self.head.<span class="built_in">next</span> = self.tail</span><br><span class="line">        self.tail.prev = self.head</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove_node</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        node.prev.<span class="built_in">next</span> = node.<span class="built_in">next</span></span><br><span class="line">        node.<span class="built_in">next</span>.prev = node.prev</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_node_to_last</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        self.tail.prev.<span class="built_in">next</span> = node</span><br><span class="line">        node.prev = self.tail.prev</span><br><span class="line">        node.<span class="built_in">next</span> = self.tail</span><br><span class="line">        self.tail.prev = node</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move_node_to_last</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        self.remove_node(node)</span><br><span class="line">        self.add_node_to_last(node)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.hashmap:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        node = self.hashmap[key]</span><br><span class="line">        self.move_node_to_last(node)</span><br><span class="line">        <span class="keyword">return</span> node.val</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self, key: <span class="built_in">int</span>, value: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.hashmap:</span><br><span class="line">            node = self.hashmap[key]</span><br><span class="line">            node.val = value</span><br><span class="line">            self.move_node_to_last(node)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.hashmap) == self.capacity:</span><br><span class="line">            <span class="keyword">del</span> self.hashmap[self.head.<span class="built_in">next</span>.key]</span><br><span class="line">            self.remove_node(self.head.<span class="built_in">next</span>)</span><br><span class="line">        node = ListNode(key, value)</span><br><span class="line">        self.hashmap[key] = node</span><br><span class="line">        self.add_node_to_last(node)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="comment"># OrderedDict       </span></span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, capacity</span>):</span></span><br><span class="line">        self.capacity = capacity</span><br><span class="line">        self.cache = collections.OrderedDict()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            value = self.cache.pop(key)</span><br><span class="line">            self.cache[key] = value</span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set</span>(<span class="params">self, key, value</span>):</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.cache.pop(key)</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(self.cache) &gt;= self.capacity:</span><br><span class="line">                self.cache.popitem(last=<span class="literal">False</span>)</span><br><span class="line">        self.cache[key] = value</span><br></pre></td></tr></table></figure>



<h2 id="子序列算法"><a href="#子序列算法" class="headerlink" title="子序列算法"></a>子序列<a href="">算法</a></h2><p>给一个字符串，求有多少种切分方式使得每一个子序列代表的数字都在给定范围内</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"><span class="comment">## [1297. 子串的最大出现次数](https://leetcode-cn.com/problems/maximum-number-of-occurrences-of-a-substring/)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入：s = “aababcaab”, maxLetters = 2, minSize = 3, maxSize = 4<br>输出：2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#96;&#96;&#96;python</span><br><span class="line">class Solution:</span><br><span class="line">    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -&gt; int:</span><br><span class="line">        n &#x3D; len(s)</span><br><span class="line">        dic &#x3D; defaultdict(int)</span><br><span class="line"></span><br><span class="line">        for i in range(n - minSize + 1):   #防止越界</span><br><span class="line">            cur &#x3D; s[i: i + minSize]       #maxSize没有用 长的都行  短的更可以</span><br><span class="line">            if len(set(cur)) &lt;&#x3D; maxLetters:</span><br><span class="line">                dic[cur] +&#x3D; 1</span><br><span class="line">                </span><br><span class="line">        if len(dic) &#x3D;&#x3D; 0:</span><br><span class="line">            return 0</span><br><span class="line">        return max(dic.values())</span><br></pre></td></tr></table></figure>



<h2 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232. 用栈实现队列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/implement-queue-using-stacks/">232. 用栈实现队列</a></h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvibrcdoldg60u00gwhdx02.gif" alt="232.gif"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为了满足队列的 FIFO 的特性，我们需要用到两个栈，用它们其中一个来反转元素的入队顺序，用另一个来存储元素的最终顺序。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.stack1 = []</span><br><span class="line">        self.stack2 = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.stack1.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.stack2:</span><br><span class="line">            <span class="keyword">while</span> self.stack1:</span><br><span class="line">                self.stack2.append(self.stack1.pop())</span><br><span class="line">        <span class="keyword">return</span> self.stack2.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.stack2:</span><br><span class="line">            <span class="keyword">while</span> self.stack1:</span><br><span class="line">                self.stack2.append(self.stack1.pop())</span><br><span class="line">        <span class="keyword">return</span> self.stack2[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">empty</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self.stack1 <span class="keyword">and</span> <span class="keyword">not</span> self.stack2</span><br></pre></td></tr></table></figure>

<h2 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225. 用队列实现栈"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/implement-stack-using-queues/">225. 用队列实现栈</a></h2><p><img src="https://assets.leetcode-cn.com/solution-static/225/225_fig1.gif" alt="fig1"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.queue1 = collections.deque()</span><br><span class="line">        self.queue2 = collections.deque()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Push element x onto stack.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.queue2.append(x)</span><br><span class="line">        <span class="keyword">while</span> self.queue1:</span><br><span class="line">            self.queue2.append(self.queue1.popleft())</span><br><span class="line">        self.queue1, self.queue2 = self.queue2, self.queue1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Removes the element on top of the stack and returns that element.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.queue1.popleft()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Get the top element.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.queue1[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">empty</span>(<span class="params">self</span>) -&gt; bool:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Returns whether the stack is empty.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self.queue1</span><br></pre></td></tr></table></figure>

<h2 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155. 最小栈"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/min-stack/">155. 最小栈</a></h2><p><img src="https://assets.leetcode-cn.com/solution-static/155/155_fig1.gif" alt="fig1"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.stack = []</span><br><span class="line">        self.min_stack = [math.inf]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.stack.append(x)</span><br><span class="line">        self.min_stack.append(<span class="built_in">min</span>(x, self.min_stack[-<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.stack.pop()</span><br><span class="line">        self.min_stack.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.stack[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMin</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.min_stack[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h2 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40. 组合总和 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum-ii/">40. 组合总和 II</a></h2><p>数组中等于指定数的数字组合 不会 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">为了避免产生重复解，本题candidates务必排序</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">backtrack步骤如下：</span></span><br><span class="line"><span class="string">剪枝：如果当前tmp数组的和cur已经大于目标target，没必要枚举了，直接return</span></span><br><span class="line"><span class="string">如果当前tmp数组的和cur正好和目标target相等，找到一个组合，加到结果res中去，并return</span></span><br><span class="line"><span class="string">for循环遍历从index开始的数，选一个数进入下一层递归。</span></span><br><span class="line"><span class="string">如果从index开始的数有连续出现的重复数字，跳过该数字continue，因为这会产生重复解</span></span><br><span class="line"><span class="string">因为数不可以重复选择，所以在进入下一层递归时，i要加1，从i之后的数中选择接下来的数</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum2</span>(<span class="params">self, candidates: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">tmp, cur, index</span>):</span></span><br><span class="line">            <span class="keyword">if</span> cur &gt; target:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> cur == target:</span><br><span class="line">                res.append(tmp)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index, n):</span><br><span class="line">                <span class="keyword">if</span> i &gt; index <span class="keyword">and</span> candidates[i] == candidates[i - <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                backtrack(tmp + [candidates[i]], cur + candidates[i], i + <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        res = []</span><br><span class="line">        n = <span class="built_in">len</span>(candidates)</span><br><span class="line">        candidates.sort()</span><br><span class="line">        backtrack([], <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>



<h2 id="字符串中所有字符出现字数"><a href="#字符串中所有字符出现字数" class="headerlink" title="字符串中所有字符出现字数"></a>字符串中所有字符出现字数</h2><p>不允许用字典 count 时间换空间一次迭代(<a href="">leetcode</a>做过 用字典哭死) 不会</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">areOccurrencesEqual</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        freq = Counter(s)   <span class="comment"># 每个字符的实际频数</span></span><br><span class="line">        occ = <span class="built_in">len</span>(s) // <span class="built_in">len</span>(freq)    <span class="comment"># 每个字符的理论频数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">all</span>(v == occ <span class="keyword">for</span> v <span class="keyword">in</span> freq.values())</span><br></pre></td></tr></table></figure>



<h2 id="运行时间装饰器"><a href="#运行时间装饰器" class="headerlink" title="运行时间装饰器"></a>运行时间装饰器</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 常规</span></span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>():</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>):</span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">            res -= <span class="number">1</span></span><br><span class="line">            </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    start = time() <span class="comment"># 获取函数开始的时间戳</span></span><br><span class="line">    run()</span><br><span class="line">    end = time() <span class="comment"># 获取函数结束的时间戳</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 装饰器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">time_costing</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">core</span>():</span></span><br><span class="line">        start = time()</span><br><span class="line">        func()</span><br><span class="line">        end = time</span><br><span class="line">        print(<span class="string">&#x27;time costing:&#x27;</span>, end - start)</span><br><span class="line">    <span class="keyword">return</span> core</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">@time_costing</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>():</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>):</span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">            res -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">	run()</span><br></pre></td></tr></table></figure>



<h2 id="跳台阶"><a href="#跳台阶" class="headerlink" title="跳台阶"></a>跳台阶</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, n + <span class="number">1</span>):</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i-<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>





<h2 id="最大回文字符串"><a href="#最大回文字符串" class="headerlink" title="最大回文字符串"></a>最大回文字符串</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line">        </span><br><span class="line">        size = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="comment"># 特殊处理</span></span><br><span class="line">        <span class="keyword">if</span> size == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        <span class="comment"># 创建动态规划dynamic programing表</span></span><br><span class="line">        dp = [[<span class="literal">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size)]</span><br><span class="line">        <span class="comment"># 初始长度为1，这样万一不存在回文，就返回第一个值（初始条件设置的时候一定要考虑输出）</span></span><br><span class="line">        max_len = <span class="number">1</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, size):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(j):</span><br><span class="line">                <span class="comment"># 边界条件：</span></span><br><span class="line">                <span class="comment"># 只要头尾相等（s[i]==s[j]）就能返回True</span></span><br><span class="line">                <span class="keyword">if</span> j - i &lt;= <span class="number">2</span>:</span><br><span class="line">                    <span class="keyword">if</span> s[i] == s[j]:</span><br><span class="line">                        dp[i][j] = <span class="literal">True</span></span><br><span class="line">                        cur_len = j - i + <span class="number">1</span></span><br><span class="line">                <span class="comment"># 状态转移方程 </span></span><br><span class="line">                <span class="comment"># 当前dp[i][j]状态：头尾相等（s[i]==s[j]）</span></span><br><span class="line">                <span class="comment"># 过去dp[i][j]状态：去掉头尾之后还是一个回文（dp[i+1][j-1] is True）</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> s[i] == s[j] <span class="keyword">and</span> dp[i + <span class="number">1</span>][j - <span class="number">1</span>]:</span><br><span class="line">                        dp[i][j] = <span class="literal">True</span></span><br><span class="line">                        cur_len = j - i + <span class="number">1</span></span><br><span class="line">                <span class="comment"># 出现回文更新输出</span></span><br><span class="line">                <span class="keyword">if</span> dp[i][j]:</span><br><span class="line">                    <span class="keyword">if</span> cur_len &gt; max_len:</span><br><span class="line">                        max_len = cur_len</span><br><span class="line">                        start = i</span><br><span class="line">        <span class="keyword">return</span> s[start: start + max_len]</span><br></pre></td></tr></table></figure>



<h2 id="力扣21-合并两个有序-链表"><a href="#力扣21-合并两个有序-链表" class="headerlink" title="力扣21 - 合并两个有序[链表"></a>力扣21 - 合并两个有序[链表</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 递归</span></span><br><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="comment"># 终止条件，直到两个链表都空</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l1: <span class="keyword">return</span> l2  </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l2: <span class="keyword">return</span> l1</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 递归调用</span></span><br><span class="line">        <span class="keyword">if</span> l1.val &lt;= l2.val:  </span><br><span class="line">            l1.<span class="built_in">next</span> = self.mergeTwoLists(l1.<span class="built_in">next</span>, l2)</span><br><span class="line">            <span class="keyword">return</span> l1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l2.<span class="built_in">next</span> = self.mergeTwoLists(l1, l2.<span class="built_in">next</span>)</span><br><span class="line">            <span class="keyword">return</span> l2</span><br></pre></td></tr></table></figure>



<h2 id="单链表逆转下标由m到n之间的节点"><a href="#单链表逆转下标由m到n之间的节点" class="headerlink" title="单链表逆转下标由m到n之间的节点"></a>单<a href="">链表</a>逆转下标由m到n之间的节点</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## [排序]()（将列表[排序]()）</span></span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="链表相关（合并，排序，反转）"><a href="#链表相关（合并，排序，反转）" class="headerlink" title="链表相关（合并，排序，反转）"></a><a href="">链表</a>相关（合并，<a href="">排序</a>，反转）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 合并</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="comment"># 终止条件，直到两个链表都空</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l1: <span class="keyword">return</span> l2  </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l2: <span class="keyword">return</span> l1</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 递归调用</span></span><br><span class="line">        <span class="keyword">if</span> l1.val &lt;= l2.val:  </span><br><span class="line">            l1.<span class="built_in">next</span> = self.mergeTwoLists(l1.<span class="built_in">next</span>, l2)</span><br><span class="line">            <span class="keyword">return</span> l1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l2.<span class="built_in">next</span> = self.mergeTwoLists(l1, l2.<span class="built_in">next</span>)</span><br><span class="line">            <span class="keyword">return</span> l2</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 反转</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        pre, cur = <span class="literal">None</span>, head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            nxt = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = nxt</span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure>



<h2 id="99乘法表"><a href="#99乘法表" class="headerlink" title="99乘法表"></a>99乘法表</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, i + <span class="number">1</span>):</span><br><span class="line">        print(<span class="string">&#x27;&#123;&#125; x &#123;&#125; = &#123;&#125;\t&#x27;</span>.<span class="built_in">format</span>(j, i, i*j), end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    print()</span><br></pre></td></tr></table></figure>



<h2 id="414-第三大的数"><a href="#414-第三大的数" class="headerlink" title="414. 第三大的数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/third-maximum-number/">414. 第三大的数</a></h2><p>（要考虑数组中元素重复的情况）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">thirdMax</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        heap = []</span><br><span class="line">        k = <span class="number">3</span></span><br><span class="line">        nums = <span class="built_in">set</span>(nums)</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            heapq.heappush(heap, num)</span><br><span class="line">            <span class="comment"># 一旦堆中的元素大于3，就把最小的（堆顶元素）抛出。始终保持一个 3 以内的堆</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(heap) &gt; k:</span><br><span class="line">                heapq.heappop(heap)</span><br><span class="line">	</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(heap) == k:</span><br><span class="line">            <span class="comment"># 堆顶元素在数组最前面</span></span><br><span class="line">            <span class="keyword">return</span> heap[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 不存在第三大元素，就返回最大的元素</span></span><br><span class="line">            <span class="keyword">return</span> heap[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>



<h2 id="判断回文字符串"><a href="#判断回文字符串" class="headerlink" title="判断回文字符串"></a>判断回文字符串</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validPalindrome</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment">#lambda [arg1 [,arg2,.....argn]]:expression, x[start:end:span] 当 span&lt;0 时，列表翻转</span></span><br><span class="line">        isPalindrome = <span class="keyword">lambda</span> x : x == x[::-<span class="number">1</span>] <span class="comment"># isPalindrome 返回值就是 bool</span></span><br><span class="line"></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            <span class="keyword">if</span> s[left] == s[right]:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> isPalindrome(s[left + <span class="number">1</span> : right + <span class="number">1</span>]) <span class="keyword">or</span> isPalindrome(s[left: right])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> <span class="comment"># True</span></span><br></pre></td></tr></table></figure>



<h2 id="兔子繁殖"><a href="#兔子繁殖" class="headerlink" title="兔子繁殖"></a>兔子繁殖</h2><p>兔子都是母兔子，每一只兔子每一年可以生4只或5只，求繁殖n年后一共有几只兔子</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 消消乐</span></span><br><span class="line"></span><br><span class="line">遇到连续<span class="number">3</span>个一样的字符就消去，输出给定字符串消消乐后的最终结果</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"><span class="comment"># 双指针</span></span><br><span class="line"></span><br><span class="line">s = <span class="string">&#x27;AAABBBDDDCCCCFCDDDCC&#x27;</span></span><br><span class="line">left = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> left &lt; <span class="built_in">len</span>(s):</span><br><span class="line">    right = left</span><br><span class="line">    <span class="keyword">while</span> right &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[right] == s[left]:</span><br><span class="line">        right += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> right &gt; <span class="number">2</span>:</span><br><span class="line">        s = s[:left] + s[right:]</span><br><span class="line">        left -= <span class="number">2</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        left = right</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure>



<h2 id="无重复三位数"><a href="#无重复三位数" class="headerlink" title="无重复三位数"></a>无重复三位数</h2><p>有1、2、3、4个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> arr:</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> arr:</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> arr:</span><br><span class="line">            <span class="keyword">if</span> i != j <span class="keyword">and</span> i != k <span class="keyword">and</span> j != k:</span><br><span class="line">                res.append(i*<span class="number">100</span> + j*<span class="number">10</span> +k*<span class="number">1</span>)</span><br><span class="line">print(res)               </span><br></pre></td></tr></table></figure>



<h2 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143. 最长公共子序列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-common-subsequence/">1143. 最长公共子序列</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonSubsequence</span>(<span class="params">self, text1, text2</span>):</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(text1), <span class="built_in">len</span>(text2)</span><br><span class="line">        dp = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> text1[i - <span class="number">1</span>] == text2[j - <span class="number">1</span>]:</span><br><span class="line">                    <span class="comment"># 可以定义 dp[i][j] 表示 text1[0:i-1] 和 text2[0:j-1] 的最长公共子序列</span></span><br><span class="line">                    <span class="comment"># 两个子字符串的最后一位相等，所以最长公共子序列又增加了 1</span></span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 那么此时的状态 dp[i][j] 应该是 dp[i - 1][j] 和 dp[i][j - 1] 的最大值</span></span><br><span class="line">                    <span class="comment"># 举个例子，比如对于 ace 和 bc 而言，他们的最长公共子序列的长度等于 ① ace 和 b 的最长公共子序列长度0 与</span></span><br><span class="line">                    <span class="comment"># ② ac 和 bc 的最长公共子序列长度1 的最大值，即 1。</span></span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>



<h2 id="Flask-加法"><a href="#Flask-加法" class="headerlink" title="Flask 加法"></a>Flask 加法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, render_template, request, url_for</span><br><span class="line"><span class="keyword">from</span> add <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"> </span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">home</span>():</span></span><br><span class="line">  <span class="keyword">return</span> render_template(<span class="string">&#x27;index.html&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>():</span></span><br><span class="line">    a = request.form[<span class="string">&#x27;adder1&#x27;</span>]</span><br><span class="line">    b = request.form[<span class="string">&#x27;adder2&#x27;</span>]</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">      a = <span class="built_in">float</span>(a)</span><br><span class="line">      b = <span class="built_in">float</span>(b)</span><br><span class="line">      result = sum_function(a, b)</span><br><span class="line">      <span class="keyword">return</span> render_template(<span class="string">&#x27;index.html&#x27;</span>, result=result, var1=a, var2=b)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">      <span class="keyword">return</span> render_template(<span class="string">&#x27;index.html&#x27;</span>, message=<span class="string">&#x27;inputs false!!!&#x27;</span>, var1=a, var2=b)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">  app.run(port=<span class="number">8080</span>)</span><br></pre></td></tr></table></figure>

<h2 id="字符串匹配问题（kmp算法）我主动写了一下代码"><a href="#字符串匹配问题（kmp算法）我主动写了一下代码" class="headerlink" title="字符串匹配问题（kmp算法）我主动写了一下代码"></a>字符串匹配问题（kmp<a href="">算法</a>）我主动写了一下代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切片</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span>(<span class="params">self, haystack: <span class="built_in">str</span>, needle: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> needle <span class="keyword">not</span> <span class="keyword">in</span> haystack:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> needle == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(haystack)):</span><br><span class="line">                <span class="keyword">if</span> haystack[i:<span class="built_in">len</span>(needle)+i] == needle[:]:</span><br><span class="line">                    <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line"><span class="comment"># KMP</span></span><br><span class="line"></span><br><span class="line">// 方法二</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span>(<span class="params">self, haystack: <span class="built_in">str</span>, needle: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        a=<span class="built_in">len</span>(needle)</span><br><span class="line">        b=<span class="built_in">len</span>(haystack)</span><br><span class="line">        <span class="keyword">if</span> a==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        i=j=<span class="number">0</span></span><br><span class="line">        <span class="built_in">next</span>=self.getnext(a,needle)</span><br><span class="line">        <span class="keyword">while</span>(i&lt;b <span class="keyword">and</span> j&lt;a):</span><br><span class="line">            <span class="keyword">if</span> j==-<span class="number">1</span> <span class="keyword">or</span> needle[j]==haystack[i]:</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">                j+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j=<span class="built_in">next</span>[j]</span><br><span class="line">        <span class="keyword">if</span> j==a:</span><br><span class="line">            <span class="keyword">return</span> i-j</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getnext</span>(<span class="params">self,a,needle</span>):</span></span><br><span class="line">        <span class="built_in">next</span>=[<span class="string">&#x27;&#x27;</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(a)]</span><br><span class="line">        j,k=<span class="number">0</span>,-<span class="number">1</span></span><br><span class="line">        <span class="built_in">next</span>[<span class="number">0</span>]=k</span><br><span class="line">        <span class="keyword">while</span>(j&lt;a-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> k==-<span class="number">1</span> <span class="keyword">or</span> needle[k]==needle[j]:</span><br><span class="line">                k+=<span class="number">1</span></span><br><span class="line">                j+=<span class="number">1</span></span><br><span class="line">                <span class="built_in">next</span>[j]=k</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                k=<span class="built_in">next</span>[k]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">next</span></span><br></pre></td></tr></table></figure>



<h2 id="找出不同文件中相同的IP地址"><a href="#找出不同文件中相同的IP地址" class="headerlink" title="找出不同文件中相同的IP地址"></a>找出不同文件中相同的IP地址</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">grep  -Ff  my.txt  ip.txt</span><br><span class="line">diff my.txt ip.txt</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;testt&quot;</span>,<span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f1:</span><br><span class="line">    list1 = f1.readlines() <span class="comment"># 行读取</span></span><br><span class="line">    print(list1)</span><br><span class="line"><span class="comment">#list1 = set(list1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;test2&quot;</span>,<span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f2:</span><br><span class="line">    list2 = f2.readlines()</span><br><span class="line">    print(list2)</span><br><span class="line"><span class="comment">#list2 = set(list2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2个文件的list进行比较，有重复取出</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_same_ip_for_two_file</span>(<span class="params">file1,file2</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(file1,<span class="built_in">list</span>) <span class="keyword">and</span> <span class="built_in">isinstance</span>(file2,<span class="built_in">list</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> file2:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> file1:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="排序算法比较"><a href="#排序算法比较" class="headerlink" title="排序算法比较"></a>排序算法比较</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gv890goha7j60qu0gc41z02.jpg" alt="849589-20171015233043168-1867817869.png"></p>
<ul>
<li>稳定性：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，A1=A2，且A1在A2之前，而在排序后的序列中，A1仍在A2之前，则称这种排序算法是稳定的；否则称为不稳定的。</li>
<li>排序方式</li>
</ul>
<h2 id="1-冒泡排序-BubbleSort"><a href="#1-冒泡排序-BubbleSort" class="headerlink" title="1 冒泡排序_BubbleSort"></a>1 冒泡排序_BubbleSort</h2><blockquote>
<p>冒泡排序是通过多次的比较和交换逐渐将序列排序的方法。大（小）的元素会经过交换<code>浮出</code>水面。</p>
</blockquote>
<ul>
<li>每次对相邻的两个数进行比较，若符合大小关系，则交换两个数；</li>
<li>每经过一次排序，将最大（小）的数放在后（前）面，剩下的未排序.length - 1。</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gbtoun6ic4g30m908r0wt.gif" alt="img"></p>
<p>算法分析：稳定排序，内排序，时间复杂度：O(n^2)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span>(<span class="params">nums</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 进行多次循环</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n - c): <span class="comment"># 搜索区间减少 c 个</span></span><br><span class="line">            <span class="keyword">if</span> nums[i - <span class="number">1</span>] &gt; nums[i]:</span><br><span class="line">                nums[i - <span class="number">1</span>], nums[i] = nums[i], nums[i - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>



<h2 id="2-选择排序-SelectionSort"><a href="#2-选择排序-SelectionSort" class="headerlink" title="2 选择排序_SelectionSort"></a>2 选择排序_SelectionSort</h2><blockquote>
<p>选择排序，每次遍历序列，找到最小（大）的数，并放在序列的最前面，对剩下未排序的序列重复上述操作。</p>
</blockquote>
<ul>
<li>每次初始设定为未序列的元素第一个为最小（大）元素，首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置；</li>
<li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾；</li>
<li>重复第二步，直到所有元素均排序完毕。</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gbtprp6xjfg30mj06wdsb.gif" alt="img"></p>
<p><strong>稳定性：</strong>用数组实现的选择排序是不稳定的，用链表实现的选择排序是稳定的；时间复杂度：O(n^2) ，<code>n</code>是数组长度</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selection_sort</span>(<span class="params">nums</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="comment"># n2</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, n): <span class="comment"># 空间从头开始缩减</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; nums[j]:</span><br><span class="line">                nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>



<h2 id="3-插入排序-InsertionSort"><a href="#3-插入排序-InsertionSort" class="headerlink" title="3 插入排序_InsertionSort"></a>3 插入排序_InsertionSort</h2><blockquote>
<p>插入排序的基本操作就是从未排序的序列中取出一个数，插入到已经排序序列的正确位置中。</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gbtqzysve0g30mj0e1n6v.gif" alt="img"></p>
<p><strong>算法分析：</strong>稳定排序，内排序，时间复杂度：O(n^2)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertion_sort</span>(<span class="params">nums</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        <span class="keyword">while</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i - <span class="number">1</span>] &gt; nums[i]:</span><br><span class="line">            nums[i - <span class="number">1</span>], nums[i] = nums[i], nums[i - <span class="number">1</span>] <span class="comment"># 交换</span></span><br><span class="line">            i -= <span class="number">1</span> <span class="comment"># 倒回去比较</span></span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>





<h2 id="4-希尔排序-ShellSort"><a href="#4-希尔排序-ShellSort" class="headerlink" title="4 希尔排序_ShellSort"></a>4 希尔排序_ShellSort</h2><blockquote>
<p>先将整个序列划分为若若干子序列，分别进行插入排序排序。开始增量（Gap）= int(arr.length/2)，经过一次排序后，增量 int(arr.length/2)/2，一直到增量 = 1。</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gbuvgp28bag307p09kgsu.gif" alt="img"></p>
<p>算法分析：非稳定排序，内排序，O(nlogn)；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_sort</span>(<span class="params">nums</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    gap = n // <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> gap:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(gap, n):</span><br><span class="line">            <span class="keyword">while</span> i - gap &gt;= <span class="number">0</span> <span class="keyword">and</span> nums[i - gap] &gt; nums[i]:</span><br><span class="line">                nums[i - gap], nums[i] = nums[i], nums[i - gap] <span class="comment"># 交换 Gap 增量</span></span><br><span class="line">                i -= gap</span><br><span class="line">        gap //= <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>



<h2 id="5-归并排序-MergeSort"><a href="#5-归并排序-MergeSort" class="headerlink" title="5 归并排序_MergeSort"></a>5 归并排序_MergeSort</h2><blockquote>
<p>归并排序的思想：将序列分解成最小有序子序列，再逐个将有序的子序列进行合并，得到有序的子序列段，最终得到一个完整的有序序列。</p>
<p><strong>分治：先将数组分成子序列，让子序列有序，再将子序列间有序，合并成有序数组。</strong></p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gbuvg1qamsg30mj0e1k05.gif" alt="img"></p>
<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gv87ene21hj611h0u0whh02.jpg" style="zoom:50%;" />

<p>算法分析：稳定排序，外排序（占用额外内存），时间复杂度O(nlogn)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span>(<span class="params">nums</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    mid = <span class="built_in">len</span>(nums) // <span class="number">2</span></span><br><span class="line">    <span class="comment"># 分</span></span><br><span class="line">    left = merge_sort(nums[:mid])</span><br><span class="line">    right = merge_sort(nums[mid:])</span><br><span class="line">    <span class="comment"># 合并</span></span><br><span class="line">    <span class="keyword">return</span> merge(left, right)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">left, right</span>):</span></span><br><span class="line">    res = []</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(left) <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(right):</span><br><span class="line">        <span class="keyword">if</span> left[i] &lt;= right[j]:</span><br><span class="line">            res.append(left[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res.append(right[j])</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">    <span class="comment"># +, 而不是追加</span></span><br><span class="line">    res += left[i:]</span><br><span class="line">    res += right[j:]</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>





<h2 id="6-快速排序-QuickSort"><a href="#6-快速排序-QuickSort" class="headerlink" title="6 快速排序_QuickSort"></a>6 快速排序_QuickSort</h2><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p>
<ul>
<li>步骤1：从数列中挑出一个元素，称为 “基准”（pivot ）；</li>
<li>步骤2：重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后；该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>
<li>步骤3：递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>
</ul>
<p><img src="https://pic.leetcode-cn.com/d13bd82917a8eba049efa261bebd3beb74b9e7c1adf39ce51bf1c9dd60d49f57-Quicksort-example.gif"></p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gbuvm1jkf0g30mj070jyl.gif" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20191204143557117.gif#pic_center#pic_center"></p>
<p>算法分析：不稳定排序，内排序，时间复杂度度O(nlogn)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 版本</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span>(<span class="params">nums</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quick</span>(<span class="params">left, right</span>):</span></span><br><span class="line">        <span class="keyword">if</span> left &gt;= right:</span><br><span class="line">            <span class="keyword">return</span> nums</span><br><span class="line">        pivot = left</span><br><span class="line">        i = left</span><br><span class="line">        j = right</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> nums[j] &gt; nums[pivot]:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> nums[i] &lt;= nums[pivot]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">        nums[pivot], nums[j] = nums[j], nums[pivot]</span><br><span class="line">        </span><br><span class="line">        quick(left, j - <span class="number">1</span>)</span><br><span class="line">        quick(j + <span class="number">1</span>, right)</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> quick(<span class="number">0</span>, n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>





<h2 id="7-堆排序-HeapSort"><a href="#7-堆排序-HeapSort" class="headerlink" title="7 堆排序_HeapSort"></a>7 堆排序_HeapSort</h2><p>堆排序是利用堆这个数据结构设计的排序算法。</p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gbuvq87o7sg30f70a4hdt.gif" alt="img"></p>
<p>建堆，<strong>从底向上</strong>（自底向上）调整堆，使得父亲节点比孩子节点值大，构成大顶堆；,交换堆顶和最后一个元素，重新调整堆。</p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gbuvq613sbg30go0goabf.gif" alt="img"></p>
<p>算法分析：不稳定排序，内排序，时间复杂度为O(nlogn)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span>(<span class="params">nums</span>):</span></span><br><span class="line">    <span class="comment"># 调整堆    </span></span><br><span class="line">    <span class="comment"># 递归写法，自底向上</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">adjust_heap</span>(<span class="params">nums, startpos, endpos</span>):</span></span><br><span class="line">        pos = startpos</span><br><span class="line">        chilidpos = pos * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> chilidpos &lt; endpos:</span><br><span class="line">            rightpos = chilidpos + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> rightpos &lt; endpos <span class="keyword">and</span> nums[rightpos] &gt; nums[chilidpos]:</span><br><span class="line">                chilidpos = rightpos</span><br><span class="line">            <span class="keyword">if</span> nums[chilidpos] &gt; nums[pos]:</span><br><span class="line">                nums[pos], nums[chilidpos] = nums[chilidpos], nums[pos]</span><br><span class="line">                adjust_heap(nums, pos, endpos)</span><br><span class="line"></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="comment"># 建堆</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="built_in">range</span>(n // <span class="number">2</span>)):</span><br><span class="line">        adjust_heap(nums, i, n)</span><br><span class="line">    <span class="comment"># 调整堆</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        nums[<span class="number">0</span>], nums[i] = nums[i], nums[<span class="number">0</span>]</span><br><span class="line">        adjust_heap(nums, <span class="number">0</span>, i)</span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>



<h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-parentheses/">20. 有效的括号</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">这个思考的过程其实就是栈的实现过程。因此我们考虑使用栈，当遇到匹配的最小括号对时，我们将这对括号从栈中删除（即出栈），如果最后栈为空，那么它是有效的括号，反之不是。</span><br><span class="line"><span class="comment"># s = &quot;()[]&#123;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        dic = &#123;<span class="string">&#x27;)&#x27;</span>:<span class="string">&#x27;(&#x27;</span>,<span class="string">&#x27;]&#x27;</span>:<span class="string">&#x27;[&#x27;</span>,<span class="string">&#x27;&#125;&#x27;</span>:<span class="string">&#x27;&#123;&#x27;</span>&#125;</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> stack <span class="keyword">and</span> i <span class="keyword">in</span> dic:</span><br><span class="line">                <span class="keyword">if</span> stack[-<span class="number">1</span>] == dic[i]: </span><br><span class="line">                    stack.pop()</span><br><span class="line">                <span class="keyword">else</span>: </span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> stack</span><br><span class="line"></span><br><span class="line">作者：z1m</span><br><span class="line">链接：https://leetcode-cn.com/problems/valid-parentheses/solution/zhu-bu-fen-xi-tu-jie-zhan-zhan-shi-zui-biao-zhun-d/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>





<h1 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h1><h2 id="数据结构算法"><a href="#数据结构算法" class="headerlink" title="数据结构算法"></a>数据结构算法</h2><p>常见的数据结构</p>
<ul>
<li><strong>栈（Stack）：</strong>栈是一种特殊的线性表，它只能在一个表的一个固定端进行数据结点的插入和删除操作。</li>
<li><strong>队列（Queue）：</strong>队列和栈类似，也是一种特殊的线性表。和栈不同的是，队列只允许在表的一端进行插入操作，而在另一端进行删除操作。</li>
<li><strong>数组（Array）：</strong>数组是一种聚合数据类型，它是将具有相同类型的若干变量有序地组织在一起的集合。</li>
<li><strong>链表（Linked List）：</strong>链表是一种数据元素按照链式存储结构进行存储的数据结构，这种存储结构具有在物理上存在非连续的特点。</li>
<li><strong>树（Tree）：</strong>树是典型的非线性结构，它是包括，2 个结点的有穷集合 K。</li>
<li><strong>图（Graph）：</strong>图是另一种非线性数据结构。在图结构中，数据结点一般称为顶点，而边是顶点的有序偶对。</li>
<li><strong>堆（Heap）：</strong>堆是一种特殊的树形数据结构，一般讨论的堆都是二叉堆。</li>
<li><strong>散列表（Hash table）：</strong>散列表源自于散列函数(Hash function)，其思想是如果在结构中存在关键字和T相等的记录，那么必定在F(T)的存储位置可以找到该记录，这样就可以不用进行比较操作而直接取得所查记录。</li>
</ul>
<h2 id="Hashmap处理哈希冲突的分析方法"><a href="#Hashmap处理哈希冲突的分析方法" class="headerlink" title="Hashmap处理哈希冲突的分析方法"></a>Hashmap处理哈希冲突的分析方法</h2><p><strong>哈希算法</strong>：根据设定的哈希函数H（key）和处理冲突方法将一组关键字映象到一个有限的地址区间上的算法。</p>
<ul>
<li>求模</li>
</ul>
<p><strong>哈希表</strong>：数据经过哈希算法之后得到的集合。这样关键字和数据在集合中的位置存在一定的关系，可以根据这种关系快速查询。</p>
<p><strong>哈希冲突</strong>：对于散列表而言，无论设置的存储区域（n）有多大，当需要存储的数据大于 n 时，那么必然会存在哈希值相同的情况。这就是所谓的<strong>散列冲突</strong>。</p>
<h3 id="开放定址法"><a href="#开放定址法" class="headerlink" title="开放定址法"></a>开放定址法</h3><p>从发生冲突的那个单元起，按照一定的次序，从哈希表中找到一个空闲的单元。然后把发生冲突的元素存入到该单元的一种方法。开放定址法需要的表长度要大于等于所需要存放的元素。 在开放定址法中解决冲突的方法有：线行探查法、平方探查法、双散列函数探查法。 开放定址法的缺点在于删除元素的时候不能真的删除，否则会引起查找错误，只能做一个特殊标记。只到有下个元素插入才能真正删除该元素。</p>
<h4 id="线行探查法"><a href="#线行探查法" class="headerlink" title="线行探查法"></a>线行探查法</h4><p>线行探查法是开放定址法中最简单的冲突处理方法，它从发生冲突的单元起，依次判断下一个单元是否为空，当达到最后一个单元时，再从表首依次判断。直到碰到空闲的单元或者探查完全部单元为止。 </p>
<h4 id="平方探查法"><a href="#平方探查法" class="headerlink" title="平方探查法"></a>平方探查法</h4><p>平方探查法即是发生冲突时，用发生冲突的单元d[i], 加上 1²、 2²等。即d[i] + 1²，d[i] + 2², d[i] + 3²…直到找到空闲单元。 在实际操作中，平方探查法不能探查到全部剩余的单元。不过在实际应用中，能探查到一半单元也就可以了。若探查到一半单元仍找不到一个空闲单元，表明此散列表太满，应该重新建立。</p>
<h4 id="双散列函数探查法"><a href="#双散列函数探查法" class="headerlink" title="双散列函数探查法"></a>双散列函数探查法</h4><p>这种方法使用两个散列函数hl和h2。其中hl和前面的h一样，以关键字为自变量，产生一个0至m—l之间的数作为散列地址；h2也以关键字为自变量，产生一个l至m—1之间的、并和m互素的数(即m不能被该数整除)作为探查序列的地址增量(即步长)，探查序列的步长值是固定值l；对于平方探查法，探查序列的步长值是探查次数i的两倍减l；对于双散列函数探查法，其探查序列的步长值是同一关键字的另一散列函数的值。</p>
<h3 id="链地址法（拉链法）"><a href="#链地址法（拉链法）" class="headerlink" title="链地址法（拉链法）"></a>链地址法（拉链法）</h3><p>链接地址法的思路是将哈希值相同的元素构成一个同义词的单链表，并将单链表的头指针存放在哈希表的第i个单元中，查找、插入和删除主要在同义词链表中进行。链表法适用于经常进行插入和删除的情况。 如下一组数字,(32、40、36、53、16、46、71、27、42、24、49、64)哈希表长度为13，哈希函数为H(key)=key%13,则链表法结果如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>       </span><br><span class="line"><span class="number">1</span>  -&gt; <span class="number">40</span> -&gt; <span class="number">27</span> -&gt; <span class="number">53</span> </span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span>  -&gt; <span class="number">16</span> -&gt; <span class="number">42</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span>  -&gt; <span class="number">32</span> -&gt; <span class="number">71</span></span><br><span class="line"><span class="number">7</span>  -&gt; <span class="number">46</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span> -&gt; <span class="number">36</span> -&gt; <span class="number">49</span></span><br><span class="line"><span class="number">11</span> -&gt; <span class="number">24</span></span><br><span class="line"><span class="number">12</span> -&gt; <span class="number">64</span></span><br></pre></td></tr></table></figure>

<h3 id="再哈希法"><a href="#再哈希法" class="headerlink" title="再哈希法"></a>再哈希法</h3><p>就是同时构造多个不同的哈希函数： Hi = RHi(key)   i= 1,2,3 … k; 当H1 = RH1(key)  发生冲突时，再用H2 = RH2(key) 进行计算，直到冲突不再产生，这种方法不易产生聚集，但是增加了计算时间。</p>
<h3 id="建立公共溢出区"><a href="#建立公共溢出区" class="headerlink" title="建立公共溢出区"></a>建立公共溢出区</h3><p>将哈希表分为公共表和溢出表，当溢出发生时，将所有溢出数据统一放到溢出区。</p>
<h2 id="堆排序，大堆，小堆，堆排序的原理"><a href="#堆排序，大堆，小堆，堆排序的原理" class="headerlink" title="堆排序，大堆，小堆，堆排序的原理"></a>堆<a href="">排序</a>，大堆，小堆，堆<a href="">排序</a>的原理</h2><p>我们知道堆是一个完全二叉树了，那么堆又分两种堆：<strong>大顶堆</strong> 和 <strong>小顶堆</strong>它们符合一个重要的性质：</p>
<ul>
<li>小顶堆满足： Key[i] &lt;= key[2i+1] &amp;&amp; Key[i] &lt;= key[2i+2] </li>
<li>大顶堆满足： Key[i] &gt;= Key[2i+1] &amp;&amp; key &gt;= key[2i+2] </li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gw15b8vxajj30nh085jro.jpg" alt="img"></p>
<h2 id="统计一篇论文，前面出现前十的单词。Counter-List"><a href="#统计一篇论文，前面出现前十的单词。Counter-List" class="headerlink" title="统计一篇论文，前面出现前十的单词。Counter(), List"></a>统计一篇论文，前面出现前十的单词。Counter(), List</h2><p>Linux：<code>cat &lt;em&gt;filename&lt;/em&gt; | sort | unique -c | sort -k1,1nr | head 10</code></p>
<p>list –&gt; dict count(key)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#统计为字典</span></span><br><span class="line">counts=&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> all_set:</span><br><span class="line">     counts[key] = all_C.count(key)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter   </span><br><span class="line">wordList = []</span><br><span class="line"><span class="comment">#统计每个词出现的次数</span></span><br><span class="line">wordList = Counter( words )</span><br><span class="line"><span class="comment">#统计出现的次数最多的N个词及出现的次数</span></span><br><span class="line">wordListNTop = wordList.most_common( N )</span><br></pre></td></tr></table></figure>



<h2 id="元组和列表的区别"><a href="#元组和列表的区别" class="headerlink" title="元组和列表的区别"></a>元组和列表的区别</h2><ul>
<li><p>元组：元组中的元素无法修改，除非将元组整体替换掉，tuple 元组是一个只读版本的 list 列表，性能好（没有指针）。而元组是静态的，长度大小固定，无法增加删减或者改变（immutable）。</p>
</li>
<li><p>列表：列表中的元素可以进行任意修改表是动态的，长度大小不固定，可以随意地增加、删减或者改变元素（mutable）。</p>
</li>
</ul>
<h2 id="装饰器的作用"><a href="#装饰器的作用" class="headerlink" title="装饰器的作用"></a>装饰器的作用</h2><p>装饰器（Decorators） 是 Python 的一个重要部分。简单地说：他们是修改其他函数的功能的函数。是一种函数的函数，因为装饰器传入的参数就是一个函数，然后通过实现各种功能来对这个函数的功能进行增强。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;123&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hello</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;同学你好&#x27;</span>)</span><br><span class="line"></span><br><span class="line">say_hello()</span><br></pre></td></tr></table></figure>

<ul>
<li> wraps 装饰器</li>
</ul>
<p>一个函数不止有他的执行语句，还有着 <code>__name__</code>（函数名），<code>__doc__</code> （说明文档）等属性，我们之前的例子会导致这些属性改变。</p>
<ul>
<li>内置装饰器</li>
</ul>
<p>有三种我们经常会用到的装饰器， <code>property</code>、 <code>staticmethod</code>、 <code>classmethod</code>，他们有个共同点，都是作用于类方法之上。</p>
<ul>
<li>类装饰器</li>
</ul>
<h2 id="Python2和Python3之间的区别"><a href="#Python2和Python3之间的区别" class="headerlink" title="Python2和Python3之间的区别"></a>Python2和Python3之间的区别</h2><ul>
<li>print 不同</li>
<li>编码不同： 2是ASCII（原因在于 Python这门语言诞生的时候还没出现 Unicode） 3是UTF-8</li>
<li>字符串：str–&gt;byte unicode–&gt;str</li>
<li>True 和 False 变为两个关键字,永远指向两个固定的对象，不允许再被重新赋值, True = 1 报错</li>
<li>迭代器：xrange 返回列表对象， next</li>
<li>global nonlocal,非局部变量</li>
<li>format</li>
<li>统一 int</li>
</ul>
<h2 id="Python的优缺点"><a href="#Python的优缺点" class="headerlink" title="Python的优缺点"></a>Python的优缺点</h2><p>优点：</p>
<ul>
<li>开源。。。</li>
<li>Python 简单易用，学习成本低，看起来非常优雅干净，代码舒适；</li>
<li>面向对象，可扩展性强</li>
<li>Python 标准库和第三库众多，功能强大，既可以开发小工具，也可以开发企业级应用；</li>
<li>Python 站在了人工智能和<a target="_blank" rel="noopener" href="http://c.biancheng.net/big_data/">大数据</a>的风口上。</li>
</ul>
<p>缺点：</p>
<ul>
<li>运行速度慢是解释型语言的通病，Python 也不例外。（<strong>解释型语言</strong>（英语：Interpreted language）是一种编程<strong>语言</strong>类型。 这种类型的程式<strong>语言</strong>，会将程式码一句一句直接执行，不需要像编译<strong>语言</strong>（Compiled language）一样，经过编译器先行编译为机器码，之后再执行。）</li>
<li>强类型语言（python属于强类型）   数据类型不可以被忽略的语言 即变量的数据类型一旦被定义，那就不会再改变，除非进行强转。 在python中，例如：name = ‘egon’，这个变量name在被赋值的那一刻，数据类型就被确定死了，是字符型，值为’egon’。 </li>
<li>动态：运行时才进行数据类型检查 即在变量赋值时，就确定了变量的数据类型，不用事先给变量指定数据类型  </li>
<li>伪多线程</li>
</ul>
<h2 id="提高Python运行效率的方法"><a href="#提高Python运行效率的方法" class="headerlink" title="提高Python运行效率的方法"></a>提高Python运行效率的方法</h2><ul>
<li>外部包，<strong>关键代码使用外部功能包</strong><ul>
<li>Cython Pylnlne PyPy Pyrex</li>
</ul>
</li>
<li>使用局部变量，便于维护，提高性能并节省内存。</li>
<li><strong>先编译后调用</strong></li>
<li><strong>采用生成器表达式替代列表解析</strong></li>
<li>排序：最佳的排序方法其实是尽可能多地使用键和内置的 sort() 方法。</li>
<li><strong>优化算法时间</strong></li>
<li><strong>循环优化</strong></li>
<li>多核 多线程 ：因为GIL的存在，Python很难充分利用多核CPU的优势。但是，可以通过内置的模块multiprocessing实现下面几种并行模式：</li>
</ul>
<h2 id="判别两个类别的字符串"><a href="#判别两个类别的字符串" class="headerlink" title="判别两个类别的字符串"></a>判别两个类别的字符串</h2><h2 id="python垃圾回收"><a href="#python垃圾回收" class="headerlink" title="python垃圾回收"></a>python垃圾回收</h2><p><strong>引用计数为主，分代收集为辅。</strong>在 python 中，<strong>如果一个对象的引用数为 0， python 虚拟机就会回收这个对象的内存。</strong></p>
<ul>
<li><p>导致引用计数 +1 的情况：</p>
<blockquote>
<ul>
<li>对象被创建： a = classname()</li>
<li>对象被引用： b = a</li>
<li>对象被作为参数，传入到一个函数中： func(a)</li>
<li>对象作为一个元素，存储在容器内： list_name = [a, a]</li>
</ul>
</blockquote>
</li>
<li><p>导致引用计数 -1 的情况：</p>
<blockquote>
<ul>
<li>对象的别名被显式销毁， 如： del a </li>
<li>对象的别名被赋予新的对象，如：a = other_class()</li>
<li>一个对象离开它的作用域，如函数执行完毕时，func 函数中的局部变量</li>
<li>对象所在的容器被销毁，或从容器中删除对象</li>
</ul>
</blockquote>
</li>
</ul>
<p><strong>循环引用导致内存泄漏</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">c1 = ClassA() <span class="comment"># 内存 1 引用计数 +1 = 1</span></span><br><span class="line">c2 = ClassA() <span class="comment"># 内存 2 引用计数 +1 = 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环引用</span></span><br><span class="line">c1.t=c2  <span class="comment">#  内存 2 引用计数 +1 = 2</span></span><br><span class="line">c2.t=c1  <span class="comment">#  内存 1 引用计数 +1 = 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> c1  <span class="comment"># 内存 1 引用计数 -1 = 1</span></span><br><span class="line"><span class="keyword">del</span> c2  <span class="comment"># 内存 2 引用计数 -1 = 1 如上文描述，由于**循环引用**，导致垃圾回收器都不会回收它们，所以就会导致内存泄露。</span></span><br></pre></td></tr></table></figure>

<p><strong>垃圾回收机制模块： gc</strong></p>
<h2 id="浅、深拷贝"><a href="#浅、深拷贝" class="headerlink" title="浅、深拷贝"></a>浅、深拷贝</h2><ul>
<li><strong>直接赋值：</strong>其实就是对象的引用（别名）。</li>
<li><strong>浅拷贝(copy)：</strong>拷贝父对象，不会拷贝对象的内部的子对象。</li>
<li><strong>深拷贝(deepcopy)：</strong> copy 模块的 deepcopy 方法，完全拷贝了父对象及其子对象。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 浅</span></span><br><span class="line"><span class="comment"># 浅拷贝, a 和 b 是一个独立的对象，但他们的子对象还是指向统一对象（是引用）。</span></span><br><span class="line">&gt;&gt;&gt;a = &#123;<span class="number">1</span>: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a.copy()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b</span><br><span class="line">(&#123;<span class="number">1</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;, &#123;<span class="number">1</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>].append(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b</span><br><span class="line">(&#123;<span class="number">1</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]&#125;, &#123;<span class="number">1</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----------------------------------------</span><br><span class="line"><span class="comment"># 深</span></span><br><span class="line"><span class="comment">## 需要导入 copy, 深度拷贝, a 和 b 完全拷贝了父对象及其子对象，两者是完全独立的。</span></span><br><span class="line">&gt;&gt;&gt;<span class="keyword">import</span> copy</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = copy.deepcopy(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, c</span><br><span class="line">(&#123;<span class="number">1</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]&#125;, &#123;<span class="number">1</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>].append(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, c</span><br><span class="line">(&#123;<span class="number">1</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]&#125;, &#123;<span class="number">1</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]&#125;)</span><br></pre></td></tr></table></figure>



<p><strong>b=a</strong> 赋值引用，a 和 b 都指向同一个对象。<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gulaxem2zdj609u06uaa302.jpg" alt="img"></p>
<p>**b = a.copy():**浅拷贝, a 和 b 是一个独立的对象，但他们的子对象还是指向统一对象（是引用）<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gulay0ol1fj60ac0780sv02.jpg" alt="img"></p>
<p><strong>b = copy.deepcopy(a):</strong> 深度拷贝, a 和 b 完全拷贝了父对象及其子对象，两者是完全独立的。<img src="https://www.runoob.com/wp-content/uploads/2017/03/1489720930-5882-BO4qO.png" alt="img"></p>
<h2 id="10亿个数取最大的10个怎么取，说三种方案"><a href="#10亿个数取最大的10个怎么取，说三种方案" class="headerlink" title="10亿个数取最大的10个怎么取，说三种方案"></a>10亿个数取最大的10个怎么取，说三种方案</h2><p>直接排序<br>最容易想到的方法是将数据全部排序，然后在排序后的集合中进行查找，最快的排序算法的时间复杂度一般为O（nlogn），如快速排序。但是在32位的机器上，每个float类型占4个字节，1亿个浮点数就要占用400MB的存储空间，对于一些可用内存小于400M的计算机而言，很显然是不能一次将全部数据读入内存进行排序的。其实即使内存能够满足要求（我机器内存都是8GB），该方法也并不高效，因为题目的目的是寻找出最大的1000个数即可，而排序却是将所有的元素都排序了，做了很多的无用功。</p>
<p><strong>局部淘汰法</strong><br>第二种方法为局部淘汰法，该方法与排序方法类似，用一个容器保存<strong>前1000个数</strong>，然后将剩余的所有数字——<strong>与容器内的最小数字相比</strong>，如果所有后续的元素都比容器内的1000个数还小，那么容器内这个1000个数就是最大1000个数。如果某一后续元素比容器内最小数字大，则删掉容器内最小元素，并将该元素插入容器，最后遍历完这1亿个数，得到的结果容器中保存的数即为最终结果了。此时的时间复杂度为O（n+m^2），其中m为容器的大小，即1000。</p>
<p><strong>分治法</strong><br>第三种方法是分治法，将1亿个数据分成100份，每份100万个数据，找到每份数据中最大的1000个，最后在剩下的100*1000个数据里面找出最大的1000个。如果100万数据选择足够理想，那么可以过滤掉1亿数据里面99%的数据。100万个数据里面查找最大的1000个数据的方法如下：用快速排序的方法。</p>
<p><strong>Hash法</strong><br>第四种方法是Hash法。如果这1亿个数里面有很多重复的数，先通过Hash法，把这1亿个数字去重复，这样如果重复率很高的话，会减少很大的内存用量，从而缩小运算空间，然后通过分治法或最小堆法查找最大的1000个数。</p>
<p><strong>最小堆</strong><br>第五种方法采用最小堆。首先读入前1000个数来创建大小为1000的最小堆，建堆的时间复杂度为O（mlogm）（m为数组的大小即为1000），然后遍历后续的数字，并于堆顶（最小）数字进行比较。如果比最小的数小，则继续读取后续数字；如果比堆顶数字大，则替换堆顶元素并重新调整堆为最小堆。整个过程直至1亿个数全部遍历完为止。然后输出当前堆中的所有1000个数字。该算法的时间复杂度为O（nmlogm），空间复杂度是1000（常数）。</p>
<h2 id="linux命令说几个"><a href="#linux命令说几个" class="headerlink" title="linux命令说几个"></a>linux命令说几个</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvmyj6ow8qj60ns1cgwgy02.jpg"></p>
<h2 id="分库分表目的"><a href="#分库分表目的" class="headerlink" title="分库分表目的"></a>分库分表目的</h2><h2 id="Python锁"><a href="#Python锁" class="headerlink" title="Python锁"></a>Python锁</h2><p>一、全局解释器锁（GIL）</p>
<p>1、什么是全局解释器锁</p>
<p><strong>每个CPU在同一时间只能执行一个线程，那么其他的线程就必须等待该线程的全局解释器，</strong>使用权消失后才能使用全局解释器，即使多个线程直接不会相互影响在同一个进程下也只有一个线程使用cpu，这样的机制称为全局解释器锁（GIL）。GIL的设计简化了CPython的实现，使的对象模型包括关键的内建类型，如：字典等，都是隐含的，可以并发访问的，锁住全局解释器使得比较容易的实现对多线程的支持，但也损失了多处理器主机的并行计算能力。</p>
<p>2、全局解释器锁的好处</p>
<p>1）避免了大量的加锁解锁的好处</p>
<p>2）使数据更加安全，解决多线程间的数据完整性和状态同步</p>
<p>3、全局解释器的缺点</p>
<p>多核处理器退化成单核处理器，只能并发不能并行。</p>
<p>4、GIL的作用：</p>
<p>多线程情况下必须存在资源的竞争，GIL是为了保证在解释器级别的线程唯一使用共享资源（cpu）。</p>
<p>二、同步锁</p>
<p>1、什么是同步锁？</p>
<p>同一时刻的一个进程下的一个线程只能使用一个cpu，要确保这个线程下的程序在一段时间内被cpu执，那么就要用到同步锁。</p>
<p>2、为什么用同步锁？</p>
<p>因为有可能当一个线程在使用cpu时，该线程下的程序可能会遇到io操作，那么cpu就会切到别的线程上去，这样就有可能会影响到该程　　序结果的完整性。</p>
<p>3、怎么使用同步锁？</p>
<p>只需要在对公共数据的操作前后加上上锁和释放锁的操作即可。</p>
<p>4、同步锁的所用：</p>
<p>为了保证解释器级别下的自己编写的程序唯一使用共享资源产生了同步锁。</p>
<p>三、死锁</p>
<p>1、什么是死锁？</p>
<p>指两个或两个以上的线程或进程在执行程序的过程中，因争夺资源或者程序推进顺序不当而相互等待的一个现象。</p>
<p>2、死锁产生的必要条件？</p>
<p>互斥条件、请求和保持条件、不剥夺条件、环路等待条件</p>
<p>3、处理死锁的基本方法？</p>
<p>预防死锁、避免死锁（银行家算法）、检测死锁（资源分配）、解除死锁：剥夺资源、撤销进程</p>
<p>四、什么是递归锁？</p>
<p>在Python中为了支持同一个线程中多次请求同一资源，Python提供了可重入锁。这个RLock内部维护着一个Lock和一个counter变量，counter记录了acquire的次数，从而使得资源可以被多次require。直到一个线程所有的acquire都被release，其他的线程才能获得资源。递归锁分为可递归锁与非递归锁。</p>
<p>五、什么是乐观锁？</p>
<p>假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。</p>
<p>六、什么是悲观锁？</p>
<p>假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。</p>
<p>七、python常用的加锁方式？</p>
<p>互斥锁、可重入锁、迭代死锁、互相调用死锁、自旋锁。</p>
<h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>在执行过程中，遇到<code>yield</code>就中断，下次又继续执行</p>
<p>[] –&gt; ()</p>
<p>batch</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h2 id="数组链表的区别，操作的复杂度"><a href="#数组链表的区别，操作的复杂度" class="headerlink" title="数组链表的区别，操作的复杂度"></a>数组<a href="">链表</a>的区别，操作的复杂度</h2><h2 id="写一个排序（随意），及有关该排序的一系列问题"><a href="#写一个排序（随意），及有关该排序的一系列问题" class="headerlink" title="写一个排序（随意），及有关该排序的一系列问题"></a>写一个<a href="">排序</a>（随意），及有关该<a href="">排序</a>的一系列问题</h2><h2 id="数据库的特性，如何实现"><a href="#数据库的特性，如何实现" class="headerlink" title="数据库的特性，如何实现"></a>数据库的特性，如何实现</h2><h2 id="mysql索引的原理及实现"><a href="#mysql索引的原理及实现" class="headerlink" title="mysql索引的原理及实现"></a>mysql索引的原理及实现</h2><h2 id="HTTPS如何实现安全性"><a href="#HTTPS如何实现安全性" class="headerlink" title="HTTPS如何实现安全性"></a>HTTPS如何实现安全性</h2><p>HTTPS 加密：<code>HTTPS = HTTP + SSL/TLS</code>，通过 <code>SSL</code>证书来验证服务器的身份，并为浏览器和服务器之间的通信进行加密</p>
<p><code>SSL</code> 协议位于<code> TCP/IP</code> 协议与各种应用层协议之间，浏览器和服务器在使用 <code>SSL</code> 建立连接时需要选择一组恰当的加密算法来实现安全通信，为数据通讯提供安全支持</p>
<h3 id="SSL-加密算法"><a href="#SSL-加密算法" class="headerlink" title="SSL 加密算法"></a>SSL 加密算法</h3><ul>
<li><p>对称加密：采用协商的密钥对数据加密</p>
<ul>
<li>对称加密指的是加密和解密使用的秘钥都是同一个，是对称的。只要保证了密钥的安全，那整个通信过程就可以说具有了机密性</li>
</ul>
</li>
<li><p>非对称加密：实现身份认证和密钥协商</p>
<ul>
<li>非对称加密，存在两个秘钥，一个叫公钥，一个叫私钥。两个秘钥是不同的，公钥可以公开给任何人使用，私钥则需要保密</li>
</ul>
</li>
<li><p>摘要算法：验证信息的完整性</p>
<ul>
<li>实现完整性的手段主要是摘要算法，也就是常说的散列函数、哈希函数。可以理解成一种特殊的压缩算法，它能够把任意长度的数据“压缩”成固定长度、而且独一无二的“摘要”字符串，就好像是给这段数据生成了一个数字“指纹”</li>
</ul>
</li>
<li><p>数字签名：身份验证</p>
<ul>
<li>用私钥加密，公钥解密。公钥身份确认，需要证书：<code>CA验证机构</code>: 数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场</li>
</ul>
</li>
</ul>
<h2 id="Python-经常使用的包"><a href="#Python-经常使用的包" class="headerlink" title="Python 经常使用的包"></a>Python 经常使用的包</h2><ul>
<li>数据分析：numpy pandas matploylib seaborn</li>
<li>图像处理：opencv、pil</li>
<li>机器学习：TF Pytorch sklearn </li>
<li>后端：flask requests</li>
</ul>
<h2 id="知道dict和set的底层原理吗？"><a href="#知道dict和set的底层原理吗？" class="headerlink" title="知道dict和set的底层原理吗？"></a>知道dict和set的底层原理吗？</h2><p> 答：<a href="">哈希表</a>的构造 </p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvzg1squ51j30ea0ciaaf.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvzg2ind8cj30fy09pwet.jpg"></p>
<p>dict是用来存储键值对结构的数据的，set其实也是存储的键值对，只是默认键和值是相同的。Python中的dict和set都是通过散列表来实现的。下面来看与dict相关的几个比较重要的问题：</p>
<p>dict中的数据是无序存放的<br>操作的时间复杂度，插入、查找和删除都可以在O(1)的时间复杂度<br>键的限制，只有可哈希的对象才能作为字典的键和set的值。可hash的对象即python中的不可变对象和自定义的对象。可变对象(列表、字典、集合)是不能作为字典的键和st的值的。<br>与list相比：list的查找和删除的时间复杂度是O(n)，添加的时间复杂度是O(1)。但是dict使用hashtable内存的开销更大。为了保证较少的冲突，hashtable的装载因子，一般要小于0.75，在python中当<strong>装载因子达到2/3</strong>的时候就会自动进行扩容。</p>
<h2 id="问课余生活干什么？（强调除了学习）"><a href="#问课余生活干什么？（强调除了学习）" class="headerlink" title="问课余生活干什么？（强调除了学习）"></a>问课余生活干什么？（强调除了学习）</h2><ul>
<li>弹吉他</li>
<li>数码爱好（DIY 耳机、键盘，华强北淘机）</li>
</ul>
<h2 id="数据库索引，b-树的特点，与hash索引有什么异同"><a href="#数据库索引，b-树的特点，与hash索引有什么异同" class="headerlink" title="数据库索引，b+树的特点，与hash索引有什么异同"></a>数据库索引，b+树的特点，与hash索引有什么异同</h2><p>B+树是一个平衡的多叉树。B+树从根节点到叶子节点的搜索效率基本相当，不会出现大幅波动。</p>
<p>哈希索引采用一定的哈希算法，把键值换成新的哈希值，检索时不需要类似B+树那样从根节点逐级查找，只需一次哈希算法即可立刻定位到相应的位置。</p>
<p>两者的区别：</p>
<p>哈希索引的优势：</p>
<p>（1）等值查询。哈希索引具有绝对优势（前提是：没有大量重复键值，如果大量重复键值时，哈希索引的效率很低，因为存在所谓的哈希碰撞问题。）</p>
<p>哈希索引不适用的场景：</p>
<p>（1）不支持范围查询</p>
<p>（2）不支持索引完成排序</p>
<p>（3）不支持联合索引的最左前缀匹配规则</p>
<p>MySQL中，只有HEAP/MEMORY引擎才显示支持哈希索引。而常用的InnoDB引擎中默认使用的是B+树索引，它会实时监控表上索引的使用情况，如果认为建立哈希索引可以提高查询效率，则自动在内存中的“自适应哈希索引缓冲区”建立哈希索引（在InnoDB中默认开启自适应哈希索引），通过观察搜索模式，MySQL会利用index key的前缀建立哈希索引，如果一个表几乎大部分都在缓冲池中，那么建立一个哈希索引能够加快等值查询。</p>
<h2 id="数据库发现某一个表查询很慢可能有哪些原因"><a href="#数据库发现某一个表查询很慢可能有哪些原因" class="headerlink" title="数据库发现某一个表查询很慢可能有哪些原因"></a>数据库发现某一个表查询很慢可能有哪些原因</h2><h3 id="一-设计或编码问题"><a href="#一-设计或编码问题" class="headerlink" title="一.设计或编码问题"></a>一.设计或编码问题</h3><ol>
<li>数据库表设计是否合理，是否正确添加索引</li>
<li>sql语句编写是否合理，查询的时候没有加索引</li>
<li>sql语句编写不规范导致索引失效，改用全表扫描</li>
<li>数据库表的数据是否太大？是否需要分库分表？</li>
<li>程序设计缺陷导致死锁</li>
</ol>
<p><strong>索引失效的几种常见原因：</strong></p>
<ul>
<li>1）查询条件中出现or，!=，或&lt;&gt;</li>
<li>2）复合索引未用左列字段（最左匹配原则）</li>
<li>3）模糊查询 like以%开头;</li>
<li>4）where的判断条件对字段进行了null值判断。因为索引无法存储null</li>
<li>5）where中索引列使用了函数</li>
<li>6）where中索引列有运算</li>
</ul>
<h3 id="二-机器资源问题"><a href="#二-机器资源问题" class="headerlink" title="二. 机器资源问题"></a>二. 机器资源问题</h3><ol>
<li>连接池资源不够用了，参数优化</li>
<li>数据库所在的硬件资源情况：当查询慢的时候，内存占了多少？mysql磁盘IO是不是被其它应用共享且占用高？cpu是不是有负载？<br> 1） 硬件资源本身不够&gt;加资源<br> 2）硬件资源因为和其它进程共享，导致资源不够，可以考虑做资源隔离<br> 3）硬件资源性能不足，比如磁盘可以考虑换成SSD</li>
<li>网络资源<br> 1）应用连接数据库的网络是不是抖动，延时较高</li>
</ol>
<h3 id="三-高并发量导致"><a href="#三-高并发量导致" class="headerlink" title="三. 高并发量导致"></a>三. 高并发量导致</h3><ol>
<li>如果数据量真的炒鸡大，分库分表已经不能满足查询了，考虑将热点数据在redis做缓存。应用架构调整，把缓存模块加进去。</li>
<li>如果已经加了缓存还是慢，会不会是缓存雪崩了？击穿了？缓存命中率低？</li>
<li>缓存任然不能满足查询要求，比如很多字段的查询，可以将查询字段放到ES等大数据组件中，先查ES，ES拿到数据主键id再到MySQL中查询用户请求突然增加，导致查询变慢上有系统出现bug，导致循环调用接口做查询，这个时候是不是考虑异常情况限流</li>
</ol>
<h2 id="10亿个url怎么查询某一个url是否在其中"><a href="#10亿个url怎么查询某一个url是否在其中" class="headerlink" title="10亿个url怎么查询某一个url是否在其中"></a>10亿个url怎么查询某一个url是否在其中</h2><h3 id="为什么不能用散列表"><a href="#为什么不能用散列表" class="headerlink" title="为什么不能用散列表"></a><strong>为什么不能用散列表</strong></h3><p>100 亿是一个很大的数量级，这里每条 url 平均 64 字节，全部存储的话需要 640G 的内存空间。又因为使用了散列表这种数据结构，而散列表是会出现散列冲突的。为了让散列表维持较小的装载因子，避免出现过多的散列冲突，需要使用链表法来处理，这里就要存储链表指针。因此最后的内存空间可能超过 1000G 了。</p>
<h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a><strong>布隆过滤器</strong></h3><p>布隆过滤器（英语：Bloom Filter）是 1970 年由 <strong>Burton Bloom</strong> 提出的。</p>
<p><strong>它实际上是一个很长的二进制矢量和一系列随机映射函数</strong>。</p>
<p>它<strong>可以用来判断一个元素是否在一个集合中</strong>。它的优势是只需要占用很小的内存空间以及有着高效的查询效率。</p>
<p>对于布隆过滤器而言，它的本质是一个<strong>位数组</strong>：位数组就是数组的每个元素都只占用 1 bit ，并且每个元素只能是 0 或者 1。</p>
<p>一开始，布隆过滤器的位数组所有位都初始化为 0。比如，数组长度为 m ，那么将长度为 m 个位数组的所有的位都初始化为 0。</p>
<table>
<thead>
<tr>
<th align="left">0</th>
<th align="left">0</th>
<th align="left">0</th>
<th align="left">0</th>
<th align="left">0</th>
<th align="left">0</th>
<th align="left">0</th>
<th align="left">0</th>
<th align="left">0</th>
<th align="left">0</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">。</td>
<td align="left">。</td>
<td align="left">。</td>
<td align="left">。</td>
<td align="left">。</td>
<td align="left">m-2</td>
<td align="left">m-1</td>
</tr>
</tbody></table>
<p>在数组中的每一位都是二进制位。</p>
<p>布隆过滤器除了一个位数组，还有 K 个哈希函数。当一个元素加入布隆过滤器中的时候，会进行如下操作：</p>
<p>•使用 K 个哈希函数对元素值进行 K 次计算，得到 K 个哈希值。•根据得到的哈希值，在位数组中把对应下标的值置为 1。</p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-2662963/s1o8cgc0y3.jpeg?imageView2/2/w/1620" alt="img"></p>
<p>举个例子，假设布隆过滤器有 3 个哈希函数：f1, f2, f3 和一个位数组 <code>arr</code>。现在要把 <code>2333</code> 插入布隆过滤器中：</p>
<p>•对值进行三次哈希计算，得到三个值 n1, n2, n3。•把位数组中三个元素 arr[n1], arr[n2], arr[3] 都置为 1。</p>
<p>当要判断一个值是否在布隆过滤器中，对元素进行三次哈希计算，得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</p>
<h2 id="Python了解哪些底层原理"><a href="#Python了解哪些底层原理" class="headerlink" title="Python了解哪些底层原理"></a>Python了解哪些底层原理</h2><ul>
<li>内存管理</li>
<li>多线程</li>
</ul>
<h2 id="如果进程内存使用过高"><a href="#如果进程内存使用过高" class="headerlink" title="如果进程内存使用过高"></a>如果进程内存使用过高</h2><p>可能有几个G，在Python该如何查找具体是哪一个对象占用比较高（不会，就硬瞎说），通过哪个模块可以找到这些信息</p>
<ul>
<li><p>sys getsizeof</p>
</li>
<li><p>import psutil </p>
</li>
<li><p>df.memory_usage()显示</p>
</li>
</ul>
<h2 id="用-new-这种魔法函数实现单例，写伪代码"><a href="#用-new-这种魔法函数实现单例，写伪代码" class="headerlink" title="用__new__()这种魔法函数实现单例，写伪代码"></a>用__new__()这种魔法函数实现单例，写伪代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age</span>):</span></span><br><span class="line">    self.name = name</span><br><span class="line">    self.age = age</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(cls, <span class="string">&#x27;instance&#x27;</span>):</span><br><span class="line">      cls.instance = <span class="built_in">super</span>().__new__(cls)</span><br><span class="line">    <span class="keyword">return</span> cls.instance</span><br><span class="line"> </span><br><span class="line">a = Person(<span class="string">&#x27;p1&#x27;</span>,<span class="number">21</span></span><br><span class="line">b = Person(<span class="string">&#x27;p2&#x27;</span>,<span class="number">22</span></span><br><span class="line">print(a == b, a.name == b.name)</span><br></pre></td></tr></table></figure>



<h2 id="场景题：设计服务器，服务器只开了一个端口，但要在一分钟内处理上万的请求，用Python该处理这种上万级的请求"><a href="#场景题：设计服务器，服务器只开了一个端口，但要在一分钟内处理上万的请求，用Python该处理这种上万级的请求" class="headerlink" title="场景题：设计服务器，服务器只开了一个端口，但要在一分钟内处理上万的请求，用Python该处理这种上万级的请求"></a>场景题：设计服务器，服务器只开了一个端口，但要在一分钟内处理上万的请求，用Python该处理这种上万级的请求</h2><ul>
<li><p>多核</p>
</li>
<li><p>对于计算密集型工作，可以利用 PyPy 的即时编译</p>
</li>
<li><p>新的微服务框架japronto 全新微服务框架，异步</p>
</li>
</ul>
<h2 id="请求的响应速度过慢"><a href="#请求的响应速度过慢" class="headerlink" title="请求的响应速度过慢"></a>请求的响应速度过慢</h2><p>如何分析排除出具体原因（面试官提示说服务端的问题）</p>
<ul>
<li><p>服务端：</p>
</li>
<li><p>可能的原因一：服务器出口带宽不够用。这是一个很常见的瓶颈。一方面，可能是本身购买的服务器出口带宽就很小（企业购买带宽相当昂贵），一旦用户访问量上来了，并发量大了，自然均分给用户的出口带宽就更小了，所以某些用户的访问速度就会下降了很多。另一个，就是跨运营商网络导致带宽缩减，例如很多公司的网站（服务器）是放在电信的网络上的，而如果用户这边对接的是长城或者说联通的宽带，运营商之间网络传输在对接时是会有限制的，这就可能导致带宽的缩减。</p>
<p>  （2）可能原因二：服务器负载过大忙不过来，比如说CPU和内存消耗完了，这个容易理解，不展开。</p>
<p>  （3）可能原因三：网站的开发代码没写好，例如mysql语句没有进行优化，导致数据库的读写相当耗费时间。</p>
<p>  （4）可能原因四：数据库的瓶颈，也是很常见的一个瓶颈，这点跟上面第三个原因可以一起来说。当我们的数据库变得愈发庞大，比如好多G好多T这么大，那对于数据库的读写就会变得相当缓慢了，索引优化固然能提升一些效率，但数据库已经如此庞大的话，如果每次查询都对这么大的数据库进行全局查询，自然会很慢。这个学过数据库的话也是挺容易理解的。</p>
</li>
</ul>
<h2 id="如何分析数据库慢查询"><a href="#如何分析数据库慢查询" class="headerlink" title="如何分析数据库慢查询"></a>如何分析数据库慢查询</h2><p>explan提示的字段有哪些，全表扫描的话会type字段会显示什么</p>
<h2 id="程序里的每一个进程最多可以申请多少的空间"><a href="#程序里的每一个进程最多可以申请多少的空间" class="headerlink" title="程序里的每一个进程最多可以申请多少的空间"></a>程序里的每一个进程最多可以申请多少的空间</h2><p>2 ^ 64 减去系统占用</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvzhmqgas4j30kq08r74r.jpg" alt="img"></p>
<h2 id="多线程过多协程，如果卡死，想要定位出错的点，怎样判断整个进程的状况"><a href="#多线程过多协程，如果卡死，想要定位出错的点，怎样判断整个进程的状况" class="headerlink" title="多线程过多协程，如果卡死，想要定位出错的点，怎样判断整个进程的状况"></a>多线程过多协程，如果卡死，想要定位出错的点，怎样判断整个进程的状况</h2><h2 id="namespace和entrypoint"><a href="#namespace和entrypoint" class="headerlink" title="namespace和entrypoint"></a>namespace和entrypoint</h2><h2 id="slots-（）是用来定义什么的"><a href="#slots-（）是用来定义什么的" class="headerlink" title="__slots__（）是用来定义什么的"></a>__slots__（）是用来定义什么的</h2><h2 id="Python协程原理"><a href="#Python协程原理" class="headerlink" title="Python协程原理"></a>Python协程原理</h2><h2 id="Django框架设计思维，设计机制"><a href="#Django框架设计思维，设计机制" class="headerlink" title="Django框架设计思维，设计机制"></a>Django框架设计思维，设计机制</h2><h2 id="Mysql中B树和B-树的使用场景和区别"><a href="#Mysql中B树和B-树的使用场景和区别" class="headerlink" title="Mysql中B树和B+树的使用场景和区别"></a>Mysql中B树和B+树的使用场景和区别</h2><h2 id="定义一张表，这张表最多可以存多少条数据，这是由什么决定的"><a href="#定义一张表，这张表最多可以存多少条数据，这是由什么决定的" class="headerlink" title="定义一张表，这张表最多可以存多少条数据，这是由什么决定的"></a>定义一张表，这张表最多可以存多少条数据，这是由什么决定的</h2><h2 id="项目中如何保证数据库高可用，是否用到了主从机制"><a href="#项目中如何保证数据库高可用，是否用到了主从机制" class="headerlink" title="项目中如何保证数据库高可用，是否用到了主从机制"></a><a href="">项目</a>中如何保证数据库高可用，是否用到了主从机制</h2><h2 id="介绍项目，用户量增加后，系统原型可以从哪些地方进行改进，有参考业界其他类似需求的常见做法吗（无），项目中得到的最大收获"><a href="#介绍项目，用户量增加后，系统原型可以从哪些地方进行改进，有参考业界其他类似需求的常见做法吗（无），项目中得到的最大收获" class="headerlink" title="介绍项目，用户量增加后，系统原型可以从哪些地方进行改进，有参考业界其他类似需求的常见做法吗（无），项目中得到的最大收获"></a>介绍<a href="">项目</a>，用户量增加后，系统原型可以从哪些地方进行改进，有参考业界其他类似需求的常见做法吗（无），<a href="">项目</a>中得到的最大收获</h2><h2 id="装饰器，多个装饰器顺序问题"><a href="#装饰器，多个装饰器顺序问题" class="headerlink" title="装饰器，多个装饰器顺序问题"></a>装饰器，多个装饰器顺序问题</h2><h2 id="元类"><a href="#元类" class="headerlink" title="元类"></a>元类</h2><h2 id="类方法和普通方法和实例方法，平时怎么用的"><a href="#类方法和普通方法和实例方法，平时怎么用的" class="headerlink" title="类方法和普通方法和实例方法，平时怎么用的"></a>类方法和普通方法和实例方法，平时怎么用的</h2><p>实例方法：可以获取类属性、构造函数定义的变量，属于 method 类型。只能通过实例化调用。</p>
<p>静态方法：不能获取类属性、构造函数定义的变量，属于 function 类型。两种调用方式：类.方法名 ，实例化调用。</p>
<p>类方法 ：可以获取类属性，不能获取构造函数定义的变量，属于 method 类型。两种调用方式：类.方法名 ，实例化调用。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h2 id="队列和元组区别"><a href="#队列和元组区别" class="headerlink" title="队列和元组区别"></a>队列和元组区别</h2><p>队列 == list</p>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><h2 id="is和-区别"><a href="#is和-区别" class="headerlink" title="is和==区别"></a>is和==区别</h2><p>is比较的是id是不是一样，==比较的是值是不是一样。</p>
<p>Python中，万物皆对象！万物皆对象！万物皆对象！(很重要，重复3遍)</p>
<p>每个对象包含3个属性，id，type，value</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">b = a</span><br><span class="line">c = <span class="number">1</span></span><br><span class="line">d = <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">id</span>(a)   <span class="comment"># 35556792L</span></span><br><span class="line"><span class="built_in">id</span>(b)   <span class="comment"># 35556792L</span></span><br><span class="line"><span class="built_in">id</span>(c)   <span class="comment"># 35556792L</span></span><br><span class="line"><span class="built_in">id</span>(d)   <span class="comment"># 21253459L</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断a is b的时候，实际上比较的是id(a)==id(b)。结果为True</span></span><br><span class="line"><span class="comment"># a==b时候，实际上比较的是id(a)这个地址指向的值是不是和id(b)这个地址指向值一样</span></span><br></pre></td></tr></table></figure>

<h2 id="io的多路复用"><a href="#io的多路复用" class="headerlink" title="io的多路复用"></a>io的多路复用</h2><ul>
<li>IO 多路复用是一种同步IO模型，实现一个线程可以监视多个文件句柄；</li>
<li>一旦某个文件句柄就绪，就能够通知应用程序进行相应的读写操作；</li>
<li>没有文件句柄就绪就会阻塞应用程序，交出CPU。</li>
</ul>
<h2 id="进程通信方式"><a href="#进程通信方式" class="headerlink" title="进程通信方式"></a>进程通信方式</h2><ul>
<li><p>管道 grep</p>
</li>
<li><p>消息队列</p>
</li>
<li><p>共享内存：系统加载一个进程的时候，分配给进程的内存并不是实际物理内存，而是虚拟内存空间。那么我们可以让两个进程各自拿出一块虚拟地址空间来，然后映射到相同的物理内存中，这样，两个进程虽然有着独立的虚拟内存空间，但有一部分却是映射到相同的物理内存，这就完成了内存共享机制了。</p>
</li>
</ul>
<h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvzhy87hfoj30k008ygm3.jpg" alt="img"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvzhyk2tdlj30k009vjrx.jpg" alt="img"></p>
<h2 id="数组和链表的区别"><a href="#数组和链表的区别" class="headerlink" title="数组和链表的区别"></a>数组和<a href="">链表</a>的区别</h2><p>两种数据结构都属于线性表，数组占用的是一块连续的内存区，而链表在内存中，是分散的，因为是分散的（指针）</p>
<p><strong>数组和链表时间复杂度分别是O(1)与O(n)，方式一种是“随机访问”，一种是“顺序访问”。</strong></p>
<p>数组：使用下标访问‘</p>
<p>链表：使用指针顺序查找（单向链表）</p>
<h2 id="排序算法了解那些？时间复杂度？"><a href="#排序算法了解那些？时间复杂度？" class="headerlink" title="排序算法了解那些？时间复杂度？"></a><a href="">排序</a><a href="">算法</a>了解那些？时间复杂度？</h2><h2 id="口排一下快速排序吧"><a href="#口排一下快速排序吧" class="headerlink" title="口排一下快速排序吧"></a>口排一下快速<a href="">排序</a>吧</h2><h2 id="孤儿进程，僵尸进程，能否用kill杀掉僵尸进程，怎么查看僵尸进程"><a href="#孤儿进程，僵尸进程，能否用kill杀掉僵尸进程，怎么查看僵尸进程" class="headerlink" title="孤儿进程，僵尸进程，能否用kill杀掉僵尸进程，怎么查看僵尸进程"></a>孤儿进程，僵尸进程，能否用kill杀掉僵尸进程，怎么查看僵尸进程</h2><ul>
<li><code>ps -ef | grep defunct</code></li>
<li><code>top</code></li>
</ul>
<p>Tasks: 95 total, 1 running, 94 sleeping, 0 stopped, <strong>0 zombie</strong></p>
<h3 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h3><ul>
<li><p>一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。</p>
</li>
<li><p>孤儿进程将被 <code>init 进程（进程号为 1）</code>所收养，并由 <code>init 进程</code>对它们完成状态收集工作。</p>
</li>
<li><p>由于孤儿进程会被<code> init 进程</code>收养，所以孤儿进程不会对系统造成危害。</p>
</li>
</ul>
<h3 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h3><ul>
<li><p>一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过 <code>wait()</code> 或 <code>waitpid()</code> 获取了子进程信息后才会释放。如果子进程退出，而父进程并没有调用 <code>wait()</code> 或 <code>waitpid()</code>，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵尸进程。</p>
</li>
<li><p>僵尸进程通过 ps 命令显示出来的状态为 Z（zombie）。</p>
</li>
<li><p>系统所能使用的进程号是有限的，如果产生大量僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。</p>
</li>
<li><p>要消灭系统中大量的僵尸进程，只需要将其父进程杀死，此时僵尸进程就会变成孤儿进程，从而被 init 进程所收养，这样 init 进程就会释放所有的僵尸进程所占有的资源，从而结束僵尸进程。</p>
</li>
</ul>
<h2 id="top命令"><a href="#top命令" class="headerlink" title="top命令"></a>top命令</h2><h2 id="netstat命令"><a href="#netstat命令" class="headerlink" title="netstat命令"></a>netstat命令</h2><h2 id="事务ACID"><a href="#事务ACID" class="headerlink" title="事务ACID"></a>事务ACID</h2><h2 id="开发过程中多进程共享文件的问题-加锁-，加什么锁"><a href="#开发过程中多进程共享文件的问题-加锁-，加什么锁" class="headerlink" title="开发过程中多进程共享文件的问题(加锁)，加什么锁"></a>开发过程中多进程共享文件的问题(加锁)，加什么锁</h2><p> flock 文件锁</p>
<h2 id="深信服这在防护墙那有黑名单，如何快速匹配一个（hash表）如果数量很大呢（分治，在hash）"><a href="#深信服这在防护墙那有黑名单，如何快速匹配一个（hash表）如果数量很大呢（分治，在hash）" class="headerlink" title="深信服这在防护墙那有黑名单，如何快速匹配一个（hash表）如果数量很大呢（分治，在hash）"></a><a href="">深信服</a>这在防护墙那有黑名单，如何快速匹配一个（hash表）如果数量很大呢（分治，在hash）</h2><p>海量日志，文件太大，IP地址最多有2^32=4G，无法装入内存，，将这个大文件（hash映射：可以取模00）分成多个小文件（如1000）。</p>
<p>对每个小文件进行hash统计，hash_map(ip,value),得到每个文件出现频率最多的ip</p>
<p>将这些频率最高的ip进行统计，然后排序得出最大值，这里可以采用堆/快速/归并，但只取一个最大值的话可以采用堆排序。</p>
<h2 id="多线程进程协程"><a href="#多线程进程协程" class="headerlink" title="多线程进程协程"></a>多线程进程协程</h2><h2 id="静态实例类方法"><a href="#静态实例类方法" class="headerlink" title="静态实例类方法"></a>静态实例类方法</h2><h2 id="生成器迭代器"><a href="#生成器迭代器" class="headerlink" title="生成器迭代器"></a>生成器迭代器</h2><h2 id="垃圾回收-1"><a href="#垃圾回收-1" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><h2 id="列表元组"><a href="#列表元组" class="headerlink" title="列表元组"></a>列表元组</h2><h2 id="python的数据结构有哪些"><a href="#python的数据结构有哪些" class="headerlink" title="python的数据结构有哪些"></a>python的数据结构有哪些</h2><h2 id="python切片"><a href="#python切片" class="headerlink" title="python切片"></a>python切片</h2><h2 id="元组和列表的异同"><a href="#元组和列表的异同" class="headerlink" title="元组和列表的异同"></a>元组和列表的异同</h2><h2 id="手撕快排，并解释"><a href="#手撕快排，并解释" class="headerlink" title="手撕快排，并解释"></a>手撕快排，并解释</h2><h2 id="python的内存管理机制"><a href="#python的内存管理机制" class="headerlink" title="python的内存管理机制"></a>python的内存管理机制</h2><h2 id="发生内存泄漏如何排查"><a href="#发生内存泄漏如何排查" class="headerlink" title="发生内存泄漏如何排查"></a>发生内存泄漏如何排查</h2><h2 id="简述进程，线程，和协程"><a href="#简述进程，线程，和协程" class="headerlink" title="简述进程，线程，和协程"></a>简述进程，线程，和协程</h2><h2 id="Python垃圾回收机制，内存机制？"><a href="#Python垃圾回收机制，内存机制？" class="headerlink" title="Python垃圾回收机制，内存机制？"></a>Python垃圾回收机制，内存机制？</h2><h2 id="Mysql语句如何优化？B树和B＋树区别"><a href="#Mysql语句如何优化？B树和B＋树区别" class="headerlink" title="Mysql语句如何优化？B树和B＋树区别"></a>Mysql语句如何优化？B树和B＋树区别</h2><h2 id="new-和-init-的区别？"><a href="#new-和-init-的区别？" class="headerlink" title="__new__和__init__的区别？"></a>__new__和__init__的区别？</h2><p>作者：初识CV<br>链接：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/356064986">https://zhuanlan.zhihu.com/p/356064986</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h2 id="1-new-函数"><a href="#1-new-函数" class="headerlink" title="1. __ new__函数"></a>1. __ new__函数</h2><p><strong>new</strong>() 是一种负责创建类实例的静态方法，它无需使用 staticmethod 装饰器修饰，且该方法会优先 <strong>init</strong>() 初始化方法被调用。</p>
<p>一般情况下，覆写 <strong>new</strong>() 的实现将会使用合适的参数调用其超类的 super().<strong>new</strong>()，并在返回之前修改实例。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class demoClass:</span><br><span class="line">    instances_created &#x3D; 0</span><br><span class="line">    def __new__(cls,*args,**kwargs):</span><br><span class="line">        print(&quot;__new__():&quot;,cls,args,kwargs)</span><br><span class="line">        instance &#x3D; super().__new__(cls)</span><br><span class="line">        instance.number &#x3D; cls.instances_created</span><br><span class="line">        cls.instances_created +&#x3D; 1</span><br><span class="line">        return instance</span><br><span class="line">    def __init__(self,attribute):</span><br><span class="line">        print(&quot;__init__():&quot;,self,attribute)</span><br><span class="line">        self.attribute &#x3D; attribute</span><br><span class="line">test1 &#x3D; demoClass(&quot;abc&quot;)</span><br><span class="line">test2 &#x3D; demoClass(&quot;xyz&quot;)</span><br><span class="line">print(test1.number,test1.instances_created)</span><br><span class="line">print(test2.number,test2.instances_created)</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__new__(): &lt;class &#39;__main__.demoClass&#39;&gt; (&#39;abc&#39;,) &#123;&#125;</span><br><span class="line">__init__(): &lt;__main__.demoClass object at 0x0000025650FACF28&gt; abc</span><br><span class="line">__new__(): &lt;class &#39;__main__.demoClass&#39;&gt; (&#39;xyz&#39;,) &#123;&#125;</span><br><span class="line">__init__(): &lt;__main__.demoClass object at 0x000002565FFC4CF8&gt; xyz</span><br><span class="line">0 2</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure>

<p><strong>new</strong>() 通常会返回该类的一个实例，但有时也可能会返回其他类的实例，如果发生了这种情况，则会跳过对 <strong>init</strong>() 方法的调用。而在某些情况下（比如需要修改不可变类实例（Python 的某些内置类型）的创建行为），利用这一点会事半功倍。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class nonZero(int):</span><br><span class="line">    def __new__(cls,value):</span><br><span class="line">        return super().__new__(cls,value) if value !&#x3D; 0 else None</span><br><span class="line">    def __init__(self,skipped_value):</span><br><span class="line">        #此例中会跳过此方法</span><br><span class="line">        print(&quot;__init__()&quot;)</span><br><span class="line">        super().__init__()</span><br><span class="line">print(type(nonZero(-12)))</span><br><span class="line">print(type(nonZero(0)))</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__init__()</span><br><span class="line">&lt;class &#39;__main__.nonZero&#39;&gt;</span><br><span class="line">&lt;class &#39;NoneType&#39;&gt;</span><br></pre></td></tr></table></figure>

<p>那么，什么情况下使用 <strong>new</strong>() 呢？答案很简单，在 <strong>init</strong>() 不够用的时候。</p>
<p>例如，前面例子中对 Python 不可变的内置类型（如 int、str、float 等）进行了子类化，这是因为一旦创建了这样不可变的对象实例，就无法在 <strong>init</strong>() 方法中对其进行修改。</p>
<p>有些读者可能会认为，<strong>new</strong>() 对执行重要的对象初始化很有用，如果用户忘记使用 super()，可能会漏掉这一初始化。虽然这听上去很合理，但有一个主要的缺点，即如果使用这样的方法，那么即便初始化过程已经是预期的行为，程序员明确跳过初始化步骤也会变得更加困难。不仅如此，它还破坏了“<strong>init</strong>() 中执行所有初始化工作”的潜规则。</p>
<p>注意，由于 <strong>new</strong>() 不限于返回同一个类的实例，所以很容易被滥用，不负责任地使用这种方法可能会对代码有害，所以要谨慎使用。一般来说，对于特定问题，最好搜索其他可用的解决方案，最好不要影响对象的创建过程，使其违背程序员的预期。比如说，前面提到的覆写不可变类型初始化的例子，完全可以用工厂方法（一种设计模式）来替代。</p>
<h2 id="2-init"><a href="#2-init" class="headerlink" title="2. __ init__()"></a>2. __ init__()</h2><p><strong>所有类的超类object</strong>，有一个默认包含pass的__ init __()实现，这个函数会在对象初始化的时候调用，我们可以选择实现，也可以选择不实现，一般建议是实现的，不实现对象属性就不会被初始化。</p>
<p>**<strong>init</strong>() 方法可以包含多个参数，但必须包含一个名为 self 的参数，且必须作为第一个参数。**也就是说，类的构造方法最少也要有一个 self 参数，仅包含 self 参数的 <strong>init</strong>() 构造方法，又称为类的默认构造方法。例如，仍以 TheFirstDemo 类为例，添加构造方法的代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class TheFirstDemo:</span><br><span class="line">        &#39;&#39;&#39;这是一个学习Python定义的第一个类&#39;&#39;&#39;</span><br><span class="line"></span><br><span class="line">        # 构造方法</span><br><span class="line">        def __init__(self):</span><br><span class="line">                print(&quot;调用构造方法&quot;)</span><br><span class="line"></span><br><span class="line">        # 下面定义了一个类属性</span><br><span class="line">        add &#x3D; &#39;http:&#x2F;&#x2F;c.biancheng.net&#39;</span><br><span class="line"></span><br><span class="line">        # 下面定义了一个say方法</span><br><span class="line">        def say(self, content):</span><br><span class="line">                print(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">        result &#x3D; TheFirstDemo()</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">调用构造方法</span><br></pre></td></tr></table></figure>

<p>在创建 result  这个对象时，隐式调用了我们手动创建的 <strong>init</strong>() 构造方法。</p>
<p>不仅如此，在 <strong>init</strong>() 构造方法中，除了 self 参数外，还可以自定义一些参数，参数之间使用逗号“,”进行分割。例如，下面的代码在创建 <strong>init</strong>() 方法时，额外指定了 2 个参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class CLanguage:</span><br><span class="line">    &#39;&#39;&#39;这是一个学习Python定义的一个类&#39;&#39;&#39;</span><br><span class="line">    def __init__(self,name,add):</span><br><span class="line">        print(name,&quot;的网址为:&quot;,add)</span><br><span class="line"></span><br><span class="line">#创建 add 对象，并传递参数给构造函数</span><br><span class="line">add &#x3D; CLanguage(&quot;C语言中文网&quot;,&quot;http:&#x2F;&#x2F;c.biancheng.net&quot;)</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C语言中文网 的网址为: http:&#x2F;&#x2F;c.biancheng.net</span><br></pre></td></tr></table></figure>

<p>可以看到，虽然构造方法中有 self、name、add 3 个参数，但实际需要传参的仅有 name 和 add，也就是说，self 不需要手动传递参数。</p>
<h2 id="出现bug怎么去找到原因？"><a href="#出现bug怎么去找到原因？" class="headerlink" title="出现bug怎么去找到原因？"></a>出现bug怎么去找到原因？</h2><h2 id="过河问题，ABCD四个人，单独过河分别需要1，2，5，10，最多两个人同时过，并且只有一个手电筒，每次都需要电筒，两人过河按慢的时间算，问最少几分钟？（17分钟）如果有n个人过河，每个人过河的时间不定，怎么用算法实现"><a href="#过河问题，ABCD四个人，单独过河分别需要1，2，5，10，最多两个人同时过，并且只有一个手电筒，每次都需要电筒，两人过河按慢的时间算，问最少几分钟？（17分钟）如果有n个人过河，每个人过河的时间不定，怎么用算法实现" class="headerlink" title="过河问题，ABCD四个人，单独过河分别需要1，2，5，10，最多两个人同时过，并且只有一个手电筒，每次都需要电筒，两人过河按慢的时间算，问最少几分钟？（17分钟）如果有n个人过河，每个人过河的时间不定，怎么用算法实现"></a>过河问题，ABCD四个人，单独过河分别需要1，2，5，10，最多两个人同时过，并且只有一个手电筒，每次都需要电筒，两人过河按慢的时间算，问最少几分钟？（17分钟）如果有n个人过河，每个人过河的时间不定，怎么用<a href="">算法</a>实现</h2><h2 id="从一亿个ip找出指定的IP。"><a href="#从一亿个ip找出指定的IP。" class="headerlink" title="从一亿个ip找出指定的IP。"></a>从一亿个ip找出指定的IP。</h2><h2 id="列表和元组，字典的底层实现"><a href="#列表和元组，字典的底层实现" class="headerlink" title="列表和元组，字典的底层实现"></a>列表和元组，字典的底层实现</h2><p>数组 哈希表</p>
<h2 id="说了解web常见的漏洞原理、利用方式）"><a href="#说了解web常见的漏洞原理、利用方式）" class="headerlink" title="说了解web常见的漏洞原理、利用方式）"></a>说了解web常见的漏洞原理、利用方式）</h2><h2 id="说说SMB协议（不是很了解）"><a href="#说说SMB协议（不是很了解）" class="headerlink" title="说说SMB协议（不是很了解）"></a>说说SMB协议（不是很了解）</h2><h2 id="详细介绍了自己的一个项目（协议相关）"><a href="#详细介绍了自己的一个项目（协议相关）" class="headerlink" title="详细介绍了自己的一个项目（协议相关）"></a>详细介绍了自己的一个<a target="_blank" rel="noopener" href="https://www.nowcoder.com/jump/super-jump/word?word=%E9%A1%B9%E7%9B%AE">项目</a>（协议相关）</h2><h2 id="协议常见的攻击"><a href="#协议常见的攻击" class="headerlink" title="协议常见的攻击"></a>协议常见的攻击</h2><p>（中间人、重放 的原理、防御）</p>
<p>一般的TCP网络攻击</p>
<p>SYN Flood  - 可能是最古老的，但用作大多数攻击向量。攻击者正在向服务器发送大量SYN数据包。 IP不必是真实的，因为攻击不需要调查返回流量。通常这是一个无效的IP。这使得难以理解攻击者的来源并允许攻击者保持匿名。 SYN攻击技术多年来不断发展。</p>
<p>SYN攻击背后的主要思想是发送大量SYN数据包以消耗TCP \ IP堆栈上分配的内存。多年来，SYN攻击变得更加复杂。最新的变种是Tsunami SYN Flood Attack。这会使用TCP SYN位的<a target="_blank" rel="noopener" href="https://cloud.tencent.com/solution/bigdata?from=10680">大数据</a>包使Internet管道饱和，从而导致TCP \ IP堆栈的并行损坏。</p>
<p>除了SYN泛洪之外，TCP网络攻击还会针对各种攻击使用所有其他TCP，ACK泛洪，RST洪水，推送洪水，FIN洪水及其组合。只要存在腐败可能，攻击者就会尽一切努力。</p>
<p>HTTP L7攻击非常普遍。 HTTP L7攻击与上述网络攻击之间的主要区别在于HTTP事务需要有效的IP。 TCP握手不能IP欺骗HTTP请求，因为IP需要接收数据包并进行响应。如果没有IP，则无法建立连接。对于想要使用HTTP攻击的攻击者来说，这种差异非常困难。然而，在今天的世界中，对于最近的IoT僵尸网络攻击目标来说，拥有多个真实IP地址并不是一项不可能完成的任务。当从真实IP地址建立连接时，存在一些攻击选项。</p>
<p>垃圾洪水 - 最简单的攻击方式是打开与HTTP端口（通常是端口80或443）的连接并发送垃圾二进制数据。这种类型的攻击通常会忽略缓解，因为服务器和保护它的安全设备需要“有效”的HTTP流量。通常，此攻击的目的是将缓存设备中的Web服务器的内部缓冲区和队列置于它们之前。攻击方法很简单，但这种攻击可以用来使互联网管道饱和。</p>
<p>GET Flood  -  HTTP协议最常见的用途是GET请求。使用GET请求方法，例如GET泛洪，但数量很大。攻击者试图停止向服务器提供合法的GET请求。通常，此攻击根据HTTP协议标准使用RFC fcompliancy检查来防止减少。</p>
<p>其他HTTP方法 - 除了通常的GET方法之外，HTTP协议还允许其他方法，例如HEAD和POST。使用这些方法的攻击通常与GET泛洪一起使用，以试图攻击服务器代码的异常区域。通常，POST请求比GET请求大，因此大型POST请求更有可能通过缓解器来了解服务器，保护服务器比大型GET请求更可疑。这会增加服务器上的内存消耗和拒绝服务。</p>
<p>XSS攻击：跨站脚本攻击(Cross-Site Scripting)，为了不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS。XSS是一种常见的web安全漏洞，它允许攻击者将恶意代码植入到提供给其它用户使用的页面中。不同于大多数攻击(一般只涉及攻击者和受害者)，XSS涉及到三方，即攻击者、客户端与Web应用。XSS的攻击目标是为了盗取存储在客户端的cookie或者其他网站用于识别客户端身份的敏感信息。一旦获取到合法用户的信息后，攻击者甚至可以假冒合法用户与网站进行交互。</p>
<h2 id="什么是SQL注入"><a href="#什么是SQL注入" class="headerlink" title="什么是SQL注入"></a>什么是SQL注入</h2><p>攻击者成功的向服务器提交恶意的SQL查询代码，程序在接收后错误的将攻击者的输入作为查询语句的一部分执行，导致原始的查询逻辑被改变，额外的执行了攻击者精心构造的恶意代码。</p>
<p>举例：<code>&#39; OR &#39;1&#39;=&#39;1</code></p>
<p>这是最常见的 SQL注入攻击，当我们输如用户名 admin ，然后密码输如<code>&#39; OR &#39;1&#39;=1=&#39;1</code>的时候，我们在查询用户名和密码是否正确的时候，本来要执行的是<code>SELECT * FROM user WHERE username=&#39;&#39; and password=&#39;&#39;</code>,经过参数拼接后，会执行 SQL语句 <code>SELECT * FROM user WHERE username=&#39;&#39; and password=&#39;&#39; OR &#39;1&#39;=&#39;1&#39;</code>，这个时候1=1是成立，自然就跳过验证了。</p>
<p>CSRF（Cross-site request forgery），中文名称：跨站请求伪造，也被称为：one click attack/session riding，缩写为：CSRF/XSRF。</p>
<p>你这可以这么理解CSRF攻击：攻击者盗用了你的身份，以你的名义发送恶意请求。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账……造成的问题包括：个人隐私泄露以及财产安全。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvznzgedadj30t80ghn1s.jpg" alt="img"></p>
<h2 id="b树、b-树、红黑树"><a href="#b树、b-树、红黑树" class="headerlink" title="b树、b+树、红黑树"></a><strong>b树、b+树、红黑树</strong></h2><h2 id="快排和冒泡的比较（口述分别怎么实现的）"><a href="#快排和冒泡的比较（口述分别怎么实现的）" class="headerlink" title="快排和冒泡的比较（口述分别怎么实现的）"></a>快排和冒泡的比较（口述分别怎么实现的）</h2><h2 id="Try-except-else-finally中的问题，try中使用return了还会不会执行else-finally"><a href="#Try-except-else-finally中的问题，try中使用return了还会不会执行else-finally" class="headerlink" title="Try except else finally中的问题，try中使用return了还会不会执行else  finally"></a>Try except else finally中的问题，try中使用return了还会不会执行else  finally</h2><p>以运行结果为准，说明无论try里执行什么，<strong>即使是return，也会调用finally的</strong>。</p>
<p><strong>如果try中没有异常</strong>，那么except部分将跳过，<strong>执行else中的语句</strong>。（前提是try里没有返回值）</p>
<p>finally是无论是否有异常，最后都要做的一些事情。”（无论try里是否有返回值）</p>
<p>这里补充一句，在<strong>含有return的情况下，并不会阻碍finally的执行</strong>。（但是会阻碍else）</p>
<h2 id="python内存管理"><a href="#python内存管理" class="headerlink" title="python内存管理"></a>python内存管理</h2><p>（详细介绍了GC三种方式以及底层实现，和内存池相关）</p>
<h2 id="装饰器有用过么？（staticmethod和自己写的时间戳装饰器）"><a href="#装饰器有用过么？（staticmethod和自己写的时间戳装饰器）" class="headerlink" title="装饰器有用过么？（staticmethod和自己写的时间戳装饰器）"></a>装饰器有用过么？（staticmethod和自己写的时间戳装饰器）</h2><h2 id="进一步：-staticmethod讲一下？和其他类成员函数的区别？"><a href="#进一步：-staticmethod讲一下？和其他类成员函数的区别？" class="headerlink" title="进一步： staticmethod讲一下？和其他类成员函数的区别？"></a>进一步： staticmethod讲一下？和其他类成员函数的区别？</h2><h2 id="用过什么库？各自用来干什么？（答：numpy，os，sys，re，collections）"><a href="#用过什么库？各自用来干什么？（答：numpy，os，sys，re，collections）" class="headerlink" title="用过什么库？各自用来干什么？（答：numpy，os，sys，re，collections）"></a>用过什么库？各自用来干什么？（答：numpy，os，sys，re，collections）</h2><h2 id="re用过？讲讲用过哪些正则？（re-search-amp-re-match）"><a href="#re用过？讲讲用过哪些正则？（re-search-amp-re-match）" class="headerlink" title="re用过？讲讲用过哪些正则？（re.search &amp; re.match）"></a>re用过？讲讲用过哪些正则？（re.search &amp; re.match）</h2><h2 id="上面两者的区别？"><a href="#上面两者的区别？" class="headerlink" title="上面两者的区别？"></a>上面两者的区别？</h2><h2 id="深浅拷贝？详细说一下？"><a href="#深浅拷贝？详细说一下？" class="headerlink" title="深浅拷贝？详细说一下？"></a>深浅拷贝？详细说一下？</h2><h2 id="set了解么？和list的区别？底层如何实现的？（哈希map）"><a href="#set了解么？和list的区别？底层如何实现的？（哈希map）" class="headerlink" title="set了解么？和list的区别？底层如何实现的？（哈希map）"></a>set了解么？和list的区别？底层如何实现的？（哈希map）</h2><p>哈希映射</p>
<h2 id="类的继承了解么？项目里面有没有涉及到？"><a href="#类的继承了解么？项目里面有没有涉及到？" class="headerlink" title="类的继承了解么？项目里面有没有涉及到？"></a>类的继承了解么？<a href="">项目</a>里面有没有涉及到？</h2><p>Python中类的继承也就是一个类继承另一个类的话，便可以拥有所继承类的所有属性和方法，此时使用起来不仅方便且节省代码量。</p>
<p> <strong>Python单继承</strong></p>
<h2 id="TCP和UDP这个知道的吧？"><a href="#TCP和UDP这个知道的吧？" class="headerlink" title="TCP和UDP这个知道的吧？"></a>TCP和UDP这个知道的吧？</h2><p>（答：老熟人了）那好我问你个不常见的吧（我：危）， ARP协议了解嘛，具体的运作方式？（刚好面<a href="">华为</a>的时候看过，甚至答了RARP）</p>
<h2 id="第二次向同一个主机发送数据的时候还需要用ARP吗？（不用，有缓存）"><a href="#第二次向同一个主机发送数据的时候还需要用ARP吗？（不用，有缓存）" class="headerlink" title="第二次向同一个主机发送数据的时候还需要用ARP吗？（不用，有缓存）"></a>第二次向同一个主机发送数据的时候还需要用ARP吗？（不用，有缓存）</h2><h2 id="线程进程了解嘛？进程的调度？通讯方式？（经典八股文）项目里面有实现这些通讯方式嘛？（？？？）"><a href="#线程进程了解嘛？进程的调度？通讯方式？（经典八股文）项目里面有实现这些通讯方式嘛？（？？？）" class="headerlink" title="线程进程了解嘛？进程的调度？通讯方式？（经典八股文）项目里面有实现这些通讯方式嘛？（？？？）"></a>线程进程了解嘛？进程的调度？通讯方式？（经典八股文）<a href="">项目</a>里面有实现这些通讯方式嘛？（？？？）</h2><h2 id="python用哪个模块实现多线程？（import-thread）项目中有涉及多线程嘛？（无···）"><a href="#python用哪个模块实现多线程？（import-thread）项目中有涉及多线程嘛？（无···）" class="headerlink" title="python用哪个模块实现多线程？（import thread）项目中有涉及多线程嘛？（无···）"></a>python用哪个模块实现多线程？（import thread）<a href="">项目</a>中有涉及多线程嘛？（无···）</h2><h2 id="数据结构了解嘛？（本科软工）讲一下数组和链表的区别？（送分题）插入数据的话二者的复杂度？"><a href="#数据结构了解嘛？（本科软工）讲一下数组和链表的区别？（送分题）插入数据的话二者的复杂度？" class="headerlink" title="数据结构了解嘛？（本科软工）讲一下数组和链表的区别？（送分题）插入数据的话二者的复杂度？"></a>数据结构了解嘛？（本科软工）讲一下数组和<a href="">链表</a>的区别？（送分题）插入数据的话二者的复杂度？</h2><h2 id="排序和查找算法了解嘛？那些排序算法复杂度是nlogn？"><a href="#排序和查找算法了解嘛？那些排序算法复杂度是nlogn？" class="headerlink" title="排序和查找算法了解嘛？那些排序算法复杂度是nlogn？"></a><a href="">排序</a>和查找<a href="">算法</a>了解嘛？那些<a href="">排序</a><a href="">算法</a>复杂度是nlogn？</h2><h2 id="你觉得Python语言有什么特性呢？"><a href="#你觉得Python语言有什么特性呢？" class="headerlink" title="你觉得Python语言有什么特性呢？"></a>你觉得Python语言有什么特性呢？</h2><h2 id="解释性语言和编译性语言的区别"><a href="#解释性语言和编译性语言的区别" class="headerlink" title="解释性语言和编译性语言的区别"></a>解释性语言和编译性语言的区别</h2><h2 id="有了解Python虚拟机吗？（回答不了解，只知道Python解释器），那你说一下解释器吧"><a href="#有了解Python虚拟机吗？（回答不了解，只知道Python解释器），那你说一下解释器吧" class="headerlink" title="有了解Python虚拟机吗？（回答不了解，只知道Python解释器），那你说一下解释器吧"></a>有了解Python虚拟机吗？（回答不了解，只知道Python解释器），那你说一下解释器吧</h2><h2 id="解释器主要的功能是什么？"><a href="#解释器主要的功能是什么？" class="headerlink" title="解释器主要的功能是什么？"></a>解释器主要的功能是什么？</h2><h2 id="CPython"><a href="#CPython" class="headerlink" title="CPython"></a><strong>CPython</strong></h2><p>当从Python官方网站下载并安装好Python2.7后，就直接获得了一个官方版本的解释器：Cpython，这个解释器是用C语言开发的，所以叫CPython，在命名行下运行python，就是启动CPython解释器，CPython是使用最广的Python解释器。</p>
<h2 id="IPython"><a href="#IPython" class="headerlink" title="IPython"></a>IPython</h2><p>IPython是基于CPython之上的一个交互式解释器，也就是说，IPython只是在交互方式上有所增强，但是执行Python代码的功能和CPython是完全一样的，好比很多国产浏览器虽然外观不同，但内核其实是调用了IE。</p>
<h2 id="PyPy"><a href="#PyPy" class="headerlink" title="PyPy"></a>PyPy</h2><p>PyPy是另一个Python解释器，它的目标是执行速度，PyPy采用JIT技术，对Python代码进行动态编译，所以可以显著提高Python代码的执行速度。</p>
<h2 id="Jython"><a href="#Jython" class="headerlink" title="Jython"></a>Jython</h2><p>Jython是运行在Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行。</p>
<h2 id="IronPython"><a href="#IronPython" class="headerlink" title="IronPython"></a>IronPython</h2><p>IronPython和Jython类似，只不过IronPython是运行在微软.Net平台上的Python解释器，可以直接把Python代码编译成.Net的字节码。</p>
<h2 id="GIL锁有了解吗，解释一下"><a href="#GIL锁有了解吗，解释一下" class="headerlink" title="GIL锁有了解吗，解释一下"></a>GIL锁有了解吗，解释一下</h2><h2 id="协程和线程之间的区别"><a href="#协程和线程之间的区别" class="headerlink" title="协程和线程之间的区别"></a>协程和线程之间的区别</h2><h2 id="进程切换和线程切换的区别"><a href="#进程切换和线程切换的区别" class="headerlink" title="进程切换和线程切换的区别"></a>进程切换和线程切换的区别</h2><h2 id="Python函数声明中有三种类型的参数，说一下区别（听题没听清楚，以为问的三种函数类型，面试官指正了问的是三种参数类型，反应过来后就重答了一下）"><a href="#Python函数声明中有三种类型的参数，说一下区别（听题没听清楚，以为问的三种函数类型，面试官指正了问的是三种参数类型，反应过来后就重答了一下）" class="headerlink" title="Python函数声明中有三种类型的参数，说一下区别（听题没听清楚，以为问的三种函数类型，面试官指正了问的是三种参数类型，反应过来后就重答了一下）"></a>Python函数声明中有三种类型的参数，说一下区别（听题没听清楚，以为问的三种函数类型，面试官指正了问的是三种参数类型，反应过来后就重答了一下）</h2><h2 id="说一下你知道的Django组件"><a href="#说一下你知道的Django组件" class="headerlink" title="说一下你知道的Django组件"></a>说一下你知道的Django组件</h2><h2 id="Python中的迭代器是怎么用的"><a href="#Python中的迭代器是怎么用的" class="headerlink" title="Python中的迭代器是怎么用的"></a>Python中的迭代器是怎么用的</h2><h2 id="你是怎么理解线程安全的"><a href="#你是怎么理解线程安全的" class="headerlink" title="你是怎么理解线程安全的"></a>你是怎么理解线程安全的</h2><h2 id="有哪些进程间通信方式"><a href="#有哪些进程间通信方式" class="headerlink" title="有哪些进程间通信方式"></a>有哪些进程间通信方式</h2><h2 id="列表去重"><a href="#列表去重" class="headerlink" title="列表去重"></a>列表去重</h2><h2 id="自己实现set类，应该如何去实现"><a href="#自己实现set类，应该如何去实现" class="headerlink" title="自己实现set类，应该如何去实现"></a>自己实现set类，应该如何去实现</h2><h2 id="有写过单元测试吗（回答没写过），那你平时是怎么调试的（回答的打断点debug），有在Linux上调试过吗（无）"><a href="#有写过单元测试吗（回答没写过），那你平时是怎么调试的（回答的打断点debug），有在Linux上调试过吗（无）" class="headerlink" title="有写过单元测试吗（回答没写过），那你平时是怎么调试的（回答的打断点debug），有在Linux上调试过吗（无）"></a>有写过单元测试吗（回答没写过），那你平时是怎么调试的（回答的打断点debug），有在Linux上调试过吗（无）</h2><h2 id="数据结构这一块你比较熟悉哪个，或者算法（回答都还可以），那么树的使用场景有哪些（答了一些场景），比如红黑树一般会在哪里使用呢（不知道）"><a href="#数据结构这一块你比较熟悉哪个，或者算法（回答都还可以），那么树的使用场景有哪些（答了一些场景），比如红黑树一般会在哪里使用呢（不知道）" class="headerlink" title="数据结构这一块你比较熟悉哪个，或者算法（回答都还可以），那么树的使用场景有哪些（答了一些场景），比如红黑树一般会在哪里使用呢（不知道）"></a>数据结构这一块你比较熟悉哪个，或者<a href="">算法</a>（回答都还可以），那么树的使用场景有哪些（答了一些场景），比如<a href="">红黑树</a>一般会在哪里使用呢（不知道）</h2><h2 id="在100个数中找第K大的数，如何实现"><a href="#在100个数中找第K大的数，如何实现" class="headerlink" title="在100个数中找第K大的数，如何实现"></a>在100个数中找第K大的数，如何实现</h2><p>（答的快排分治，用K和基准值比较决定往左分支或右分支进行单支递归），还有其他的思路吗（思考后说了大根堆），讲一下大根堆是什么（讲了大根堆的实现原理）</p>
<h2 id="Python还有哪些是你比较熟悉的，是我刚才没有问到的？"><a href="#Python还有哪些是你比较熟悉的，是我刚才没有问到的？" class="headerlink" title="Python还有哪些是你比较熟悉的，是我刚才没有问到的？"></a>Python还有哪些是你比较熟悉的，是我刚才没有问到的？</h2><p>（答了列表元组和字典的底层实现原理），那你说一下字典的底层原理吧（讲了3.6前后的字典原理区别）</p>
<h2 id="Linux内核熟悉吗（不熟悉），Linux常规使用（不太用）"><a href="#Linux内核熟悉吗（不熟悉），Linux常规使用（不太用）" class="headerlink" title="Linux内核熟悉吗（不熟悉），Linux常规使用（不太用）"></a>Linux内核熟悉吗（不熟悉），Linux常规使用（不太用）</h2><h2 id="网络这一块熟悉吗，我在浏览器上输入URL，它的请求过程是怎样的"><a href="#网络这一块熟悉吗，我在浏览器上输入URL，它的请求过程是怎样的" class="headerlink" title="网络这一块熟悉吗，我在浏览器上输入URL，它的请求过程是怎样的"></a>网络这一块熟悉吗，我在浏览器上输入URL，它的请求过程是怎样的</h2><h2 id="IP层分片重组是用来做什么的"><a href="#IP层分片重组是用来做什么的" class="headerlink" title="IP层分片重组是用来做什么的"></a>IP层分片重组是用来做什么的</h2><p>1.1 服务器UDP程序发2000 byte 数据，以一整块的方式到IP层</p>
<p>1.2 IP MTU = 1500，2000 byte 被分成两片</p>
<h2 id="TCP拥塞控制是怎么做的"><a href="#TCP拥塞控制是怎么做的" class="headerlink" title="TCP拥塞控制是怎么做的"></a>TCP拥塞控制是怎么做的</h2><h2 id="文件系统中的软链接知道是什么吗（不知道）"><a href="#文件系统中的软链接知道是什么吗（不知道）" class="headerlink" title="文件系统中的软链接知道是什么吗（不知道）"></a>文件系统中的软链接知道是什么吗（不知道）</h2><h2 id="现在有一个任务，最多只有10个线程在执行，如何实现？"><a href="#现在有一个任务，最多只有10个线程在执行，如何实现？" class="headerlink" title="现在有一个任务，最多只有10个线程在执行，如何实现？"></a>现在有一个任务，最多只有10个线程在执行，如何实现？</h2><p>（答了线程池），线程池具体怎么实现？那如果池子满了，其他任务该如何处理？还有别的思路吗？（要求提示一下，面试官提示了用队列去实现，答了双端队列）</p>
<h2 id="Python中使用锁是不是比较少？（是的）"><a href="#Python中使用锁是不是比较少？（是的）" class="headerlink" title="Python中使用锁是不是比较少？（是的）"></a>Python中使用锁是不是比较少？（是的）</h2><h2 id="如果我两个主机网络不通了，该如何排查？"><a href="#如果我两个主机网络不通了，该如何排查？" class="headerlink" title="如果我两个主机网络不通了，该如何排查？"></a>如果我两个主机网络不通了，该如何排查？</h2><h2 id="为什么需要用nginx反向代理"><a href="#为什么需要用nginx反向代理" class="headerlink" title="为什么需要用nginx反向代理"></a>为什么需要用nginx反向代理</h2><h2 id="nginx如何实现负载均衡"><a href="#nginx如何实现负载均衡" class="headerlink" title="nginx如何实现负载均衡"></a>nginx如何实现负载均衡</h2><h2 id="通过论文，你觉得导师为什么能快速想到你想不到的idea，导师是如何达到这样的高度的"><a href="#通过论文，你觉得导师为什么能快速想到你想不到的idea，导师是如何达到这样的高度的" class="headerlink" title="通过论文，你觉得导师为什么能快速想到你想不到的idea，导师是如何达到这样的高度的"></a>通过论文，你觉得导师为什么能快速想到你想不到的idea，导师是如何达到这样的高度的</h2><h2 id="场景题，双十一高并发，阿里架构师推出的产品是怎么做的"><a href="#场景题，双十一高并发，阿里架构师推出的产品是怎么做的" class="headerlink" title="场景题，双十一高并发，阿里架构师推出的产品是怎么做的"></a>场景题，双十一高并发，阿里架构师推出的产品是怎么做的</h2><p>给你做能想到哪些技术难点（答了两个点，面试官问还有别的点吗，提示了数据库支撑不了，补充了中间件）</p>
<h2 id="介绍自己的技术优势"><a href="#介绍自己的技术优势" class="headerlink" title="介绍自己的技术优势"></a>介绍自己的技术优势</h2><h2 id="自己想要达到的程度"><a href="#自己想要达到的程度" class="headerlink" title="自己想要达到的程度"></a>自己想要达到的程度</h2><h2 id="如果涉及其他语言的项目，学习能力如何"><a href="#如果涉及其他语言的项目，学习能力如何" class="headerlink" title="如果涉及其他语言的项目，学习能力如何"></a>如果涉及其他语言的<a href="">项目</a>，学习能力如何</h2><h2 id="除了Python外还需要什么技能"><a href="#除了Python外还需要什么技能" class="headerlink" title="除了Python外还需要什么技能"></a>除了Python外还需要什么技能</h2><p>云/运维：docker、k8s</p>
<p>存储：数据库</p>
<p>协议：HTTP/TCP/UDP</p>
<p>优化</p>
<p>处理大数据 spark flink  hadoop</p>
<p>监控平台</p>
<h2 id="字符串拼接方法哪个更快"><a href="#字符串拼接方法哪个更快" class="headerlink" title="字符串拼接方法哪个更快"></a>字符串拼接方法哪个更快</h2><h2 id="指针和引用区别"><a href="#指针和引用区别" class="headerlink" title="指针和引用区别"></a>指针和引用区别</h2><h2 id="红黑树及应用"><a href="#红黑树及应用" class="headerlink" title="红黑树及应用"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%BA%A2%E9%BB%91%E6%A0%91">红黑树</a>及应用</h2><h2 id="项目用到哪些数据结构"><a href="#项目用到哪些数据结构" class="headerlink" title="项目用到哪些数据结构"></a><a href="">项目</a>用到哪些数据结构</h2><h2 id="python数据结构有哪些，各有啥特点"><a href="#python数据结构有哪些，各有啥特点" class="headerlink" title="python数据结构有哪些，各有啥特点"></a>python数据结构有哪些，各有啥特点</h2><h2 id="哈希表原理，哈希冲突怎么解决"><a href="#哈希表原理，哈希冲突怎么解决" class="headerlink" title="哈希表原理，哈希冲突怎么解决"></a><a href="">哈希表</a>原理，哈希冲突怎么解决</h2><h2 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a><a href="">二叉树</a>的定义</h2><h2 id="二叉树查找方式有哪些"><a href="#二叉树查找方式有哪些" class="headerlink" title="二叉树查找方式有哪些"></a><a href="">二叉树</a>查找方式有哪些</h2><h2 id="二叉树和其他数据结构相比有什么特点"><a href="#二叉树和其他数据结构相比有什么特点" class="headerlink" title="二叉树和其他数据结构相比有什么特点"></a><a href="">二叉树</a>和其他数据结构相比有什么特点</h2><h2 id="B-树有什么应用场景"><a href="#B-树有什么应用场景" class="headerlink" title="B+树有什么应用场景"></a>B+树有什么应用场景</h2><h2 id="二叉树和图有什么区别"><a href="#二叉树和图有什么区别" class="headerlink" title="二叉树和图有什么区别"></a><a href="">二叉树</a>和图有什么区别</h2><h2 id="知道最小生成树吗"><a href="#知道最小生成树吗" class="headerlink" title="知道最小生成树吗"></a>知道最小生成树吗</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gw244rqywrj308c06qt8p.jpg" alt="img"></p>
<p>p 算法</p>
<p>1）以某一个点开始，寻找当前该点可以访问的所有的边；<br>2）在已经寻找的边中发现最小边，这个边必须有一个点还没有访问过，将还没有访问的点加入我们的集合，记录添加的边；<br>3）寻找当前集合可以访问的所有边，重复2的过程，直到没有新的点可以加入；<br>4）此时由所有边构成的树即为最小生成树。</p>
<p>k 算法</p>
<p>现在我们假设一个图有m个节点，n条边。首先，我们需要把m个节点看成m个独立的生成树，并且把n条边按照从小到大的数据进行排列。在n条边中，我们依次取出其中的每一条边，如果发现边的两个节点分别位于两棵树上，那么把两棵树合并成为一颗树；如果树的两个节点位于同一棵树上，那么忽略这条边，继续运行。等到所有的边都遍历结束之后，如果所有的生成树可以合并成一条生成树，那么它就是我们需要寻找的最小生成树，反之则没有最小生成树。</p>
<h2 id="什么是元类"><a href="#什么是元类" class="headerlink" title="什么是元类"></a>什么是元类</h2><p>所谓元类，就是类的类。也可以这么解释，对象是类实例化生成的，那类又是谁生成的？含无疑问，类是元类生成的。</p>
<ol>
<li><strong>道</strong> 即是 type</li>
<li><strong>一</strong> 即是 metaclass(元类，或者叫类生成器)</li>
<li><strong>二</strong> 即是 class(类，或者叫实例生成器)</li>
<li><strong>三</strong> 即是 instance(实例)</li>
<li><strong>万物</strong> 即是 实例的各种属性与方法，我们平常使用python时，调用的就是它们</li>
</ol>
<h2 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h2><p>1.栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈；</p>
<p>2.堆（操作系统）： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。</p>
<p>二.堆栈缓存方式区别：</p>
<p>1.栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放；</p>
<p>2.堆是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。</p>
<p>三.堆栈数据结构区别：</p>
<p>堆（数据结构）：堆可以被看成是一棵树，如：堆排序；</p>
<p>栈（数据结构）：一种先进后出的数据结构。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvzn5tz9klj30cc08k3yt.jpg" alt="img"></p>
<h2 id="什么是最小堆"><a href="#什么是最小堆" class="headerlink" title="什么是最小堆"></a>什么是最小堆</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvzn6eo4f0j30l40ihq3k.jpg" alt="img"></p>
<p>·<strong>最大堆性质</strong>： 结点的键值都小于等于其父结点的键值。</p>
<p>·<strong>最小堆性质</strong>： 结点的键值都大于等于其父结点的键值。</p>
<p>满足最大堆性质的二叉堆叫做最大堆，满足最小堆性质的二叉堆叫做最小堆。</p>
<p><strong>最小堆</strong></p>
<ol>
<li>数组来实现二叉树，所以满足二叉树的特性。</li>
<li>根元素是最小的元素，父节点小于它的两个子节点。</li>
<li>树中的元素是相对有序的。</li>
</ol>
<h2 id="动态规划是怎么解决问题的"><a href="#动态规划是怎么解决问题的" class="headerlink" title="动态规划是怎么解决问题的"></a><a href="">动态规划</a>是怎么解决问题的</h2><blockquote>
<p>动态编程是一种迭代解决递归性质问题的技术，适用于子问题的计算重叠的情况。而用记忆的方法可以防止重复计算子问题。</p>
<p>可以说动态规划问题可以用递归来解决。但是递归的问题不一定可以用动态规划问题解决，需要子问题的计算重叠。</p>
</blockquote>
<p>动态编程是一种迭代解决递归性质问题的技术，适用于子问题的计算重叠的情况。而用记忆的方法可以防止重复计算子问题。</p>
<p>可以说动态规划问题可以用递归来解决。但是递归的问题不一定可以用动态规划问题解决，需要子问题的<strong>计算重叠</strong>。</p>
<h2 id="python内置的算法有哪些"><a href="#python内置的算法有哪些" class="headerlink" title="python内置的算法有哪些"></a>python内置的<a href="">算法</a>有哪些</h2><ul>
<li>常用内置数据类型：list, tuple, dict, set, frozenset</li>
<li>collections</li>
<li>heapq</li>
<li>bisect</li>
</ul>
<h2 id="人生中最重要的算法是哪个"><a href="#人生中最重要的算法是哪个" class="headerlink" title="人生中最重要的算法是哪个"></a>人生中最重要的<a href="">算法</a>是哪个</h2><h2 id="字典、元组、列表的in方法哪个更快"><a href="#字典、元组、列表的in方法哪个更快" class="headerlink" title="字典、元组、列表的in方法哪个更快"></a>字典、元组、列表的in方法哪个更快</h2><p>很多人会告诉你，这是Hash Table，而Hash Table的访问速度是O(1)的</p>
<h2 id="open和with-open的区别"><a href="#open和with-open的区别" class="headerlink" title="open和with open的区别"></a>open和with open的区别</h2><p>平常用哪个比较多</p>
<p>由于文件读写时都有可能产生<code>IOError</code>，一旦出错，后面的<code>f.close()</code>就不会调用。所以，为了保证无论是否出错都能正确地关闭文件，我们可以使用<code>try ... finally</code>来实现：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def read_file():</span><br><span class="line">    try:</span><br><span class="line">        f = open(&#x27;sawako&#x27;, &#x27;r&#x27;)</span><br><span class="line">        try:</span><br><span class="line">            print(&#x27;&#x27;.join(f.readlines()))</span><br><span class="line">        except:</span><br><span class="line">            print(&#x27;error occurs while reading file&#x27;)</span><br><span class="line">        finally:</span><br><span class="line">            f.close()</span><br><span class="line">    except:</span><br><span class="line">        print(&quot;rror occurs while reading file&quot;)</span><br><span class="line">read_file()</span><br></pre></td></tr></table></figure>



<p>这样的操作太麻烦了，可以通过with open语法来代替：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def readFile():</span><br><span class="line">    try:</span><br><span class="line">        with open(&#x27;mio&#x27;, &#x27;r&#x27;) as f:</span><br><span class="line">            print((&#x27;&#x27;.join(f.readlines())))</span><br><span class="line">    except:</span><br><span class="line">        print(&#x27;error occurs while reading file&#x27;)</span><br><span class="line">readFile()</span><br></pre></td></tr></table></figure>

<p>执行结果与上例相同。这和前面的<code>try ... finally</code>是一样的，但是代码更佳简洁，并且不必调用<code>f.close()</code>方法。</p>
<h2 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvzmov50uuj305l06lglh.jpg" alt="img"></p>
<p>这一类单词集合在本数据结构中公用前缀，因此，当我们搜索单词的时候，这一数据结构可以自动帮助我们过滤掉那些前缀不一致的单词。当单词数据库变的很大很大的时候，这一检索方法会帮我们节省大量的时间。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">words = [<span class="string">&#x27;cat&#x27;</span>,<span class="string">&#x27;category&#x27;</span>,<span class="string">&#x27;tree&#x27;</span>,<span class="string">&#x27;trace&#x27;</span>,<span class="string">&#x27;top&#x27;</span>]</span><br><span class="line">trie = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">    t = trie <span class="comment"># 请把这个t理解为指针，这个指针除了用来移动外，也用来建立新的字典。</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> word:</span><br><span class="line">        <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> t:</span><br><span class="line">            t[c] = &#123;&#125; <span class="comment"># 若没有，为下一个字母建立一个新的字典</span></span><br><span class="line">        t = t[c] <span class="comment"># 进入下一层</span></span><br><span class="line">    t[<span class="string">&#x27;#&#x27;</span>] = <span class="string">&#x27;#&#x27;</span> <span class="comment"># 句尾结束符</span></span><br><span class="line">print(trie)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">word</span>):</span></span><br><span class="line">    t = trie</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> word:</span><br><span class="line">        <span class="keyword">if</span> c <span class="keyword">in</span> t: <span class="comment"># 如果我们在本层发现了这个字母，那么，我们进入下一层</span></span><br><span class="line">            t = t[c] <span class="comment"># 关键点依然是把t理解成指针。</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;#&#x27;</span> <span class="keyword">in</span> t: <span class="comment"># 当所有字母都检查完毕的时候，我们需要确定，这个被查询的序列到底是不是一个完整的单词</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>



<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><h2 id="如何杀死-test-py进程"><a href="#如何杀死-test-py进程" class="headerlink" title="如何杀死 test.py进程"></a>如何杀死 test.py进程</h2><p>（我说先用ps查看进程号，然后kill -9 kill掉，然后就问我如何用一行命令杀死）</p>
<p><code>ps -ef | grep flask | grep -v grep | awk &#39;&#123;print $2&#125;&#39; | xargs kill -9</code></p>
<ul>
<li>AWK 是一种处理文本文件的语言，是一个强大的文本分析工具</li>
</ul>
<h2 id="快排的思路"><a href="#快排的思路" class="headerlink" title="快排的思路"></a>快排的思路</h2><h2 id="给定一个a-txt，b-txt文件，里面存有许多ip地址，现在判断有多少个相同的IP"><a href="#给定一个a-txt，b-txt文件，里面存有许多ip地址，现在判断有多少个相同的IP" class="headerlink" title="给定一个a.txt，b.txt文件，里面存有许多ip地址，现在判断有多少个相同的IP"></a>给定一个a.txt，b.txt文件，里面存有许多ip地址，现在判断有多少个相同的IP</h2><p>   方案1：可以估计每个文件安的大小为5G×64=320G，远远大于内存限制的4G。所以不可能将其完全加载到内存中处理。考虑采取分而治之的方法。</p>
<pre><code>遍历文件a，对每个url求取hash(url)%1000，然后根据所取得的值将url分别存储到1000个小文件（记为a0,a1,...,a999）中。这样每个小文件的大约为300M。

遍历文件b，采取和a相同的方式将url分别存储到1000小文件（记为b0,b1,...,b999）。这样处理后，所有可能相同的url都在对应的小文件（a0vsb0,a1vsb1,...,a999vsb999）中，不对应的小文件不可能有相同的url。然后我们只要求出1000对小文件中相同的url即可。

求每对小文件中相同的url时，可以把其中一个小文件的url存储到hash_set中。然后遍历另一个小文件的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。

方案2：如果允许有一定的错误率，可以使用Bloom filter，4G内存大概可以表示340亿bit。将其中一个文件中的url使用Bloom filter映射为这340亿bit，然后挨个读取另外一个文件的url，检查是否与Bloom filter，如果是，那么该url应该是共同的url（注意会有一定的错误率）。

Bloom filter日后会在本BLOG内详细阐述。
</code></pre>
<h2 id="统计在文件夹-root-下，包含“word”的文件的个数"><a href="#统计在文件夹-root-下，包含“word”的文件的个数" class="headerlink" title="统计在文件夹/root 下，包含“word”的文件的个数"></a>统计在文件夹/root 下，包含“word”的文件的个数</h2><ul>
<li>统计当前目录下文件的个数（不包括目录）</li>
</ul>
<p>``$ ls -l | grep “^-“ | wc -l`</p>
<ul>
<li>统计当前目录下文件的个数（包括子目录）</li>
</ul>
<p>``$ ls -lR| grep “^-“ | wc -l`</p>
<ul>
<li>查看某目录下文件夹(目录)的个数（包括子目录）</li>
</ul>
<p>``$ ls -lR | grep “^d” | wc -l`</p>
<ul>
<li><code>grep &quot;^-&quot;</code><br>  过滤<code>ls</code>的输出信息，只保留一般文件，只保留目录是<code>grep &quot;^d&quot;</code>。</li>
<li><code>wc -l</code><br>  统计输出信息的行数，统计结果就是输出信息的行数，一行信息对应一个文件，所以就是文件的个数。</li>
</ul>
<h2 id="MySQL的调优"><a href="#MySQL的调优" class="headerlink" title="MySQL的调优"></a>MySQL的调优</h2><h2 id="现有100亿个QQ号，如何快速判断某个QQ号是否在其中，存储方式自己考虑，越快越好（运行时间），空间越小越好。"><a href="#现有100亿个QQ号，如何快速判断某个QQ号是否在其中，存储方式自己考虑，越快越好（运行时间），空间越小越好。" class="headerlink" title="现有100亿个QQ号，如何快速判断某个QQ号是否在其中，存储方式自己考虑，越快越好（运行时间），空间越小越好。"></a>现有100亿个QQ号，如何快速判断某个QQ号是否在其中，存储方式自己考虑，越快越好（运行时间），空间越小越好。</h2><p>mapreduce</p>
<p>Len(qq—nums) 5 6 7 8 9 10 11 划分片段</p>
<p>分治 </p>
<p>位图法：40 亿个不重复整数，我们用 40 亿个 bit 来表示，初始位均为 0，那么总共需要内存：4,000,000,000b≈512M。我们读取这 40 亿个整数，将对应的 bit 设置为 1。接着读取要查询的数，查看相应位是否为 1，如果为 1 表示存在，如果为 0 表示不存在。</p>
<p>可以hash一下，拆分成N多库N多表N多机器，比如一台机器分配100万用户，查询毫无压力吧。再说登录并发不算高，谁没事登着玩啊。</p>
<h2 id="大数据处理"><a href="#大数据处理" class="headerlink" title="大数据处理"></a>大数据处理</h2><p>针对时间，我们可以采用巧妙的算法搭配合适的数据结构，如Bloom filter/Hash/bit-map/堆/数据库或倒排索引/trie树；</p>
<p>针对空间，无非就一个办法：大而化小，分而治之（hash映射），你不是说规模太大嘛，那简单啊，就把规模大化为规模小的，各个击破不就完了嘛；</p>
<p><strong>分而治之/hash映射 + hash统计 + 堆/快速/归并排序</strong></p>
<ol>
<li>分而治之/hash映射：针对数据太大，内存受限，只能把大文件化成(取模映射)小文件</li>
<li>hash_map统计：当大文件转化了小文件，那么我们便可以采用常规的hash_map(key，value)来进行频率统计</li>
<li>堆/快速排序：统计完了之后，便进行排序(可采取堆排序)，得到次数最多的key</li>
</ol>
<h2 id="迭代器-1"><a href="#迭代器-1" class="headerlink" title="迭代器"></a>迭代器</h2><p>是访问集合元素的一种方式，从集合的第一个元素开始访问，直到所有元素被访问结束。其优点是不需要事先准备好整个迭代过程中的所有元素，仅在迭代到某个元素时才开始计算该元素。适合遍历比较巨大的集合。<strong>iter</strong>()：方法返回迭代器本身， <strong>next</strong>()：方法用于返回容器中下一个元素或数据。</p>
<h2 id="生成器-1"><a href="#生成器-1" class="headerlink" title="生成器"></a>生成器</h2><p>带有yield的函数不再是一个普通函数，而是一个生成器。当函数被调用时，返回一个生成器对象。不像一般函数在生成值后退出，生成器函数在生成值后会自动挂起并暂停他们的执行状态。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;迭代器&#x27;&#x27;&#x27;</span></span><br><span class="line">print(<span class="string">&#x27;for x in iter([1, 2, 3, 4, 5]):&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">iter</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]):</span><br><span class="line">    print(x)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;生成器&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myyield</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">while</span> n&gt;<span class="number">0</span>:</span><br><span class="line">        print(<span class="string">&quot;开始生成...:&quot;</span>)</span><br><span class="line">        <span class="keyword">yield</span> n</span><br><span class="line">        print(<span class="string">&quot;完成一次...:&quot;</span>)</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> myyield(<span class="number">4</span>):</span><br><span class="line">    print(<span class="string">&quot;遍历得到的值:&quot;</span>,i)</span><br></pre></td></tr></table></figure>



<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包可以实现先将一个参数传递给一个函数，而并不立即执行，以达到延迟求值的目的。闭包可以保存当前的运行环境</p>
<p>满足以下三个条件：必须有一个内嵌函数；内嵌函数必须引用外部函数中变量；外部函数返回值必须是内嵌函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delay_fun</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">caculator</span>():</span></span><br><span class="line">        <span class="keyword">return</span> x+y</span><br><span class="line">    <span class="keyword">return</span> caculator</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;返回一个求和的函数，并不求和&#x27;</span>)</span><br><span class="line">msum = delay_fun(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">print(<span class="string">&#x27;调用并求和:&#x27;</span>)</span><br><span class="line">print(msum())</span><br></pre></td></tr></table></figure>

<h2 id="args-和-kwargs"><a href="#args-和-kwargs" class="headerlink" title="**args 和 *kwargs"></a>*<em>*args 和 *<em>kwargs</em></em></h2><p>这两个是Python中的可变参数，用于接受参数的传递。<em>args表示任何多个无名参数，它是一个元组，**kwargs表示关键字参数，它是一个字典。同时使用</em>args和<strong>kwargs时，必须*args在</strong>kwargs之前</p>
<h2 id="property-和-setter"><a href="#property-和-setter" class="headerlink" title="@property 和 @setter"></a><strong>@property 和 @setter</strong></h2><p>@property负责把一个方法变成属性调用。在对实例操作时，不暴露接口，而是通过getter和setter方法实现。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._score</span><br><span class="line"></span><br><span class="line"><span class="meta">    @score.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(value, <span class="built_in">int</span>):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;score must be an intager&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> value&lt;<span class="number">0</span> <span class="keyword">or</span> value&gt;<span class="number">100</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;score must between 0~100!&#x27;</span>)</span><br><span class="line">        self._score = value</span><br><span class="line"></span><br><span class="line">s = Student()</span><br><span class="line">s.score = <span class="number">60</span></span><br><span class="line">print(s.score)</span><br><span class="line">s.score = <span class="number">999</span></span><br><span class="line">print(s.score)</span><br></pre></td></tr></table></figure>



<h2 id="Python-方法"><a href="#Python-方法" class="headerlink" title="Python 方法"></a>Python 方法</h2><p>Python中有三种方法，实例方法、类方法(@classmethod)、静态方法(@staticmethod)。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        print(<span class="string">&quot;executing foo(%s,%s)&quot;</span> % (self, x))</span><br><span class="line">        print(<span class="string">&#x27;self:&#x27;</span>, self)</span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">class_foo</span>(<span class="params">cls, x</span>):</span></span><br><span class="line">        print(<span class="string">&quot;executing class_foo(%s,%s)&quot;</span> % (cls, x))</span><br><span class="line">        print(<span class="string">&#x27;cls:&#x27;</span>, cls)</span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">static_foo</span>(<span class="params">x</span>):</span></span><br><span class="line">        print(<span class="string">&quot;executing static_foo(%s)&quot;</span> % x)</span><br><span class="line">a = A()</span><br><span class="line">print(a.foo(<span class="number">1</span>))</span><br><span class="line">print(a.class_foo(<span class="number">1</span>))</span><br><span class="line">print(a.static_foo(<span class="number">1</span>))</span><br></pre></td></tr></table></figure>



<h2 id="import之类的知识点"><a href="#import之类的知识点" class="headerlink" title="import之类的知识点"></a>import之类的知识点</h2><p> 模块（Module）和 <strong>包（Package）</strong> </p>
<ul>
<li>模块<ul>
<li>不管是对常见的<code>*.py</code>文件，或是编译优化的<code>*.pyc</code>, <code>*.pyo</code>文件、扩展类型的<code>*.pyd</code>，<code>*.pyw</code>文件来说， 它们是属于Python代码载体的最小单元，这样单独存在的文件我们都称之为“模块”。</li>
</ul>
</li>
<li>包<ul>
<li> import 导入该目录时，会执行 <strong>__init__.py</strong> 里面的代码。</li>
</ul>
</li>
</ul>
<h2 id="Python进程、线程、协程概念"><a href="#Python进程、线程、协程概念" class="headerlink" title="Python进程、线程、协程概念"></a>Python进程、线程、协程概念</h2><ul>
<li><p>进程：每个程序，本身首先是一个进程</p>
<ul>
<li>运行中每个进程都拥有自己的地址空间、内存、数据栈及其它资源。</li>
<li>进程彼此之间互相隔离，要实现进程间通信（IPC），multiprocessing 模块支持两种形式：<strong>队列和管道</strong>，这两种方式都是使用消息传递的。<ul>
<li>进程 queue: 在生成子进程的时候，会将代码拷贝到子进程中执行一遍，及子进程拥有和主进程内容一样的不同的名称空间。</li>
<li>管道 Pipe</li>
<li>共享数据</li>
<li>进程池</li>
</ul>
</li>
</ul>
</li>
<li><p>线程：线程，是在进程中执行的代码。一个进程下可以运行多个线程，这些线程之间共享主进程内申请的操作系统资源。</p>
<ul>
<li>线程，必须在一个存在的进程中启动运行</li>
<li>线程使用进程获得的系统资源，不会像进程那样需要申请CPU等资源</li>
<li>线程池：线程池在系统启动时即创建大量空闲的线程，程序只要将一个函数提交给线程池，线程池就会启动一个空闲的线程来执行它。当该函数执行结束后，该线程并不会死亡，而是再次返回到线程池中变成空闲状态，等待执行下一个函数。使用线程池可以有效地控制系统中并发线程的数量</li>
<li>多线程通信<ul>
<li>共享变量：创建全局变量，多个线程公用一个全局变量，方便简单。但是坏处就是共享变量容易出现数据竞争，不是线程安全的，解决方法就是使用互斥锁。</li>
<li>队列：线程间使用队列进行通信，因为队列所有方法都是线程安全的，所以不会出现线程竞争资源的情况</li>
</ul>
</li>
</ul>
</li>
<li><p>协程：又称微线程，纤程，英文名Coroutine。协程的作用，是在执行函数A时，可以随时中断，去执行函数B，然后中断继续执行函数A（可以自由切换）。但这一过程并不是函数调用（没有调用语句），这一整个过程看似像多线程，然而协程只有一个线程执行。协程由于由程序主动控制切换，没有线程切换的开销，所以执行效率极高。对于IO密集型任务非常适用，如果是cpu密集型，推荐多进程+协程的方式。协程间是协同调度的，这使得并发量数万以上的时候，协程的性能是远远高于线程。</p>
</li>
</ul>
<h2 id="常见Web安全"><a href="#常见Web安全" class="headerlink" title="常见Web安全"></a>常见Web安全</h2><h3 id="SQL-注入"><a href="#SQL-注入" class="headerlink" title="SQL 注入"></a>SQL 注入</h3><p>当应用程序将用户输入的内容，拼接到 SQL 语句中，一起提交给数据库执行时，就会产生SQL注入威胁。由于用户的输入，也是SQL语句的一部分，所以攻击者可以利用这部分可以控制的内容，注入自己定义的语句，改变 SQL 语句执行逻辑，让数据库执行任意自己需要的指令。通过控制部分 SQL 语句，攻击者可以查洵数据库中任何自己需要的数据，利用数据库的一些特性，可以直接获取数据库服务器的系统权限。</p>
<p>本来 SQL 注入攻击需要攻击者对 SQL 语句非常了解，所以对攻击者的技术有一定要求。但是现在已经出现了大量 SQL 注入利用工具，可以让任何攻击者，只要点几下鼠标，就能达到攻击效果，这使得 SQL 注入的威胁极大增加。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">USER</span> <span class="keyword">WHERE</span> username <span class="operator">=</span> &quot;Mark&quot;; <span class="keyword">AND</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span><span class="comment">-- AND PASSWORD=&quot;1234&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>如何防范？</strong></p>
<p>不信任用户输入的数据，确保用户输入必须经过检查，目前许多成熟的 Web 框架都支持ORM 服务，大部分都基本防范了 SQL 注入。保护网站不受注入攻击危害，主要落实到代码库构建上。比如说，缓解 SQL 注入风险的首选方法就是始终尽量采用参数化语句。更进一步，可以考虑使用第三方身份验证工作流来外包你的数据库防护。</p>
<h3 id="XSS-跨站脚本攻击"><a href="#XSS-跨站脚本攻击" class="headerlink" title="XSS 跨站脚本攻击"></a>XSS 跨站脚本攻击</h3><p>跨站脚本攻击（Cross Site Scripting)，为不和层叠样式表(Cascading Style Sheets, CSS）的缩写混淆，故将跨站脚本攻击缩写为XSS。恶意攻击者往Web页面里插入恶意 html 代码，当用户浏览该页之时，嵌入其中Web里面的html代码会被执行，从而达到恶意攻击用户的特殊目的。</p>
<ul>
<li>反射型跨站脚本攻击</li>
</ul>
<p>攻击者会通过社会工程学手段，发送一个URL连接给用户打开，在用户打开页面的同时，浏览器会执行页面中<strong>嵌入的恶意脚本</strong>。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gw0qjxdh62j30kc0450sv.jpg" alt="img"></p>
<ul>
<li>存储型跨站脚本攻击</li>
</ul>
<p>攻击者利用 web 应用程序提供的录入或修改数据功能，将<strong>数据存储到服务器或用户 cookie 中</strong>，当其他用户浏览展示该数据的页面时，浏览器会执行页面中嵌入的恶意脚本。所有浏览者都会受到攻击。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gw0qjzfo2dj30gj055dg3.jpg" alt="img"></p>
<ul>
<li>命令注入</li>
</ul>
<p>OS 命令注入攻击指通过 Web 应用，执行非法的操作系统命令达到攻击的目的。只要在能调用 Shell 函数的地方就有存在被攻击的风险。倘若调用 Shell 时存在疏漏，就可以执行插入的非法命令。命令注入攻击可以向 Shell 发送命令，让 Windows 或 Linux 操作系统的命令行启动程序。也就是说，通过命令注入攻击可执行操作系统上安装着的各种程序。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gw0qjyu69mj30i904aglm.jpg" alt="img"></p>
<h3 id="CSRF-跨站请求伪造"><a href="#CSRF-跨站请求伪造" class="headerlink" title="CSRF 跨站请求伪造"></a>CSRF 跨站请求伪造</h3><p>CSRF(Cross Site Request Forgery)，利用已登录的用户身份，以用户的名义发送恶意请求，完成非法操作。</p>
<p>例如，如果用户浏览并信任具有 CSRF 漏洞的网站 A，则浏览器会生成相应的 cookie，并且用户访问危险的网站B而不退出网站。危险网站 B 要求访问网站 A 并提出要求。 浏览器使用用户的 cookie 信息访问网站  A。 由于网站 A 不知道是用户自身发出的请求还是危险网站 B 发出的请求，因此将处理危险网站 B 的请求，从而完成了用户操作目的的模拟。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gw0qoc49hjj30c008fmxn.jpg" alt="img"></p>
<h3 id="越权访问"><a href="#越权访问" class="headerlink" title="越权访问"></a>越权访问</h3><p>越权漏洞是指应用在检查授权（Authorization）时存在纰漏，使得攻击者在获得低权限用户帐后后，可以利用一些方式绕过权限检查，访问或者操作到原本无权访问的高权限功能。在实际的代码安全审查中，这类漏洞往往很难通过工具进行自动化检测，因此在实际应用中危害很大。其与未授权访问有一定差别。目前存在着两种越权操作类型：垂直越权操作和水平越权操作。</p>
<p>垂直越权漏洞，也称为<strong>权限提升</strong>，是一种<strong>“基于 UR L的访问控制”</strong>设计缺陷引起的漏洞。由于 Web 应用程序没有做权限控制或者仅在菜单上做了权限控制，导致恶意用户只要猜测其他管理页面的 URL，就可以访问或控制其他角色拥有的数据或页面，达到权限提升的目的。</p>
<p>水平越权漏洞，是一种<strong>“基于数据的访问控制”</strong>设计缺陷引起的漏洞。由于服务器端在接收到请求数据进行操作时没有判断数据的所属人而导致的越权数据访问漏洞。如服务器端从客户端提交的 request 参数(用户能够控制的数据)中获取用户 id，恶意攻击者通过变换请求 ID 的值，查看或修改不属于本人的数据。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gw0qr8109nj30kc0akdg2.jpg" alt="img"></p>
<h3 id="模糊测试"><a href="#模糊测试" class="headerlink" title="模糊测试"></a>模糊测试</h3><p>开发人员使用模糊测试来查找软件、操作系统或网络中的编程错误和安全漏洞。然而，攻击者可以使用同样的技术来寻找你网站或服务器上的漏洞。</p>
<p>采用模糊测试方法，攻击者首先向应用输入大量随机数据（模糊）让应用崩溃。下一步就是用模糊测试工具发现应用的弱点。如果目标应用中存在漏洞，攻击者即可展开进一步漏洞利用。</p>
<p>对抗模糊攻击的最佳方法就是保持更新安全设置和其他应用，尤其是在安全补丁发布后不更新就会遭遇恶意黑客利用漏洞的情况下。</p>
<h3 id="零日攻击"><a href="#零日攻击" class="headerlink" title="零日攻击"></a>零日攻击</h3><p>零日攻击是模糊攻击的扩展，但不要求识别漏洞本身。此类攻击最近的案例是谷歌发现的，他们在 Windows 和 Chrome 软件中发现了潜在的零日攻击。</p>
<p>在两种情况下，恶意黑客能够从零日攻击中获利。</p>
<ul>
<li>第一种情况是，如果能够获得关于即将到来的安全更新的信息，攻击者就可以在更新上线前分析出漏洞的位置。</li>
<li>第二种情况是，网络罪犯获取补丁信息，然后攻击尚未更新系统的用户。</li>
<li>保护自己和自身网站不受零日攻击影响最简便的方法，就是在新版本发布后及时更新你的软件。</li>
</ul>
<h3 id="目录遍历"><a href="#目录遍历" class="headerlink" title="目录遍历"></a>目录遍历</h3><p>路径遍历攻击不像上述几种攻击方法那么常见，但仍然是任何 Web 应用的一大威胁。路径遍历攻击针对 Web root 文件夹，访问目标文件夹外部的未授权文件或目录。攻击者试图将移动模式注入服务器目录，以便向上爬升。成功的路径遍历攻击能够获得网站访问权，染指配置文件、数据库和同一实体服务器上的其他网站和文件。</p>
<p>网站能否抵御路径遍历攻击取决于你的输入净化程度。这意味着保证用户输入安全，并且不能从你的服务器恢复出用户输入内容。最直观的建议就是打造你的代码库，这样用户的任何信息都不会传输到文件系统 API。即使这条路走不通，也有其他技术解决方案可用。</p>
<h3 id="DDoS"><a href="#DDoS" class="headerlink" title="DDoS"></a>DDoS</h3><p>DDoS 攻击本身不能使恶意黑客突破安全措施，但会令网站暂时或永久掉线。卡巴斯基实验室《2017年 IT 安全风险调查》指出，单次DDoS攻击可令小企业平均损失 12.3 万美元，大型企业的损失水平在230万美元左右。</p>
<p>DDoS 旨在用请求洪水压垮目标 Web 服务器，让其他访客无法访问网站。僵尸网络通常能够利用之前感染的计算机从全球各地协同发送大量请求。而且，DDoS 攻击常与其他攻击方法搭配使用；攻击者利用 DDoS 攻击吸引安全系统火力，从而暗中利用漏洞入侵系统。</p>
<p>保护网站免遭 DDoS 攻击侵害一般要从几个方面着手。首先，需通过内容分发网络（CDN）、负载均衡器和可扩展资源缓解高峰流量。其次，需部署 Web 应用防火墙（WAF），防止DDoS 攻击隐蔽注入攻击或跨站脚本等其他网络攻击方法。</p>
<h3 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h3><p>中间人攻击常见于用户与服务器间传输数据不加密的网站。作为用户，只要看看网站的 URL 是不是以 HTTPS 开头就能发现这一潜在风险了，因为HTTPS中的“S”指的就是数据是加密的，缺了“S”就是未加密。</p>
<p>攻击者利用中间人类型的攻击收集信息，通常是敏感信息。数据在双方之间传输时可能遭到恶意黑客拦截，如果数据未加密，攻击者就能轻易读取个人信息、登录信息或其他敏感信息。</p>
<p>在网站上安装安全套接字层（SSL）就能缓解中间人攻击风险。SSL证书加密各方间传输的信息，攻击者即使拦截到了也无法轻易破解。现代托管提供商通常已经在托管服务包中配置了 SSL 证书。</p>
<h3 id="暴力破解攻击"><a href="#暴力破解攻击" class="headerlink" title="暴力破解攻击"></a>暴力破解攻击</h3><p>暴力破解攻击是获取Web应用登录信息相当直接的一种方式。但同时也是非常容易缓解的攻击方式之一，尤其是从用户侧加以缓解最为方便。</p>
<p>暴力破解攻击中，攻击者试图猜解用户名和密码对，以便登录用户账户。当然，即使采用多台计算机，除非密码相当简单且明显，否则破解过程可能需耗费几年时间。</p>
<p>保护登录信息的最佳办法，是创建强密码，或者使用双因子身份验证（2FA）。作为网站拥有者，你可以要求用户同时设置强密码和2FA，以便缓解网络罪犯猜出密码的风险。</p>
<h3 id="使用未知代码或第三方代码"><a href="#使用未知代码或第三方代码" class="headerlink" title="使用未知代码或第三方代码"></a>使用未知代码或第三方代码</h3><p>尽管不是对网站的直接攻击，使用由第三方创建的未经验证代码，也可能导致严重的安全漏洞。</p>
<p>代码或应用的原始创建者可能会在代码中隐藏恶意字符串，或者无意中留下后门。一旦将“受感染”的代码引入网站，那你就会面临恶意字符串执行或后门遭利用的风险。其后果可以从单纯的数据传输直到网站管理权限陷落。</p>
<p>想要避免围绕潜在数据泄露的风险，请让你的开发人员分析并审计代码的有效性。此外，确保所用插件（尤其是WordPress插件）及时更新，并定期接收安全补丁：研究显示，超过 1.7 万个 WordPress 插件（约占研究当时采样数量的47%）两年内没有更新。</p>
<h3 id="网络钓鱼"><a href="#网络钓鱼" class="headerlink" title="网络钓鱼"></a>网络钓鱼</h3><p>网络钓鱼是另一种没有直接针对网站的攻击方法，但我们不能将它排除在名单之外，因为网络钓鱼也会破坏你系统的完整性。根据 FBI《互联网犯罪报告》的说法，其原因在于网络钓鱼是最常见的社会工程网络犯罪。</p>
<p>网络钓鱼攻击用到的标准工具就是电子邮件。攻击者通常会伪装成其他人，诱骗受害者给出敏感信息或执行银行转账。此类攻击可以是古怪的 419 骗局（属于预付费欺诈类骗局），或者涉及假冒电子邮件地址、貌似真实的网站和极具说服力用语的高端攻击。后者以鱼叉式网络钓鱼之名广为人知。</p>
<p>缓解网络钓鱼骗局风险最有效的办法，是培训员工和自身，增强对此类欺诈的辨识能力。保持警惕，总是检查发送者电子邮件地址是否合法，邮件内容是否古怪，请求是否不合常理。另外，谨记：天上不会掉馅饼，事出反常必有妖。</p>
<h3 id="DDoS-1"><a href="#DDoS-1" class="headerlink" title="DDoS"></a>DDoS</h3><p>将DDoS的攻击方式分成4类，分别是攻击网络带宽、攻击系统、攻击应用、混合攻击。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gw0t7mcu6gj30u00hx797.jpg" alt="img"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gw0tanmak6j30u00eljv1.jpg" alt="原创 | DDoS攻击技术分析与防御"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gw0taws3cxj30u00g4di9.jpg" alt="原创 | DDoS攻击技术分析与防御"></p>
<p>DRDoS(DistributedReflectionDenialofService，分布式反射拒绝服务)，是指攻击者利用路由器、服务器等设施对请求产生应答，从而反射出大量的流量对受害者进行攻击的一种DDoS攻击方式。这种攻击方式隐蔽，更大危害还来自于使用反射过程的放大。放大是一种特殊的反射攻击，其特殊之处在于反射器对于网络流量具有放大作用，可以将攻击者较小的流量放大成较大流量，从而造成更加严重的带宽消耗。</p>
<h3 id="DDoS检测"><a href="#DDoS检测" class="headerlink" title="DDoS检测"></a>DDoS检测</h3><ul>
<li><p>特征检测（首先对异常信息源建模分析提取特征向量，根据特征设计针对性的特征检测算法，若新数据样本检测出相应的特征值，则发布预警或进行反应）</p>
</li>
<li><p>异常检测（创建正常的系统或者网络的基准轮廓，异常）</p>
</li>
<li><p><strong>网络流量实时监测系统</strong></p>
<p>  ( 1 ) 发现网络流量突然暴增，出现异常变化。</p>
<p>  ( 2 ) 个别网络协议（如：ICMP、UDP、TCP；HTTP、DNS等）突然暴增。</p>
<p>  ( 3 ) 出现相同源地址的大量数据包、大量垃圾数据包。</p>
</li>
<li><p><strong>基于设备运行状态</strong></p>
<p>  ( 1 ) 监控业务系统性能，网络设备、服务器CUP占用率突然增高。</p>
<p>  ( 2 ) 业务系统的业务请求连接突然大量增加。</p>
<p>  ( 3 ) 服务器出现大量垃圾数据包。</p>
<p>  ( 4 ) 将服务器网络断开后，异常状态消失。</p>
</li>
</ul>
<h2 id="OSI-七层协议"><a href="#OSI-七层协议" class="headerlink" title="OSI 七层协议"></a>OSI 七层协议</h2><h2 id="TCP的重传机制、快速重传是怎样的"><a href="#TCP的重传机制、快速重传是怎样的" class="headerlink" title="TCP的重传机制、快速重传是怎样的"></a>TCP的重传机制、快速重传是怎样的</h2><p>重传机制的其中一个方式，就是在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 <code>ACK</code> 确认应答报文，就会重发该数据，也就是我们常说的<strong>超时重传</strong>。</p>
<p>TCP 会在以下两种情况发生超时重传：</p>
<ul>
<li>数据包丢失</li>
<li>确认应答丢失</li>
</ul>
<p>今天，将重点介绍 TCP 的<strong>重传机制、滑动窗口、流量控制、拥塞控制。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/3.jpg" alt="img"></p>
<h3 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h3><p>TCP 实现可靠传输的方式之一，是通过序列号与确认应答。</p>
<p>在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回一个确认应答消息，表示已收到消息。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/4.jpg" alt="正常的数据传输">正常的数据传输</p>
<p>但在错综复杂的网络，并不一定能如上图那么顺利能正常的数据传输，万一数据在传输过程中丢失了呢？</p>
<p>所以 TCP 针对数据包丢失的情况，会用<strong>重传机制</strong>解决。</p>
<p>接下来说说常见的重传机制：</p>
<ul>
<li>超时重传</li>
<li>快速重传</li>
<li>SACK</li>
<li>D-SACK</li>
</ul>
<h4 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h4><p>重传机制的其中一个方式，就是在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 <code>ACK</code> 确认应答报文，就会重发该数据，也就是我们常说的<strong>超时重传</strong>。</p>
<p>TCP 会在以下两种情况发生超时重传：</p>
<ul>
<li>数据包丢失</li>
<li>确认应答丢失</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/5.jpg" alt="超时重传的两种情况">超时重传的两种情况</p>
<blockquote>
<p>超时时间应该设置为多少呢？</p>
</blockquote>
<p>我们先来了解一下什么是 <code>RTT</code>（Round-Trip Time 往返时延），从下图我们就可以知道：</p>
<p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/6.jpg" alt="RTT">RTT</p>
<p><code>RTT</code> 就是<strong>数据从网络一端传送到另一端所需的时间</strong>，也就是包的往返时间。</p>
<p>超时重传时间是以 <code>RTO</code> （Retransmission Timeout 超时重传时间）表示。</p>
<p>假设在重传的情况下，超时时间 <code>RTO</code> 「较长或较短」时，会发生什么事情呢？</p>
<p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/7.jpg" alt="超时时间较长与较短">超时时间较长与较短</p>
<p>上图中有两种超时时间不同的情况：</p>
<ul>
<li>当超时时间 <strong>RTO 较大</strong>时，重发就慢，丢了老半天才重发，没有效率，性能差；</li>
<li>当超时时间 <strong>RTO 较小</strong>时，会导致可能并没有丢就重发，于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。</li>
</ul>
<p>精确的测量超时时间 <code>RTO</code> 的值是非常重要的，这可让我们的重传机制更高效。</p>
<p>根据上述的两种情况，我们可以得知，<strong>超时重传时间 RTO 的值应该略大于报文往返 RTT 的值</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/8.jpg" alt="RTO 应略大于 RTT">RTO 应略大于 RTT</p>
<p>至此，可能大家觉得超时重传时间 <code>RTO</code> 的值计算，也不是很复杂嘛。</p>
<p>好像就是在发送端发包时记下 <code>t0</code> ，然后接收端再把这个 <code>ack</code> 回来时再记一个 <code>t1</code>，于是 <code>RTT = t1 – t0</code>。没那么简单，<strong>这只是一个采样，不能代表普遍情况</strong>。</p>
<p>实际上「报文往返 RTT 的值」是经常变化的，因为我们的网络也是时常变化的。也就因为「报文往返 RTT 的值」 是经常波动变化的，所以「超时重传时间 RTO 的值」应该是一个<strong>动态变化的值</strong>。</p>
<p>我们来看看 Linux 是如何计算 <code>RTO</code> 的呢？</p>
<p>估计往返时间，通常需要采样以下两个：</p>
<ul>
<li>需要 TCP 通过采样 RTT 的时间，然后进行加权平均，算出一个平滑 RTT 的值，而且这个值还是要不断变化的，因为网络状况不断地变化。</li>
<li>除了采样 RTT，还要采样 RTT 的波动范围，这样就避免如果 RTT 有一个大的波动的话，很难被发现的情况。</li>
</ul>
<p>RFC6289 建议使用以下的公式计算 RTO：</p>
<p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/9.jpg" alt="RFC6289 建议的 RTO 计算 ">RFC6289 建议的 RTO 计算</p>
<p>其中 <code>SRTT</code> 是计算平滑的RTT ，<code>DevRTR</code> 是计算平滑的RTT 与 最新 RTT 的差距。</p>
<p>在 Linux 下，<strong>α = 0.125，β = 0.25， μ = 1，∂ = 4</strong>。别问怎么来的，问就是大量实验中调出来的。</p>
<p>如果超时重发的数据，再次超时的时候，又需要重传的时候，TCP 的策略是<strong>超时间隔加倍。</strong></p>
<p>也就是<strong>每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送。</strong></p>
<p>超时触发重传存在的问题是，超时周期可能相对较长。那是不是可以有更快的方式呢？</p>
<p>于是就可以用「快速重传」机制来解决超时重发的时间等待。</p>
<h4 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h4><p>TCP 还有另外一种<strong>快速重传（Fast Retransmit）机制</strong>，它<strong>不以时间为驱动，而是以数据驱动重传</strong>。</p>
<p>快速重传机制，是如何工作的呢？其实很简单，一图胜千言。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/10.jpg" alt="快速重传机制">快速重传机制</p>
<p>在上图，发送方发出了 1，2，3，4，5 份数据：</p>
<ul>
<li>第一份 Seq1 先送到了，于是就 Ack 回 2；</li>
<li>结果 Seq2 因为某些原因没收到，Seq3 到达了，于是还是 Ack 回 2；</li>
<li>后面的 Seq4 和 Seq5 都到了，但还是 Ack 回 2，因为 Seq2 还是没有收到；</li>
<li><strong>发送端收到了三个 Ack = 2 的确认，知道了 Seq2 还没有收到，就会在定时器过期之前，重传丢失的 Seq2。</strong></li>
<li>最后，收到了 Seq2，此时因为 Seq3，Seq4，Seq5 都收到了，于是 Ack 回 6 。</li>
</ul>
<p>所以，快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。</p>
<p>快速重传机制只解决了一个问题，就是超时时间的问题，但是它依然面临着另外一个问题。就是<strong>重传的时候，是重传之前的一个，还是重传所有的问题。</strong></p>
<p>比如对于上面的例子，是重传 Seq2 呢？还是重传 Seq2、Seq3、Seq4、Seq5 呢？因为发送端并不清楚这连续的三个 Ack 2 是谁传回来的。</p>
<p>根据 TCP 不同的实现，以上两种情况都是有可能的。可见，这是一把双刃剑。</p>
<p>为了解决不知道该重传哪些 TCP 报文，于是就有 <code>SACK</code> 方法。</p>
<h4 id="SACK-方法"><a href="#SACK-方法" class="headerlink" title="SACK 方法"></a>SACK 方法</h4><p>还有一种实现重传机制的方式叫：<code>SACK</code>（ Selective Acknowledgment 选择性确认）。</p>
<p>这种方式需要在 TCP 头部「选项」字段里加一个 <code>SACK</code> 的东西，它<strong>可以将缓存的地图发送给发送方</strong>，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以<strong>只重传丢失的数据</strong>。</p>
<p>如下图，发送方收到了三次同样的 ACK 确认报文，于是就会触发快速重发机制，通过 <code>SACK</code> 信息发现只有 <code>200~299</code> 这段数据丢失，则重发时，就只选择了这个 TCP 段进行重复。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/11.jpg" alt="选择性确认">选择性确认</p>
<p>如果要支持 <code>SACK</code>，必须双方都要支持。在 Linux 下，可以通过 <code>net.ipv4.tcp_sack</code> 参数打开这个功能（Linux 2.4 后默认打开）。</p>
<h4 id="Duplicate-SACK"><a href="#Duplicate-SACK" class="headerlink" title="Duplicate SACK"></a>Duplicate SACK</h4><p>Duplicate SACK 又称 <code>D-SACK</code>，其主要<strong>使用了 SACK 来告诉「发送方」有哪些数据被重复接收了。</strong></p>
<p>下面举例两个栗子，来说明 <code>D-SACK</code> 的作用。</p>
<p><em>栗子一号：ACK 丢包</em></p>
<p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/12.jpg" alt="ACK 丢包">ACK 丢包</p>
<ul>
<li>「接收方」发给「发送方」的两个 ACK 确认应答都丢失了，所以发送方超时后，重传第一个数据包（3000 ~ 3499）</li>
<li><strong>于是「接收方」发现数据是重复收到的，于是回了一个 SACK = 3000~3500</strong>，告诉「发送方」 3000~3500 的数据早已被接收了，因为 ACK 都到了 4000 了，已经意味着 4000 之前的所有数据都已收到，所以这个 SACK 就代表着 <code>D-SACK</code>。</li>
<li>这样「发送方」就知道了，数据没有丢，是「接收方」的 ACK 确认报文丢了。</li>
</ul>
<p><em>栗子二号：网络延时</em></p>
<p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/13.jpg" alt="网络延时">网络延时</p>
<ul>
<li>数据包（1000~1499） 被网络延迟了，导致「发送方」没有收到 Ack 1500 的确认报文。</li>
<li>而后面报文到达的三个相同的 ACK 确认报文，就触发了快速重传机制，但是在重传后，被延迟的数据包（1000~1499）又到了「接收方」；</li>
<li><strong>所以「接收方」回了一个 SACK=1000~1500，因为 ACK 已经到了 3000，所以这个 SACK 是 D-SACK，表示收到了重复的包。</strong></li>
<li>这样发送方就知道快速重传触发的原因不是发出去的包丢了，也不是因为回应的 ACK 包丢了，而是因为网络延迟了。</li>
</ul>
<p>可见，<code>D-SACK</code> 有这么几个好处：</p>
<ol>
<li>可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了;</li>
<li>可以知道是不是「发送方」的数据包被网络延迟了;</li>
<li>可以知道网络中是不是把「发送方」的数据包给复制了;</li>
</ol>
<p>在 Linux 下可以通过 <code>net.ipv4.tcp_dsack</code> 参数开启/关闭这个功能（Linux 2.4 后默认打开）。</p>
<hr>
<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><blockquote>
<p>引入窗口概念的原因</p>
</blockquote>
<p>我们都知道 TCP 是每发送一个数据，都要进行一次确认应答。当上一个数据包收到了应答了， 再发送下一个。</p>
<p>这个模式就有点像我和你面对面聊天，你一句我一句。但这种方式的缺点是效率比较低的。</p>
<p>如果你说完一句话，我在处理其他事情，没有及时回复你，那你不是要干等着我做完其他事情后，我回复你，你才能说下一句话，很显然这不现实。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/14.jpg" alt="按数据包进行确认应答">按数据包进行确认应答</p>
<p>所以，这样的传输方式有一个缺点：数据包的<strong>往返时间越长，通信的效率就越低</strong>。</p>
<p>为解决这个问题，TCP 引入了<strong>窗口</strong>这个概念。即使在往返时间较长的情况下，它也不会降低网络通信的效率。</p>
<p>那么有了窗口，就可以指定窗口大小，窗口大小就是指<strong>无需等待确认应答，而可以继续发送数据的最大值</strong>。</p>
<p>窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。</p>
<p>假设窗口大小为 <code>3</code> 个 TCP 段，那么发送方就可以「连续发送」 <code>3</code> 个 TCP 段，并且中途若有 ACK 丢失，可以通过「下一个确认应答进行确认」。如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/15.jpg" alt="用滑动窗口方式并行处理">用滑动窗口方式并行处理</p>
<p>图中的 ACK 600 确认应答报文丢失，也没关系，因为可以通过下一个确认应答进行确认，只要发送方收到了 ACK 700 确认应答，就意味着 700 之前的所有数据「接收方」都收到了。这个模式就叫<strong>累计确认</strong>或者<strong>累计应答</strong>。</p>
<blockquote>
<p>窗口大小由哪一方决定？</p>
</blockquote>
<p>TCP 头里有一个字段叫 <code>Window</code>，也就是窗口大小。</p>
<p><strong>这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。</strong></p>
<p>所以，通常窗口的大小是由接收方的窗口大小来决定的。</p>
<p>发送方发送的数据大小不能超过接收方的窗口大小，否则接收方就无法正常接收到数据。</p>
<blockquote>
<p>发送方的滑动窗口</p>
</blockquote>
<p>我们先来看看发送方的窗口，下图就是发送方缓存的数据，根据处理的情况分成四个部分，其中深蓝色方框是发送窗口，紫色方框是可用窗口：</p>
<p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/16.jpg" alt="img"></p>
<ul>
<li>#1 是已发送并收到 ACK确认的数据：1~31 字节</li>
<li>#2 是已发送但未收到 ACK确认的数据：32~45 字节</li>
<li>#3 是未发送但总大小在接收方处理范围内（接收方还有空间）：46~51字节</li>
<li>#4 是未发送但总大小超过接收方处理范围（接收方没有空间）：52字节以后</li>
</ul>
<p>在下图，当发送方把数据「全部」都一下发送出去后，可用窗口的大小就为 0 了，表明可用窗口耗尽，在没收到 ACK 确认之前是无法继续发送数据了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/17.jpg" alt="可用窗口耗尽">可用窗口耗尽</p>
<p>在下图，当收到之前发送的数据 <code>32~36</code> 字节的 ACK 确认应答后，如果发送窗口的大小没有变化，则<strong>滑动窗口往右边移动 5 个字节，因为有 5 个字节的数据被应答确认</strong>，接下来 <code>52~56</code> 字节又变成了可用窗口，那么后续也就可以发送 <code>52~56</code> 这 5 个字节的数据了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/18.jpg" alt="32 ~ 36 字节已确认">32 ~ 36 字节已确认</p>
<blockquote>
<p>程序是如何表示发送方的四个部分的呢？</p>
</blockquote>
<p>TCP 滑动窗口方案使用三个指针来跟踪在四个传输类别中的每一个类别中的字节。其中两个指针是绝对指针（指特定的序列号），一个是相对指针（需要做偏移）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/19.jpg" alt="SND.WND、SND.UN、SND.NXT">SND.WND、SND.UN、SND.NXT</p>
<ul>
<li><code>SND.WND</code>：表示发送窗口的大小（大小是由接收方指定的）；</li>
<li><code>SND.UNA</code>：是一个绝对指针，它指向的是已发送但未收到确认的第一个字节的序列号，也就是 #2 的第一个字节。</li>
<li><code>SND.NXT</code>：也是一个绝对指针，它指向未发送但可发送范围的第一个字节的序列号，也就是 #3 的第一个字节。</li>
<li>指向 #4 的第一个字节是个相对指针，它需要 <code>SND.UNA</code> 指针加上 <code>SND.WND</code> 大小的偏移量，就可以指向 #4 的第一个字节了。</li>
</ul>
<p>那么可用窗口大小的计算就可以是：</p>
<p><strong>可用窗口大 = SND.WND -（SND.NXT - SND.UNA）</strong></p>
<blockquote>
<p>接收方的滑动窗口</p>
</blockquote>
<p>接下来我们看看接收方的窗口，接收窗口相对简单一些，根据处理的情况划分成三个部分：</p>
<ul>
<li>#1 + #2 是已成功接收并确认的数据（等待应用进程读取）；</li>
<li>#3 是未收到数据但可以接收的数据；</li>
<li>#4 未收到数据并不可以接收的数据；</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/20.jpg" alt="接收窗口">接收窗口</p>
<p>其中三个接收部分，使用两个指针进行划分:</p>
<ul>
<li><code>RCV.WND</code>：表示接收窗口的大小，它会通告给发送方。</li>
<li><code>RCV.NXT</code>：是一个指针，它指向期望从发送方发送来的下一个数据字节的序列号，也就是 #3 的第一个字节。</li>
<li>指向 #4 的第一个字节是个相对指针，它需要 <code>RCV.NXT</code> 指针加上 <code>RCV.WND</code> 大小的偏移量，就可以指向 #4 的第一个字节了。</li>
</ul>
<blockquote>
<p>接收窗口和发送窗口的大小是相等的吗？</p>
</blockquote>
<p>并不是完全相等，接收窗口的大小是<strong>约等于</strong>发送窗口的大小的。</p>
<p>因为滑动窗口并不是一成不变的。比如，当接收方的应用进程读取数据的速度非常快的话，这样的话接收窗口可以很快的就空缺出来。那么新的接收窗口大小，是通过 TCP 报文中的 Windows 字段来告诉发送方。那么这个传输过程是存在时延的，所以接收窗口和发送窗口是约等于的关系。</p>
<hr>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>发送方不能无脑的发数据给接收方，要考虑接收方处理能力。</p>
<p>如果一直无脑的发数据给对方，但对方处理不过来，那么就会导致触发重发机制，从而导致网络流量的无端的浪费。</p>
<p>为了解决这种现象发生，<strong>TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。</strong></p>
<p>下面举个栗子，为了简单起见，假设以下场景：</p>
<ul>
<li>客户端是接收方，服务端是发送方</li>
<li>假设接收窗口和发送窗口相同，都为 <code>200</code></li>
<li>假设两个设备在整个传输过程中都保持相同的窗口大小，不受外界影响</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/21.jpg" alt="流量控制">流量控制</p>
<p>根据上图的流量控制，说明下每个过程：</p>
<ol>
<li>客户端向服务端发送请求数据报文。这里要说明下，本次例子是把服务端作为发送方，所以没有画出服务端的接收窗口。</li>
<li>服务端收到请求报文后，发送确认报文和 80 字节的数据，于是可用窗口 <code>Usable</code> 减少为 120 字节，同时 <code>SND.NXT</code> 指针也向右偏移 80 字节后，指向 321，<strong>这意味着下次发送数据的时候，序列号是 321。</strong></li>
<li>客户端收到 80 字节数据后，于是接收窗口往右移动 80 字节，<code>RCV.NXT</code> 也就指向 321，<strong>这意味着客户端期望的下一个报文的序列号是 321</strong>，接着发送确认报文给服务端。</li>
<li>服务端再次发送了 120 字节数据，于是可用窗口耗尽为 0，服务端无法再继续发送数据。</li>
<li>客户端收到 120 字节的数据后，于是接收窗口往右移动 120 字节，<code>RCV.NXT</code> 也就指向 441，接着发送确认报文给服务端。</li>
<li>服务端收到对 80 字节数据的确认报文后，<code>SND.UNA</code> 指针往右偏移后指向 321，于是可用窗口 <code>Usable</code> 增大到 80。</li>
<li>服务端收到对 120 字节数据的确认报文后，<code>SND.UNA</code> 指针往右偏移后指向 441，于是可用窗口 <code>Usable</code> 增大到 200。</li>
<li>服务端可以继续发送了，于是发送了 160 字节的数据后，<code>SND.NXT</code> 指向 601，于是可用窗口 <code>Usable</code> 减少到 40。</li>
<li>客户端收到 160 字节后，接收窗口往右移动了 160 字节，<code>RCV.NXT</code> 也就是指向了 601，接着发送确认报文给服务端。</li>
<li>服务端收到对 160 字节数据的确认报文后，发送窗口往右移动了 160 字节，于是 <code>SND.UNA</code> 指针偏移了 160 后指向 601，可用窗口 <code>Usable</code> 也就增大至了 200。</li>
</ol>
<h4 id="操作系统缓冲区与滑动窗口的关系"><a href="#操作系统缓冲区与滑动窗口的关系" class="headerlink" title="操作系统缓冲区与滑动窗口的关系"></a>操作系统缓冲区与滑动窗口的关系</h4><p>前面的流量控制例子，我们假定了发送窗口和接收窗口是不变的，但是实际上，发送窗口和接收窗口中所存放的字节数，都是放在操作系统内存缓冲区中的，而操作系统的缓冲区，会<strong>被操作系统调整</strong>。</p>
<p>当应用进程没办法及时读取缓冲区的内容时，也会对我们的缓冲区造成影响。</p>
<blockquote>
<p>那操心系统的缓冲区，是如何影响发送窗口和接收窗口的呢？</p>
</blockquote>
<p><em>我们先来看看第一个例子。</em></p>
<p>当应用程序没有及时读取缓存时，发送窗口和接收窗口的变化。</p>
<p>考虑以下场景：</p>
<ul>
<li>客户端作为发送方，服务端作为接收方，发送窗口和接收窗口初始大小为 <code>360</code>；</li>
<li>服务端非常的繁忙，当收到客户端的数据时，应用层不能及时读取数据。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/22.jpg" alt="img"></p>
<p>根据上图的流量控制，说明下每个过程：</p>
<ol>
<li>客户端发送 140 字节数据后，可用窗口变为 220 （360 - 140）。</li>
<li>服务端收到 140 字节数据，<strong>但是服务端非常繁忙，应用进程只读取了 40 个字节，还有 100 字节占用着缓冲区，于是接收窗口收缩到了 260 （360 - 100）</strong>，最后发送确认信息时，将窗口大小通告给客户端。</li>
<li>客户端收到确认和窗口通告报文后，发送窗口减少为 260。</li>
<li>客户端发送 180 字节数据，此时可用窗口减少到 80。</li>
<li>服务端收到 180 字节数据，<strong>但是应用程序没有读取任何数据，这 180 字节直接就留在了缓冲区，于是接收窗口收缩到了 80 （260 - 180）</strong>，并在发送确认信息时，通过窗口大小给客户端。</li>
<li>客户端收到确认和窗口通告报文后，发送窗口减少为 80。</li>
<li>客户端发送 80 字节数据后，可用窗口耗尽。</li>
<li>服务端收到 80 字节数据，<strong>但是应用程序依然没有读取任何数据，这 80 字节留在了缓冲区，于是接收窗口收缩到了 0</strong>，并在发送确认信息时，通过窗口大小给客户端。</li>
<li>客户端收到确认和窗口通告报文后，发送窗口减少为 0。</li>
</ol>
<p>可见最后窗口都收缩为 0 了，也就是发生了窗口关闭。当发送方可用窗口变为 0 时，发送方实际上会定时发送窗口探测报文，以便知道接收方的窗口是否发生了改变，这个内容后面会说，这里先简单提一下。</p>
<p><em>我们先来看看第二个例子。</em></p>
<p>当服务端系统资源非常紧张的时候，操心系统可能会直接减少了接收缓冲区大小，这时应用程序又无法及时读取缓存数据，那么这时候就有严重的事情发生了，会出现数据包丢失的现象。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/23.jpg" alt="img"></p>
<p>说明下每个过程：</p>
<ol>
<li>客户端发送 140 字节的数据，于是可用窗口减少到了 220。</li>
<li><strong>服务端因为现在非常的繁忙，操作系统于是就把接收缓存减少了 120 字节，当收到 140 字节数据后，又因为应用程序没有读取任何数据，所以 140 字节留在了缓冲区中，于是接收窗口大小从 360 收缩成了 100</strong>，最后发送确认信息时，通告窗口大小给对方。</li>
<li>此时客户端因为还没有收到服务端的通告窗口报文，所以不知道此时接收窗口收缩成了 100，客户端只会看自己的可用窗口还有 220，所以客户端就发送了 180 字节数据，于是可用窗口减少到 40。</li>
<li>服务端收到了 180 字节数据时，<strong>发现数据大小超过了接收窗口的大小，于是就把数据包丢失了。</strong></li>
<li>客户端收到第 2 步时，服务端发送的确认报文和通告窗口报文，尝试减少发送窗口到 100，把窗口的右端向左收缩了 80，此时可用窗口的大小就会出现诡异的负值。</li>
</ol>
<p>所以，如果发生了先减少缓存，再收缩窗口，就会出现丢包的现象。</p>
<p><strong>为了防止这种情况发生，TCP 规定是不允许同时减少缓存又收缩窗口的，而是采用先收缩窗口，过段时间再减少缓存，这样就可以避免了丢包情况。</strong></p>
<h4 id="窗口关闭"><a href="#窗口关闭" class="headerlink" title="窗口关闭"></a>窗口关闭</h4><p>在前面我们都看到了，TCP 通过让接收方指明希望从发送方接收的数据大小（窗口大小）来进行流量控制。</p>
<p><strong>如果窗口大小为 0 时，就会阻止发送方给接收方传递数据，直到窗口变为非 0 为止，这就是窗口关闭。</strong></p>
<blockquote>
<p>窗口关闭潜在的危险</p>
</blockquote>
<p>接收方向发送方通告窗口大小时，是通过 <code>ACK</code> 报文来通告的。</p>
<p>那么，当发生窗口关闭时，接收方处理完数据后，会向发送方通告一个窗口非 0 的 ACK 报文，如果这个通告窗口的 ACK 报文在网络中丢失了，那麻烦就大了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/24.jpg" alt="窗口关闭潜在的危险">窗口关闭潜在的危险</p>
<p>这会导致发送方一直等待接收方的非 0 窗口通知，接收方也一直等待发送方的数据，如不采取措施，这种相互等待的过程，会造成了死锁的现象。</p>
<blockquote>
<p>TCP 是如何解决窗口关闭时，潜在的死锁现象呢？</p>
</blockquote>
<p>为了解决这个问题，TCP 为每个连接设有一个持续定时器，<strong>只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。</strong></p>
<p>如果持续计时器超时，就会发送<strong>窗口探测 ( Window probe ) 报文</strong>，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/25.jpg" alt="窗口探测">窗口探测</p>
<ul>
<li>如果接收窗口仍然为 0，那么收到这个报文的一方就会重新启动持续计时器；</li>
<li>如果接收窗口不是 0，那么死锁的局面就可以被打破了。</li>
</ul>
<p>窗口探测的次数一般为 3 次，每次大约 30-60 秒（不同的实现可能会不一样）。如果 3 次过后接收窗口还是 0 的话，有的 TCP 实现就会发 <code>RST</code> 报文来中断连接。</p>
<h4 id="糊涂窗口综合症"><a href="#糊涂窗口综合症" class="headerlink" title="糊涂窗口综合症"></a>糊涂窗口综合症</h4><p>如果接收方太忙了，来不及取走接收窗口里的数据，那么就会导致发送方的发送窗口越来越小。</p>
<p>到最后，<strong>如果接收方腾出几个字节并告诉发送方现在有几个字节的窗口，而发送方会义无反顾地发送这几个字节，这就是糊涂窗口综合症</strong>。</p>
<p>要知道，我们的 <code>TCP + IP</code> 头有 <code>40</code> 个字节，为了传输那几个字节的数据，要达上这么大的开销，这太不经济了。</p>
<p>就好像一个可以承载 50 人的大巴车，每次来了一两个人，就直接发车。除非家里有矿的大巴司机，才敢这样玩，不然迟早破产。要解决这个问题也不难，大巴司机等乘客数量超过了 25 个，才认定可以发车。</p>
<p>现举个糊涂窗口综合症的栗子，考虑以下场景：</p>
<p>接收方的窗口大小是 360 字节，但接收方由于某些原因陷入困境，假设接收方的应用层读取的能力如下：</p>
<ul>
<li>接收方每接收 3 个字节，应用程序就只能从缓冲区中读取 1 个字节的数据；</li>
<li>在下一个发送方的 TCP 段到达之前，应用程序还从缓冲区中读取了 40 个额外的字节；</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/26.png" alt="糊涂窗口综合症">糊涂窗口综合症</p>
<p>每个过程的窗口大小的变化，在图中都描述的很清楚了，可以发现窗口不断减少了，并且发送的数据都是比较小的了。</p>
<p>所以，糊涂窗口综合症的现象是可以发生在发送方和接收方：</p>
<ul>
<li>接收方可以通告一个小的窗口</li>
<li>而发送方可以发送小数据</li>
</ul>
<p>于是，要解决糊涂窗口综合症，就解决上面两个问题就可以了</p>
<ul>
<li>让接收方不通告小窗口给发送方</li>
<li>让发送方避免发送小数据</li>
</ul>
<blockquote>
<p>怎么让接收方不通告小窗口呢？</p>
</blockquote>
<p>接收方通常的策略如下:</p>
<p>当「窗口大小」小于 min( MSS，缓存空间/2 ) ，也就是小于 MSS 与 1/2 缓存大小中的最小值时，就会向发送方通告窗口为 <code>0</code>，也就阻止了发送方再发数据过来。</p>
<p>等到接收方处理了一些数据后，窗口大小 &gt;= MSS，或者接收方缓存空间有一半可以使用，就可以把窗口打开让发送方发送数据过来。</p>
<blockquote>
<p>怎么让发送方避免发送小数据呢？</p>
</blockquote>
<p>发送方通常的策略:</p>
<p>使用 Nagle 算法，该算法的思路是延时处理，它满足以下两个条件中的一条才可以发送数据：</p>
<ul>
<li>要等到窗口大小 &gt;= <code>MSS</code> 或是 数据大小 &gt;= <code>MSS</code></li>
<li>收到之前发送数据的 <code>ack</code> 回包</li>
</ul>
<p>只要没满足上面条件中的一条，发送方一直在囤积数据，直到满足上面的发送条件。</p>
<p>另外，Nagle 算法默认是打开的，如果对于一些需要小数据包交互的场景的程序，比如，telnet 或 ssh 这样的交互性比较强的程序，则需要关闭 Nagle 算法。</p>
<p>可以在 Socket 设置 <code>TCP_NODELAY</code> 选项来关闭这个算法（关闭 Nagle 算法没有全局参数，需要根据每个应用自己的特点来关闭）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setsockopt(sock_fd, IPPROTO_TCP, TCP_NODELAY, (<span class="keyword">char</span> *)&amp;value, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><blockquote>
<p>为什么要有拥塞控制呀，不是有流量控制了吗？</p>
</blockquote>
<p>前面的流量控制是避免「发送方」的数据填满「接收方」的缓存，但是并不知道网络的中发生了什么。</p>
<p>一般来说，计算机网络都处在一个共享的环境。因此也有可能会因为其他主机之间的通信使得网络拥堵。</p>
<p><strong>在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大….</strong></p>
<p>所以，TCP 不能忽略网络上发生的事，它被设计成一个无私的协议，当网络发送拥塞时，TCP 会自我牺牲，降低发送的数据量。</p>
<p>于是，就有了<strong>拥塞控制</strong>，控制的目的就是<strong>避免「发送方」的数据填满整个网络。</strong></p>
<p>为了在「发送方」调节所要发送数据的量，定义了一个叫做「<strong>拥塞窗口</strong>」的概念。</p>
<blockquote>
<p>什么是拥塞窗口？和发送窗口有什么关系呢？</p>
</blockquote>
<p><strong>拥塞窗口 cwnd</strong>是发送方维护的一个的状态变量，它会根据<strong>网络的拥塞程度动态变化的</strong>。</p>
<p>我们在前面提到过发送窗口 <code>swnd</code> 和接收窗口 <code>rwnd</code> 是约等于的关系，那么由于加入了拥塞窗口的概念后，此时发送窗口的值是swnd = min(cwnd, rwnd)，也就是拥塞窗口和接收窗口中的最小值。</p>
<p>拥塞窗口 <code>cwnd</code> 变化的规则：</p>
<ul>
<li>只要网络中没有出现拥塞，<code>cwnd</code> 就会增大；</li>
<li>但网络中出现了拥塞，<code>cwnd</code> 就减少；</li>
</ul>
<blockquote>
<p>那么怎么知道当前网络是否出现了拥塞呢？</p>
</blockquote>
<p>其实只要「发送方」没有在规定时间内接收到 ACK 应答报文，也就是<strong>发生了超时重传，就会认为网络出现了用拥塞。</strong></p>
<blockquote>
<p>拥塞控制有哪些控制算法？</p>
</blockquote>
<p>拥塞控制主要是四个算法：</p>
<ul>
<li>慢启动</li>
<li>拥塞避免</li>
<li>拥塞发生</li>
<li>快速恢复</li>
</ul>
<h4 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h4><p>TCP 在刚建立连接完成后，首先是有个慢启动的过程，这个慢启动的意思就是一点一点的提高发送数据包的数量，如果一上来就发大量的数据，这不是给网络添堵吗？</p>
<p>慢启动的算法记住一个规则就行：<strong>当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1。</strong></p>
<p>这里假定拥塞窗口 <code>cwnd</code> 和发送窗口 <code>swnd</code> 相等，下面举个栗子：</p>
<ul>
<li>连接建立完成后，一开始初始化 <code>cwnd = 1</code>，表示可以传一个 <code>MSS</code> 大小的数据。</li>
<li>当收到一个 ACK 确认应答后，cwnd 增加 1，于是一次能够发送 2 个</li>
<li>当收到 2 个的 ACK 确认应答后， cwnd 增加 2，于是就可以比之前多发2 个，所以这一次能够发送 4 个</li>
<li>当这 4 个的 ACK 确认到来的时候，每个确认 cwnd 增加 1， 4 个确认 cwnd 增加 4，于是就可以比之前多发 4 个，所以这一次能够发送 8 个。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/27.jpg" alt="慢启动算法">慢启动算法</p>
<p>可以看出慢启动算法，发包的个数是<strong>指数性的增长</strong>。</p>
<blockquote>
<p>那慢启动涨到什么时候是个头呢？</p>
</blockquote>
<p>有一个叫慢启动门限 <code>ssthresh</code> （slow start threshold）状态变量。</p>
<ul>
<li>当 <code>cwnd</code> &lt; <code>ssthresh</code> 时，使用慢启动算法。</li>
<li>当 <code>cwnd</code> &gt;= <code>ssthresh</code> 时，就会使用「拥塞避免算法」。</li>
</ul>
<h4 id="拥塞避免算法"><a href="#拥塞避免算法" class="headerlink" title="拥塞避免算法"></a>拥塞避免算法</h4><p>前面说道，当拥塞窗口 <code>cwnd</code> 「超过」慢启动门限 <code>ssthresh</code> 就会进入拥塞避免算法。</p>
<p>一般来说 <code>ssthresh</code> 的大小是 <code>65535</code> 字节。</p>
<p>那么进入拥塞避免算法后，它的规则是：<strong>每当收到一个 ACK 时，cwnd 增加 1/cwnd。</strong></p>
<p>接上前面的慢启动的栗子，现假定 <code>ssthresh</code> 为 <code>8</code>：</p>
<ul>
<li>当 8 个 ACK 应答确认到来时，每个确认增加 1/8，8 个 ACK 确认 cwnd 一共增加 1，于是这一次能够发送 9 个 <code>MSS</code> 大小的数据，变成了<strong>线性增长。</strong></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/28.jpg" alt="拥塞避免">拥塞避免</p>
<p>所以，我们可以发现，拥塞避免算法就是将原本慢启动算法的指数增长变成了线性增长，还是增长阶段，但是增长速度缓慢了一些。</p>
<p>就这么一直增长着后，网络就会慢慢进入了拥塞的状况了，于是就会出现丢包现象，这时就需要对丢失的数据包进行重传。</p>
<p>当触发了重传机制，也就进入了「拥塞发生算法」。</p>
<h4 id="拥塞发生"><a href="#拥塞发生" class="headerlink" title="拥塞发生"></a>拥塞发生</h4><p>当网络出现拥塞，也就是会发生数据包重传，重传机制主要有两种：</p>
<ul>
<li>超时重传</li>
<li>快速重传</li>
</ul>
<p>这两种使用的拥塞发送算法是不同的，接下来分别来说说。</p>
<blockquote>
<p>发生超时重传的拥塞发生算法</p>
</blockquote>
<p>当发生了「超时重传」，则就会使用拥塞发生算法。</p>
<p>这个时候，ssthresh 和 cwnd 的值会发生变化：</p>
<ul>
<li><code>ssthresh</code> 设为 <code>cwnd/2</code>，</li>
<li><code>cwnd</code> 重置为 <code>1</code></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/29.jpg" alt="拥塞发送 —— 超时重传">拥塞发送 —— 超时重传</p>
<p>接着，就重新开始慢启动，慢启动是会突然减少数据流的。这真是一旦「超时重传」，马上回到解放前。但是这种方式太激进了，反应也很强烈，会造成网络卡顿。</p>
<p>就好像本来在秋名山高速漂移着，突然来个紧急刹车，轮胎受得了吗。。。</p>
<blockquote>
<p>发生快速重传的拥塞发生算法</p>
</blockquote>
<p>还有更好的方式，前面我们讲过「快速重传算法」。当接收方发现丢了一个中间包的时候，发送三次前一个包的 ACK，于是发送端就会快速地重传，不必等待超时再重传。</p>
<p>TCP 认为这种情况不严重，因为大部分没丢，只丢了一小部分，则 <code>ssthresh</code> 和 <code>cwnd</code> 变化如下：</p>
<ul>
<li><code>cwnd = cwnd/2</code> ，也就是设置为原来的一半;</li>
<li><code>ssthresh = cwnd</code>;</li>
<li>进入快速恢复算法</li>
</ul>
<h4 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h4><p>快速重传和快速恢复算法一般同时使用，快速恢复算法是认为，你还能收到 3 个重复 ACK 说明网络也不那么糟糕，所以没有必要像 <code>RTO</code> 超时那么强烈。</p>
<p>正如前面所说，进入快速恢复之前，<code>cwnd</code> 和 <code>ssthresh</code> 已被更新了：</p>
<ul>
<li><code>cwnd = cwnd/2</code> ，也就是设置为原来的一半;</li>
<li><code>ssthresh = cwnd</code>;</li>
</ul>
<p>然后，进入快速恢复算法如下：</p>
<ul>
<li>拥塞窗口 <code>cwnd = ssthresh + 3</code> （ 3 的意思是确认有 3 个数据包被收到了）；</li>
<li>重传丢失的数据包；</li>
<li>如果再收到重复的 ACK，那么 cwnd 增加 1；</li>
<li>如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/30.jpg" alt="快速重传和快速恢复">快速重传和快速恢复</p>
<p>也就是没有像「超时重传」一夜回到解放前，而是还在比较高的值，后续呈线性增长。</p>
<h4 id="拥塞算法示意图"><a href="#拥塞算法示意图" class="headerlink" title="拥塞算法示意图"></a>拥塞算法示意图</h4><p>好了，以上就是拥塞控制的全部内容了，看完后，你再来看下面这张图片，每个过程我相信你都能明白：</p>
<p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/31.png" alt="TCP 拥塞控制">TCP 拥塞控制</p>
<h2 id="tcp保证数据传输的三个流程"><a href="#tcp保证数据传输的三个流程" class="headerlink" title="tcp保证数据传输的三个流程"></a>tcp保证数据传输的三个流程</h2><p>TCP为了提供可靠传输：<br>（1）首先，采用三次握手来建立TCP连接，四次握手来释放TCP连接，从而保证建立的传输信道是可靠的。<br>（2）其次，TCP 采用了连续ARQ协议（回退N，Go-back-N；超时自动重传）(自动重传请求（Automatic Repeat-reQuest，ARQ）)来保证数据传输的正确性，使用滑动窗口协议来保证接方能够及时处理所接收到的数据，进行流量控制。<br>（3）最后，TCP 使用慢开始、拥塞避免、快重传和快恢复来进行拥塞控制，避免网络拥塞。</p>
<h2 id="tcp-三次握手"><a href="#tcp-三次握手" class="headerlink" title="tcp 三次握手"></a>tcp 三次握手</h2><p>在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。<br>第一次握手： 建立连接时，客户端发送 syn 包 (syn=j) 到服务器，并进入 SYN_SEND 状态，等待服务器确认；<br>第二次握手： 服务器收到 syn 包，必须确认客户的 SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；<br>第三次握手： 客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。 完成三次握手，客户端与服务器开始传送数据.</p>
<p>三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送 3 个包</p>
<p>主要作用就是为了<strong>确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号</strong>为后面的可靠性传送做准备</p>
<p>过程如下：</p>
<ul>
<li>第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)，此时客户端处于 SYN_SENT 状态</li>
<li>第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，为了确认客户端的 SYN，将客户端的 ISN+1作为ACK的值，此时服务器处于 SYN_RCVD 的状态</li>
<li>第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，值为服务器的 ISN+1。此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/df92e0deefb619759aa435aca99720cf4113a5ba705eb09f1636f91c89d3eb1e/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f66623438396663302d626562392d313165622d383566362d3666616337376330633962332e706e67"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gw0vu3wk8qj30fd0aemxk.jpg" alt="img"></a></p>
<p>上述每一次握手的作用如下：</p>
<ul>
<li>第一次握手：客户端发送网络包，服务端收到了<br>  这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</li>
<li>第二次握手：服务端发包，客户端收到了</li>
<li>这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时<strong>服务器并不能确认客户端的接收能力</strong>是否正常</li>
<li>第三次握手：客户端发包，服务端收到了<br>  这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常</li>
</ul>
<p>通过三次握手，就能确定双方的接收和发送能力是正常的。之后就可以正常通信了</p>
<h2 id="为什么三次握手"><a href="#为什么三次握手" class="headerlink" title="为什么三次握手"></a>为什么三次握手</h2><p>第三次握手🤝服务端（接收端）确认自己发的包对方能接收到，如果采用两次握手的话, 客户端有可能因为网络阻塞等原因会发送多个请求报文，延时到达的请求又会与服务器建立连接，浪费掉许多服务器的资源。</p>
<p>如果是两次握手，发送端可以确定自己发送的信息能对方能收到，也能确定对方发的包自己能收到，但接收端只能确定对方发的包自己能收到 <strong>无法确定自己发的包对方能收到</strong>，并且两次握手的话, 客户端有可能因为网络阻塞等原因会发送多个请求报文，延时到达的请求又会与服务器建立连接，浪费掉许多服务器的资源</p>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p><code>tcp</code>终止一个连接，需要经过四次挥手</p>
<p>过程如下：</p>
<ul>
<li>第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态，停止发送数据，等待服务端的确认</li>
<li>第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态</li>
<li>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 <code>LAST_ACK</code> 的状态</li>
<li>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/245cf8925daac2792d36f0f07066826a955175fe6e09030ae0a7ae17d1be9954/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f30613365626239302d626562612d313165622d383566362d3666616337376330633962332e706e67"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gw1z0wr7pkj30vw0gzab8.jpg" alt="img"></a></p>
<table>
<thead>
<tr>
<th>状 态</th>
<th>描 述</th>
</tr>
</thead>
<tbody><tr>
<td>CLOSED</td>
<td>关闭状态，没有连接活动或正在进行</td>
</tr>
<tr>
<td>LISTEN</td>
<td>监听状态，服务器正在等待连接进入</td>
</tr>
<tr>
<td>SYN RCVD</td>
<td>收到一个连接请求，尚未确认</td>
</tr>
<tr>
<td>SYN SENT</td>
<td>已经发出连接请求，等待确认</td>
</tr>
<tr>
<td>ESTABLISHED</td>
<td>连接建立，正常数据传输状态</td>
</tr>
<tr>
<td>FIN WAIT 1</td>
<td>（主动关闭）已经发送关闭请求，等待确认</td>
</tr>
<tr>
<td>FIN WAIT 2</td>
<td>（主动关闭）收到对方关闭确认，等待对方关闭请求</td>
</tr>
<tr>
<td>TIMED WAIT</td>
<td>完成双向关闭，等待所有分组死掉</td>
</tr>
<tr>
<td>CLOSING</td>
<td>双方同时尝试关闭，等待对方确认</td>
</tr>
<tr>
<td>CLOSE WAIT</td>
<td>（被动关闭）收到对方关闭请求，已经确认</td>
</tr>
<tr>
<td>LAST ACK</td>
<td>（被动关闭）等待最后一个关闭确认，并等待所有分组死掉</td>
</tr>
</tbody></table>
<h2 id="四次挥手原因"><a href="#四次挥手原因" class="headerlink" title="四次挥手原因"></a>四次挥手原因</h2><p>服务端在收到客户端断开连接<code>Fin</code>报文后，并不会立即关闭连接，而是先发送一个<code>ACK</code>包先告诉客户端收到关闭连接的请求，只有当<strong>服务器的所有报文发送完毕</strong>之后，才发送<code>FIN</code>报文断开连接，因此需要四次挥手</p>
<p>两个两次连接，双向过程（客户端：发送关闭请求，确认关闭请求； 服务端：发送关闭请求，确认关闭请求）</p>
<ul>
<li>客户端 &lt;–&gt; 服务端 </li>
<li>服务端 &lt;–&gt; 客户端</li>
</ul>
<h2 id="TIME-WAIT"><a href="#TIME-WAIT" class="headerlink" title="TIME-WAIT"></a>TIME-WAIT</h2><ul>
<li>高并发短连接的服务器上会出现这样的情况，导致创建大量的tcp连接然后close，出现大量的连接出现time_wait的状态。</li>
</ul>
<h2 id="CLOSE-WAIT-状态的含义，如果服务端出现过多C-W状态，该如何处理"><a href="#CLOSE-WAIT-状态的含义，如果服务端出现过多C-W状态，该如何处理" class="headerlink" title="CLOSE-WAIT 状态的含义，如果服务端出现过多C-W状态，该如何处理"></a>CLOSE-WAIT 状态的含义，如果服务端出现过多C-W状态，该如何处理</h2><p>TCP 终止连接中第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。</p>
<p>出现 CW 原因：close_wait 是被动关闭连接是形成的，根据 TCP 状态机，服务器端收到客户端发送的 FIN，TCP 协议栈会自动发送 ACK，链接进入 close_wait 状态。但如果服务器端不执行 socke t的 close() 操作（即不向客户端发送FIN），状态就不能由 close_wait 迁移到 last_ack，则系统中会存在很多 close_wait 状态的连接</p>
<h2 id="常见的网络模型"><a href="#常见的网络模型" class="headerlink" title="常见的网络模型"></a>常见的网络模型</h2><p><img src="https://pic1.zhimg.com/80/v2-a9976ebe153157fde548aaa7b8d73e28_1440w.jpg" alt="img"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gw0vhso1xrj30ak07xwf4.jpg" alt="img"></p>
<p>A ： 私有号段：10.0.0.0-10.255.255.255</p>
<p>B：  私有号段：172.16.0.0-172.31.255.255</p>
<p>C：  私有号段：192.168.0.0-192.168.255.255</p>
<h2 id="二、三级转发"><a href="#二、三级转发" class="headerlink" title="二、三级转发"></a>二、三级转发</h2><p>二层：交换机</p>
<p>三层：路由器</p>
<ul>
<li><p>路由器有多个端口，分别连接不同的数据链路。它通过识别目的 IP 地址的<strong>网络号</strong>，再根据<strong>路由表</strong>进行转发，路由表中有<strong>匹配</strong>的路由条目才会转发，无匹配的路由条目则直接丢弃。路由条目既可以手动设置静态路由，也可以通过路由协议自动生成动态路由。</p>
</li>
<li><p>在不考虑代理的情况下，数据包每到一个三层，就把源MAC替换成自己的出接口MAC，目标MAC替换成下一跳MAC，不跨三层不替换。</p>
</li>
</ul>
<h2 id="TCP-UDP"><a href="#TCP-UDP" class="headerlink" title="TCP/UDP"></a>TCP/UDP</h2><ul>
<li><p>UDP 不可靠不稳定 面向非连接</p>
</li>
<li><p>TCP 可靠稳定 面向连接</p>
</li>
</ul>
<p><strong>TCP 应用场景：</strong></p>
<p>当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如 HTTP、HTTPS、FTP 等传输文件的协议，POP、SMTP 等邮件传输的协议。</p>
<p>在日常生活中，常见使用 TCP 协议的应用如下： 浏览器用的 HTTP， FlashFXP 用的 FTP，Outlook 用的 POP、SMTP，Putty 用的 Telnet、SSH，QQ 文件传输。</p>
<p><strong>UDP 应用场景：</strong> </p>
<p>当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用 UDP。 </p>
<p>比如，日常生活中，常见使用 UDP 协议的应用如下：QQ 语音，QQ 视频，TFTP 等。有些应用场景对可靠性要求不高会用到 UPD，比如长视频，要求速率。</p>
<h2 id="浏览器输入URL全过程"><a href="#浏览器输入URL全过程" class="headerlink" title="浏览器输入URL全过程"></a>浏览器输入URL全过程</h2><ol>
<li>DNS域名解析；将域名解析为 IP 地址</li>
<li>建立TCP连接；三次握手</li>
<li>发送HTTP请求；</li>
<li>服务器处理请求；</li>
<li>返回响应结果；</li>
<li>关闭TCP连接；四次挥手</li>
<li>浏览器解析HTML；</li>
<li>浏览器布局渲染；</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.ashin.wang/leetcode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://tva1.sinaimg.cn/large/006y8mN6ly1g74lvmm1zhj3074074q4r.jpg">
      <meta itemprop="name" content="Ashin Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ashin Wang's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/leetcode/" class="post-title-link" itemprop="url">leetcode</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：1978-01-01 00:00:00" itemprop="dateCreated datePublished" datetime="1978-01-01T00:00:00+08:00">1978-01-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">leetcode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h1><ul>
<li>刷题目录 ❤️：<a target="_blank" rel="noopener" href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/Leetcode%20%E9%A2%98%E8%A7%A3/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E7%9B%AE%E5%BD%95.html">CYC2018  Leetcode 题解</a></li>
<li>刷题模板：<a target="_blank" rel="noopener" href="https://ojeveryday.github.io/AlgoWiki/#/?id=algowiki">AlgoWiki</a></li>
<li>刷题套路1：<a target="_blank" rel="noopener" href="https://labuladong.gitbook.io/algo/">📖labuladong 的算法小抄</a></li>
<li>刷题套路2：<a target="_blank" rel="noopener" href="https://programmercarl.com/">代码随想录</a></li>
<li>排序算法：<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/itsharehome/p/11058010.html">十大经典排序算法@冰狼爱魔</a></li>
<li><a target="_blank" rel="noopener" href="https://sort.hust.cc/">十大经典排序算法@https://sort.hust.cc</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sort-an-array/solution/python-shi-xian-de-shi-da-jing-dian-pai-xu-suan-fa/">https://leetcode-cn.com/problems/sort-an-array/solution/python-shi-xian-de-shi-da-jing-dian-pai-xu-suan-fa/</a></li>
</ul>
</li>
</ul>
<h1 id="笔试"><a href="#笔试" class="headerlink" title="笔试"></a>笔试</h1><p>做的A卷，一共三部分，第一部分是不定选项，第二部分是填空题，第三部分有两道编程题。 </p>
<ul>
<li><p>第一道编程题，输入一个字符串，判断这个字符串是不是全对称字符串 </p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        sgood = <span class="string">&quot;&quot;</span>.join(ch.lower() <span class="keyword">for</span> ch <span class="keyword">in</span> s <span class="keyword">if</span> ch.isalnum())</span><br><span class="line">        <span class="keyword">return</span> sgood == sgood[::-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        sgood = <span class="string">&quot;&quot;</span>.join(ch.lower() <span class="keyword">for</span> ch <span class="keyword">in</span> s <span class="keyword">if</span> ch.isalnum())</span><br><span class="line">        n = <span class="built_in">len</span>(sgood)</span><br><span class="line">        left, right = <span class="number">0</span>, n - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="keyword">if</span> sgood[left] != sgood[right]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            left, right = left + <span class="number">1</span>, right - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validPalindrome</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment">#lambda [arg1 [,arg2,.....argn]]:expression, x[start:end:span] 当 span&lt;0 时，列表翻转</span></span><br><span class="line">        isPalindrome = <span class="keyword">lambda</span> x : x == x[::-<span class="number">1</span>] <span class="comment"># isPalindrome 返回值就是 bool</span></span><br><span class="line"></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            <span class="keyword">if</span> s[left] == s[right]:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> isPalindrome(s[left + <span class="number">1</span> : right + <span class="number">1</span>]) <span class="keyword">or</span> isPalindrome(s[left: right])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

</li>
<li><p>第二道编程题有很多种不同的木材，每种木材可以选取任意次，让你选择最少的木材数量，使得木材长度和刚好等于k</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">coinChange</span>(<span class="params">self, coins: List[<span class="built_in">int</span>], amount: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        </span><br><span class="line">        dp = [<span class="number">0</span>] + [<span class="number">10001</span>] * (amount)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(coin, amount + <span class="number">1</span>):</span><br><span class="line">                dp[j] = <span class="built_in">min</span>(dp[j], dp[j - coin] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>] <span class="keyword">if</span> dp[-<span class="number">1</span>] != <span class="number">10001</span> <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>



<p>第一题求回文串，123321算，12321不算，1221123321这种也算</p>
<p>第二题给一个数和一个数组，用数组里面的数最少能否组成这个数，不能返回-1，能的话返回用的数组里面的数量 </p>
<p>  好像两道都可以dp，不过我第二个用的dp，第一个用的算是滑动窗口</p>
<p>9.10做的笔试2道编程，力扣队伍报数出列那个问题，另一个忘记了，不过不难</p>
<p> 不定项选择（3<em>10？），填空（3</em>10？），两道编程题（20*2）<br> 选择填空包括Python的一些函数情况，比如getattribute，exit这些；</p>
<ul>
<li><p><code>__getattribute__</code>是属性访问拦截器，就是当这个类的属性被访问时，会自动调用类的<code>__getattribute__</code>方法</p>
</li>
<li><p>调用实例对象 aa 的 name 属性时，不会直接打印，而是把 name 的值作为实参传进 __getattribute__方法中（参数obj是我随便定义的，可任意起名），经过一系列操作后，再把name的值返回。Python中只要定义了继承object的类，就默认存在属性拦截器，只不过是拦截后没有进行任何操作，而是直接返回。所以我们可以自己改写__getattribute__方法来实现相关功能，比如查看权限、打印log日志等。如下代码，简单理解即可：</p>
</li>
</ul>
<p><a href="">二叉树</a>给出先序和中序遍历，写出后续遍历；</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvv3rb2lqnj311d0rsadq.jpg"></p>
<p>网络的tcp如何保证数据传输真实可靠之类的</p>
<ol>
<li>应用数据被分割成 TCP 认为最适合发送的数据块。</li>
<li>TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</li>
<li><strong>校验和：</strong>TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li>
<li>TCP 的接收端会丢弃重复的数据。</li>
<li><strong>流量控制：</strong>TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</li>
<li><strong>拥塞控制：</strong>当网络拥塞时，减少数据的发送。</li>
<li><strong>ARQ协议：</strong>也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li>
<li><strong>超时重传：</strong>当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li>
</ol>
<p>编程题一个是字符串分割对称，一个是旅行家问题，用<a href="">动态规划</a>的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mincostTickets</span>(<span class="params">self, days: List[<span class="built_in">int</span>], costs: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (days[-<span class="number">1</span>] + <span class="number">1</span>)</span><br><span class="line">        <span class="comment">#dp = [0 for _ in range(days[-1] + 1)]  # dp数组，每个元素代表到当前天数最少钱数，为下标方便对应，多加一个 0 位置</span></span><br><span class="line">        days_idx = <span class="number">0</span>  <span class="comment"># 设定一个days指标，标记应该处理 days 数组中哪一个元素</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(dp)):</span><br><span class="line">            <span class="keyword">if</span> i != days[days_idx]:  <span class="comment"># 若当前天数不是待处理天数，则其花费费用和前一天相同</span></span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 若 i 走到了待处理天数，则从三种方式中选一个最小的</span></span><br><span class="line">                dp[i] = <span class="built_in">min</span>(dp[<span class="built_in">max</span>(<span class="number">0</span>, i - <span class="number">1</span>)] + costs[<span class="number">0</span>],</span><br><span class="line">                            dp[<span class="built_in">max</span>(<span class="number">0</span>, i - <span class="number">7</span>)] + costs[<span class="number">1</span>],</span><br><span class="line">                            dp[<span class="built_in">max</span>(<span class="number">0</span>, i - <span class="number">30</span>)] + costs[<span class="number">2</span>])</span><br><span class="line">                days_idx += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]  <span class="comment"># 返回最后一天对应的费用即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 二分法 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mincostTickets</span>(<span class="params">self, days: List[<span class="built_in">int</span>], costs: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        ans = [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i, day <span class="keyword">in</span> <span class="built_in">enumerate</span>(days):</span><br><span class="line">            ans.append(<span class="built_in">min</span>(</span><br><span class="line">                ans[-<span class="number">1</span>] + costs[<span class="number">0</span>],</span><br><span class="line">                ans[bisect.bisect(days, day - <span class="number">7</span>)] + costs[<span class="number">1</span>],</span><br><span class="line">                ans[bisect.bisect(days, day - <span class="number">30</span>)] + costs[<span class="number">2</span>]</span><br><span class="line">            ))</span><br><span class="line">        <span class="keyword">return</span> ans[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>



<p>第一题：厨师做饭(LRU)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSatisfaction</span>(<span class="params">self, satisfaction: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        satisfaction.sort(reverse=<span class="literal">True</span>)</span><br><span class="line">        presum, ans = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> si <span class="keyword">in</span> satisfaction:</span><br><span class="line">            <span class="keyword">if</span> presum + si &gt; <span class="number">0</span>:</span><br><span class="line">                presum += si</span><br><span class="line">                ans += presum</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>



<p>第二题：小机器人方案数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">n, m, k, p &#x3D; list(map(int, input().split()))</span><br><span class="line">eps &#x3D; 1e9 + 7</span><br><span class="line"></span><br><span class="line">last &#x3D; [0] * (n + 2)</span><br><span class="line">curr &#x3D; [0] * (n + 2)</span><br><span class="line">last[m] &#x3D; 1</span><br><span class="line">for i in range(1, k+1):</span><br><span class="line">    l &#x3D; max(1, m-i)</span><br><span class="line">    r &#x3D; min(n, m+i)</span><br><span class="line">    for j in range(l, r+1):</span><br><span class="line">        curr[j] &#x3D; (last[j-1] + last[j + 1]) % eps</span><br><span class="line">    last[:] &#x3D; curr[:]</span><br><span class="line">print(int(curr[p]))</span><br></pre></td></tr></table></figure>





<p>10道多选+10道填空+两道编程题 </p>
<p> 编程题1：判断字符串能不能被折叠，比如123321可以被折叠，12321不能，1233211221可以分成两串123321和1221分别可以折叠。 </p>
<ul>
<li> 是<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-parentheses/">有效的括号</a>这种类型的变题，直接用栈就可以解决了，我当时用递归只能 ac 60% 左右。 </li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># a = [1,2,3,3,2,1,1,1,1,1]</span></span><br><span class="line">a = [<span class="built_in">eval</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">input</span>().split()]</span><br><span class="line">stack, i, n = [], <span class="number">0</span>, <span class="built_in">len</span>(a)</span><br><span class="line"><span class="keyword">while</span>(i &lt; n):</span><br><span class="line">    <span class="keyword">if</span>(stack == [] <span class="keyword">or</span> a[i] != stack[-<span class="number">1</span>]):</span><br><span class="line">        stack.append(a[i])</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        tmp = []</span><br><span class="line">        <span class="keyword">while</span>(i &lt; n <span class="keyword">and</span> stack != [] <span class="keyword">and</span> a[i] == stack[-<span class="number">1</span>]):</span><br><span class="line">            tmp.append(stack.pop())</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span>(stack != []):</span><br><span class="line">            <span class="keyword">while</span>(tmp != []):</span><br><span class="line">                stack.append(tmp.pop())</span><br><span class="line"><span class="keyword">if</span>(stack == []):</span><br><span class="line">    print(<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p> 编程题2：有一些不同种类的木材，woods，每一种木材长度是woods[i]，请问拼成length长最少要多少根木头？每种木材可以无限使用，拼不出来返回-1。 </p>
<ul>
<li> 我当时用了贪心的思想，也只能通过ac 60% 左右。</li>
</ul>
<h1 id="ACM模式"><a href="#ACM模式" class="headerlink" title="ACM模式"></a>ACM模式</h1><h2 id="赛码"><a href="#赛码" class="headerlink" title="赛码"></a>赛码</h2><h3 id="例题1"><a href="#例题1" class="headerlink" title="例题1"></a>例题1</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">一条直线上等距离放置了n台路由器。路由器自左向右从<span class="number">1</span>到n编号。第i台路由器到第j台路由器的距离为| i-j |。每台路由器都有自己的信号强度，第i台路由器的信号强度为ai。所有与第i台路由器距离不超过ai的路由器可以收到第i台路由器的信号（注意，每台路由器都能收到自己的信号）。问一共有多少台路由器可以收到至少k台不同路由器的信号。</span><br><span class="line"></span><br><span class="line">输入描述</span><br><span class="line">输入第一行两个数n , k（<span class="number">1</span>≤n , k≤<span class="number">10</span>^<span class="number">5</span>）</span><br><span class="line">第二行n个数, a1 , a2 , a3……… , an（<span class="number">0</span>≤ai≤<span class="number">10</span>^<span class="number">9</span>）</span><br><span class="line"></span><br><span class="line">输出描述</span><br><span class="line">输出一个数，一共有多少台路由器可以收到至少k台不同路由器的信号。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 样例输入	</span></span><br><span class="line"><span class="number">4</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 样例输出</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">n, k = (<span class="built_in">int</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">input</span>().split())</span><br><span class="line">arr = [<span class="built_in">int</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">input</span>().split()]</span><br><span class="line"></span><br><span class="line">b = [<span class="number">0</span>] * n</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="keyword">if</span> i - arr[i] &lt; <span class="number">0</span>:</span><br><span class="line">        b[<span class="number">0</span>] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        b[i-arr[i]] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> i + arr[i] &lt; n - <span class="number">1</span>:</span><br><span class="line">        b[i + arr[i] + <span class="number">1</span>] -= <span class="number">1</span></span><br><span class="line">tmp=<span class="number">0</span></span><br><span class="line">num=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> b:</span><br><span class="line">    tmp += i</span><br><span class="line">    <span class="keyword">if</span> tmp&gt;= k:</span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line">print(num)</span><br></pre></td></tr></table></figure>



<h2 id="牛客"><a href="#牛客" class="headerlink" title="牛客"></a>牛客</h2><h3 id="单行输入"><a href="#单行输入" class="headerlink" title="单行输入"></a>单行输入</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># (1) 只是输入一个字符/字符串/数字</span></span><br><span class="line"><span class="comment"># &#x27;a&#x27; 或者 &#x27;aaa&#x27; 或者 1 或者 123</span></span><br><span class="line"></span><br><span class="line">n = <span class="built_in">input</span>() 	  <span class="comment"># str or string</span></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())  <span class="comment"># int</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># (2) 输入一行，这一行的多个元素直接用 分隔符分开</span></span><br><span class="line"><span class="comment"># &#x27;a&#x27; &#x27;b&#x27; &#x27;c&#x27; 或者 1 2 3</span></span><br><span class="line"></span><br><span class="line">line = <span class="built_in">input</span>().split(<span class="string">&#x27; &#x27;</span>) <span class="comment"># 空格分隔</span></span><br><span class="line">line = <span class="built_in">input</span>().split(<span class="string">&#x27;,&#x27;</span>) <span class="comment"># ,分隔</span></span><br><span class="line"></span><br><span class="line">line = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">str</span>, <span class="built_in">input</span>().split(<span class="string">&#x27; &#x27;</span>))) <span class="comment"># str</span></span><br><span class="line">line = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split(<span class="string">&#x27; &#x27;</span>))) <span class="comment"># int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, sys.stdin.readline().strip().split())</span><br><span class="line">print(n, m)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多元素输入</span></span><br><span class="line">a, b, c = [<span class="built_in">int</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">input</span>().split()]</span><br><span class="line">print(<span class="number">1</span>, b, c)</span><br><span class="line"><span class="comment"># 多行</span></span><br><span class="line"><span class="built_in">list</span>=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    <span class="built_in">list</span>.append([<span class="built_in">int</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">input</span>().split()])</span><br><span class="line">print(<span class="built_in">list</span>)</span><br></pre></td></tr></table></figure>

<h3 id="多行输入"><a href="#多行输入" class="headerlink" title="多行输入"></a>多行输入</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># （1）行数</span></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>()) <span class="comment"># n = 3，3 行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># (2) 每行只有一个元素的，如下</span></span><br><span class="line"><span class="comment"># aaa</span></span><br><span class="line"><span class="comment"># bbbbb</span></span><br><span class="line"><span class="comment"># ccccccc</span></span><br><span class="line"></span><br><span class="line">res = [] <span class="comment"># 注意使用一个 res 收集多行的结果，再在最后一起输出，牛客的一个bug </span></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())<span class="comment">#行数</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    s = <span class="built_in">input</span>()</span><br><span class="line">    <span class="keyword">if</span> s!=<span class="string">&#x27;&#x27;</span>:</span><br><span class="line">        line = <span class="built_in">str</span>(s)</span><br><span class="line">        line = <span class="built_in">int</span>(s)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="comment"># (3) 每行有多个元素，用分隔符分隔的</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># a b c </span></span><br><span class="line"><span class="comment"># 4 5 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># (3.1) 行数n已知</span></span><br><span class="line"><span class="comment"># res = [] # 注意使用一个 res 收集多行的结果，再在最后一起输出，牛客的一个bug </span></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())<span class="comment">#行数</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    s= <span class="built_in">input</span>()</span><br><span class="line">    <span class="keyword">if</span> s!=<span class="string">&#x27;&#x27;</span>:</span><br><span class="line">        line = [j <span class="keyword">for</span> j <span class="keyword">in</span> s.split()] <span class="comment">#str输入</span></span><br><span class="line">        line = [<span class="built_in">int</span>(j) <span class="keyword">for</span> j <span class="keyword">in</span> s.split()] <span class="comment">#int输入</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># (3.2) 多行输入，行数未知</span></span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        s = <span class="built_in">input</span>()</span><br><span class="line">        line = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, s.split(<span class="string">&#x27; &#x27;</span>))) </span><br><span class="line">        <span class="comment"># line = list(map(str, s.split(&#x27; &#x27;)))</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># (4) 首行有2个数字n，m ——&gt; 往下n行数据对应n， 再m行数据对应m</span></span><br><span class="line"><span class="comment"># 2 3</span></span><br><span class="line"><span class="comment"># 13 45</span></span><br><span class="line"><span class="comment"># 345 123 346</span></span><br><span class="line"></span><br><span class="line">info = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split(<span class="string">&#x27; &#x27;</span>))) <span class="comment"># 包含 n,m 的 list即 [n,m]</span></span><br><span class="line">n, m = info[<span class="number">0</span>], info[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这种情况下，最好先用 a, b 分别收集好 两类数据，每类都是多行(送入一个list)</span></span><br><span class="line">a = []</span><br><span class="line">b = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(info[<span class="number">0</span>]):</span><br><span class="line">    s = <span class="built_in">input</span>().split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    a.append(s)</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(info[<span class="number">1</span>]):</span><br><span class="line">    s = <span class="built_in">input</span>().split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    b.append(s)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment"># 多行输入</span></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>().strip())  <span class="comment"># 闹钟个数</span></span><br><span class="line"></span><br><span class="line">clocks = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    clock = [<span class="built_in">int</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">input</span>().strip().split(<span class="string">&quot; &quot;</span>)]</span><br><span class="line">    clocks.append(clock)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">N, K = [<span class="built_in">int</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">input</span>().strip().split(<span class="string">&quot; &quot;</span>)]</span><br><span class="line">P = <span class="built_in">input</span>().strip()</span><br><span class="line"></span><br><span class="line"><span class="comment"># </span></span><br><span class="line">N = <span class="built_in">int</span>(<span class="built_in">input</span>()) <span class="comment"># N 个</span></span><br><span class="line">years = [<span class="built_in">int</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">input</span>().strip().split(<span class="string">&quot; &quot;</span>)] <span class="comment">#</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># </span></span><br><span class="line">n = <span class="built_in">int</span>(sys.stdin.readline().strip())</span><br><span class="line">    inputs = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="comment"># 读取每一行</span></span><br><span class="line">        line = sys.stdin.readline().strip()</span><br><span class="line">        <span class="comment"># 把每一行的数字分隔后转化成int列表</span></span><br><span class="line">        values = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, line.split()))</span><br><span class="line">        inputs.append(values)</span><br><span class="line">        </span><br><span class="line"><span class="comment"># matrix</span></span><br><span class="line">m, k, n = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">list1, list2 = [], []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">	a = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))    </span><br><span class="line">    list1.append(a)<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):    </span><br><span class="line">        b = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))    </span><br><span class="line">        list2.append(b)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># </span></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())    </span><br><span class="line">nums = [<span class="built_in">int</span>(_) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">input</span>().split()]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># </span></span><br><span class="line">n, m, x = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">a = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br></pre></td></tr></table></figure>



<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出要注意，按行遍历输出，而不是输出一个list或者tuple</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 单行单输出</span></span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 单行多输出，空格隔开</span></span><br><span class="line"><span class="keyword">for</span> r <span class="keyword">in</span> result:</span><br><span class="line">    print(r, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 单行多输出，空格隔开</span></span><br><span class="line">print(*(<span class="built_in">list</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># list --&gt; str </span></span><br><span class="line"><span class="string">&#x27;&#x27;</span>join(<span class="built_in">list</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果多行输出 </span></span><br><span class="line"><span class="keyword">for</span> r <span class="keyword">in</span> result:</span><br><span class="line">    print(r)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="常用技巧"><a href="#常用技巧" class="headerlink" title="常用技巧"></a>常用技巧</h2><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># list</span></span><br><span class="line"><span class="comment"># list肯定是按顺序输出, 尽量只用  list </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">min</span>(), <span class="built_in">max</span>(), <span class="built_in">sum</span>()</span><br><span class="line"></span><br><span class="line">L.index(<span class="built_in">str</span>,beg,end) 返回开始索引或异常</span><br><span class="line"></span><br><span class="line">L.find(<span class="built_in">str</span>,beg,end) 返回开始索引或-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">.remove(具体内容)</span><br><span class="line"></span><br><span class="line">.pop(索引号)</span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> L[索引号]</span><br><span class="line"></span><br><span class="line">.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>]) <span class="comment"># 依据 </span></span><br><span class="line"></span><br><span class="line">.sort(key=<span class="keyword">lambda</span> x:(-x[<span class="number">1</span>],x[<span class="number">0</span>],x[<span class="number">2</span>]))<span class="comment">#默认是升序，加个符号变降序，可做多级排序。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sorted</span>() <span class="comment"># 不在本地做排序</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出 L[start:end:step], start,end 可以省略，step=1 可以省略 (有几种case不发生歧义就可以省略)</span></span><br><span class="line">正序: L[::]</span><br><span class="line">倒序: L[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>



<h3 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.keys() <span class="comment"># 返回 key 组成的list</span></span><br><span class="line">.values() <span class="comment"># 返回 val 组成的 list</span></span><br><span class="line">.items()<span class="comment">#返回的是元组 (key, val)</span></span><br></pre></td></tr></table></figure>



<h3 id="str"><a href="#str" class="headerlink" title="str"></a>str</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.strip() <span class="comment"># 去除首位空格</span></span><br><span class="line"></span><br><span class="line">.strip().strip(‘-a’) <span class="comment"># 去除首位空格和字符</span></span><br><span class="line"></span><br><span class="line">S[:<span class="number">3</span>]  +S[<span class="number">5</span>:] <span class="comment"># 拼接字符串，去除某个字符</span></span><br><span class="line"></span><br><span class="line">.replace(‘a’, ’b’) <span class="comment"># 替换字符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">re.sub(‘a’,’b’,s) <span class="comment"># 替换字符</span></span><br></pre></td></tr></table></figure>



<h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">判断 j 位 是否为<span class="number">1</span>     (bits&gt;&gt;j) &amp; <span class="number">1</span></span><br><span class="line">把第 j 位变成<span class="number">1</span>        bits|(<span class="number">1</span>&lt;&lt;j)</span><br><span class="line">将第 j 位变成<span class="number">0</span>        bits&amp;~(<span class="number">1</span>&lt;&lt;j)</span><br></pre></td></tr></table></figure>



<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><ul>
<li>掌握核心: Tree -&gt; Binary Tree -&gt; BST(search), BBT(balance), 完全二叉树，满二叉树</li>
<li>BST的创建</li>
<li>BT的模板及几种代表性题目</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<h3 id="enumerate"><a href="#enumerate" class="headerlink" title="enumerate"></a>enumerate</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># enumerate 用法</span></span><br><span class="line"><span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(a):    </span><br><span class="line">    sum1 += (i+<span class="number">1</span>)*x</span><br></pre></td></tr></table></figure>



<h1 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h1><h2 id="69-Sqrt-x"><a href="#69-Sqrt-x" class="headerlink" title="69. Sqrt(x)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sqrtx/">69. Sqrt(x)</a></h2><p>不允许使用任何内置指数函数和算符，例如 <code>pow(x, 0.5)</code> 或者 <code>x ** 0.5</code></p>
<p>牛顿法：</p>
<img src="https://assets.leetcode-cn.com/solution-static/69/69_fig1.png" alt="fig1" style="zoom:50%;" />

<p>梯度下降法：最小二乘法 <img src="https://bkimg.cdn.bcebos.com/formula/34734d73c8b627846467333de63e6e6a.svg" alt="img"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 牛顿法</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">我们先任意选定一个初始点x0和迭代误差ϵ</span></span><br><span class="line"><span class="string">点 (x0, f(x0)) 切线方程 f(x) - f(x0) = f`(x0)(x - x0), 当 相交 x 轴</span></span><br><span class="line"><span class="string">x1 = x0 − f(x0)/f′(x0)。反复迭代直到 |x1 − x0| &lt; ϵ。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">先求出f′(x)=2x。√2 肯定在1到2之间，我们不妨选定x0=1.5，误差ϵ=0.00001。</span></span><br><span class="line"><span class="string">初始0：x0=1.5, f(x0)=0.25, f′(x0)=3, f(x0)/f′(x0)=0.08333</span></span><br><span class="line"><span class="string">迭代1：x1=1.5−0.08333=1.41667, f(x1)=0.00694, f′(x1)=2.83333, f(x1)/f′(x1)=0.00245</span></span><br><span class="line"><span class="string">迭代2：x2=1.41667−0.00245=1.41422, f(x2)=0.00001, f′(x2)=2.82843, f(x2)/f′(x2)=0.00001</span></span><br><span class="line"><span class="string">迭代3：x3=1.41422−0.00001=1.41421</span></span><br><span class="line"><span class="string">停止迭代，最终近似解就是1.41421.</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### 官方解答</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> </span><br><span class="line">        C, x0 = <span class="built_in">float</span>(x), <span class="built_in">float</span>(x)</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            xi = <span class="number">0.5</span> * (x0 + C / x0)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">abs</span>(x0 - xi) &lt; <span class="number">1e-7</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            x0 = xi</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(x0)</span><br><span class="line"><span class="comment">### </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        C, x0 = <span class="built_in">float</span>(x), <span class="built_in">float</span>(x)</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">abs</span>(x0 ** <span class="number">2</span> - C) &gt; <span class="number">1e-5</span>:</span><br><span class="line">            x0 -= ((x0 ** <span class="number">2</span>) - C) / (<span class="number">2</span> * x0)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(x0)    </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 二分法，双指针</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        l, r, ans = <span class="number">0</span>, x, -<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            mid = (l + r) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> mid * mid &lt;= x:</span><br><span class="line">                ans = mid</span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用梯度下降求根号2</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">x = t×t</span></span><br><span class="line"><span class="string">我们的目的是求出一个t使得t*t 尽可能的接近x</span></span><br><span class="line"><span class="string">因为这里是对x求根号，所以x就是我们常说的y 而t变成了我们常说的x</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">f(t) = t*t</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">损失函数是什么？我们这里用最小二乘法 loss = (f(t) - x)^2 </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">定义学习率 lr = 0.0001</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">所以我们的目标函数是什么？我理解的目标函数，就是我们要用优化器（SGD、Adam等）优化的函数，也就是目标函数等于 损失函数+正则化项</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">当然这里我们不需要正则化项，所以我们的目标函数就是损失函数loss = (f(t)-x)^2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">确定迭代过程 t(n) = t(n-1)-lr*(d((f(t)-x)^2)/d(t))</span></span><br><span class="line"><span class="string">也就是要求导了,求导怎么求？外导乘内导</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">那也就是 2(f(t)-x)乘以f(t)对t的导数，那就是 2t</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">所以综合下就说 2(f(t)-x)2t</span></span><br><span class="line"><span class="string">化简完之后就是4t*(t*t-x)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        t = <span class="number">1</span></span><br><span class="line">        lr = <span class="number">0.0001</span> <span class="comment">#learning_rate 学习率</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#是用 mse 均方差损失函数</span></span><br><span class="line">        <span class="keyword">while</span> (x - t ** <span class="number">2</span>) ** <span class="number">2</span> &gt; <span class="number">0.01</span>: <span class="comment">#定义精度</span></span><br><span class="line">            <span class="comment"># tn = tn-1+损失函数对x求偏导</span></span><br><span class="line">            t = t - lr * (<span class="number">4</span> * t * (t * t - x)) </span><br><span class="line">            <span class="comment">#损失函数对t求偏导x是常数</span></span><br><span class="line">            <span class="comment"># (x-t^2)^2 对t求导 外导乘内导 </span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(t) + <span class="number">1</span> <span class="keyword">if</span> (<span class="built_in">int</span>(t) + <span class="number">1</span>) ** <span class="number">2</span> &lt;= x <span class="keyword">else</span> <span class="built_in">int</span>(t)</span><br><span class="line">        <span class="comment"># 注意边界，比如4通过梯度下降以后得到的值是1.97，，，但是我们要返回2 而8通过梯度下降之后是2.8，，但是我们要返回2</span></span><br><span class="line">        <span class="comment"># 所以我们看我们向下取整之后的值 平方后是否可以小于等于x如果可以就返回这个 不行就返回向下取整的值</span></span><br></pre></td></tr></table></figure>



<h2 id="求立方根"><a href="#求立方根" class="headerlink" title="求立方根"></a>求立方根</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 牛顿法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">newton_method</span>(<span class="params">num, error_value</span>):</span></span><br><span class="line">    x = num / <span class="number">2.</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">abs</span>(x**<span class="number">3</span> - num) &gt; error_value:</span><br><span class="line">        x -= (x**<span class="number">3</span> - num) / (<span class="number">3.0</span> * x**<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    num = -<span class="number">667817</span></span><br><span class="line">    error_value = <span class="number">1e-5</span></span><br><span class="line">    print(newton_method(num, error_value))</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 梯度下降    </span></span><br><span class="line">x = <span class="number">10</span></span><br><span class="line">lr = <span class="number">1e-3</span></span><br><span class="line">t = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> ((x - t ** <span class="number">3</span> ) ** <span class="number">2</span>) &gt; <span class="number">1e-2</span>:</span><br><span class="line">    t -= lr * <span class="number">6</span> * t * t * (t ** <span class="number">3</span> - x)</span><br><span class="line">print(<span class="built_in">int</span>(t))</span><br><span class="line">print(<span class="built_in">int</span>(t) + <span class="number">1</span> <span class="keyword">if</span> (<span class="built_in">int</span>(t) + <span class="number">1</span>) ** <span class="number">3</span> &lt;= x <span class="keyword">else</span> <span class="built_in">int</span>(t))</span><br></pre></td></tr></table></figure>





<h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><ul>
<li>总结<ul>
<li>两个指针 <code>left right</code>，注意边界尽量小</li>
<li>收缩方向</li>
<li>大小比较</li>
</ul>
</li>
</ul>
<h2 id="167-两数之和-II-输入有序数组"><a href="#167-两数之和-II-输入有序数组" class="headerlink" title="167. 两数之和 II - 输入有序数组"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/">167. 两数之和 II - 输入有序数组</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, numbers: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[int]:</span>																		left, right = <span class="number">0</span>, <span class="built_in">len</span>(numbers) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="keyword">if</span> numbers[left] + numbers[right] == target:</span><br><span class="line">                <span class="keyword">return</span> [left+<span class="number">1</span>, right+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">elif</span> numbers[left] + numbers[right] &gt; target:</span><br><span class="line">                right = right - <span class="number">1</span> <span class="comment"># 右指针左移</span></span><br><span class="line">            <span class="keyword">elif</span> numbers[left] + numbers[right] &lt; target:</span><br><span class="line">                left = left + <span class="number">1</span>   <span class="comment"># 左指针右移</span></span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gtv9zq4485j60rm0a8t8x02.jpg"></p>
<h2 id="633-平方数之和"><a href="#633-平方数之和" class="headerlink" title="633. 平方数之和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sum-of-square-numbers/">633. 平方数之和</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">judgeSquareSum</span>(<span class="params">self, c: <span class="built_in">int</span></span>) -&gt; bool:</span></span><br><span class="line">        left = <span class="number">0</span> <span class="comment"># 零是整数</span></span><br><span class="line">        right = <span class="built_in">int</span>(c ** <span class="number">0.5</span>) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            <span class="keyword">if</span> left ** <span class="number">2</span> + right ** <span class="number">2</span> == c:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> left ** <span class="number">2</span> + right ** <span class="number">2</span> &gt; c:</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其他解法：</p>
<ul>
<li>费马平方和定理，检查所有模4余3的因子的个数是否为偶数个即可</li>
</ul>
<h2 id="345-反转字符串中的元音字母"><a href="#345-反转字符串中的元音字母" class="headerlink" title="345. 反转字符串中的元音字母"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string/">345. 反转字符串中的元音字母</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseVowels</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line"></span><br><span class="line">        vowels = <span class="string">&#x27;aeiouAEIOU&#x27;</span></span><br><span class="line">        s = <span class="built_in">list</span>(s)</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="keyword">if</span> s[left] <span class="keyword">in</span> vowels:</span><br><span class="line">                <span class="keyword">while</span> s[right] <span class="keyword">not</span> <span class="keyword">in</span> vowels:</span><br><span class="line">                    right = right - <span class="number">1</span></span><br><span class="line">                s[left], s[right] = s[right], s[left]</span><br><span class="line">                left = left + <span class="number">1</span></span><br><span class="line">                right = right - <span class="number">1</span> </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = left + <span class="number">1</span></span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(s) <span class="comment"># join jion</span></span><br></pre></td></tr></table></figure>



<h2 id="680-验证回文字符串-Ⅱ"><a href="#680-验证回文字符串-Ⅱ" class="headerlink" title="680. 验证回文字符串 Ⅱ"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-palindrome-ii/">680. 验证回文字符串 Ⅱ</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validPalindrome</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment">#lambda [arg1 [,arg2,.....argn]]:expression, x[start:end:span] 当 span&lt;0 时，列表翻转</span></span><br><span class="line">        isPalindrome = <span class="keyword">lambda</span> x : x == x[::-<span class="number">1</span>] <span class="comment"># isPalindrome 返回值就是 bool</span></span><br><span class="line"></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            <span class="keyword">if</span> s[left] == s[right]:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> isPalindrome(s[left + <span class="number">1</span> : right + <span class="number">1</span>]) <span class="keyword">or</span> isPalindrome(s[left: right])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> <span class="comment"># True</span></span><br></pre></td></tr></table></figure>



<h2 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88. 合并两个有序数组"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-sorted-array/">88. 合并两个有序数组</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self, nums1: List[<span class="built_in">int</span>], m: <span class="built_in">int</span>, nums2: List[<span class="built_in">int</span>], n: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">sorted</span> = []</span><br><span class="line">        p1, p2 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> p1 &lt; m <span class="keyword">or</span> p2 &lt; n:</span><br><span class="line">            <span class="keyword">if</span> p1 == m:</span><br><span class="line">                <span class="built_in">sorted</span>.append(nums2[p2])</span><br><span class="line">                p2 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> p2 == n:</span><br><span class="line">                <span class="built_in">sorted</span>.append(nums1[p1])</span><br><span class="line">                p1 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums1[p1] &lt; nums2[p2]:</span><br><span class="line">                <span class="built_in">sorted</span>.append(nums1[p1])</span><br><span class="line">                p1 = p1 + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">sorted</span>.append(nums2[p2])</span><br><span class="line">                p2 = p2 + <span class="number">1</span>     </span><br><span class="line">        nums1[:] = <span class="built_in">sorted</span></span><br></pre></td></tr></table></figure>



<h2 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-cycle/">141. 环形链表</a></h2><ul>
<li>使用双指针（快慢指针），一个指针每次移动一个节点，一个指针每次移动两个节点，如果存在环，那么这两个指针一定会相遇。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span>(<span class="params">self, head: ListNode</span>) -&gt; bool:</span></span><br><span class="line">        p1 = p2 = head</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> p2 <span class="keyword">and</span> p2.<span class="built_in">next</span>: <span class="comment"># 防止head为空和出现空指针的next的情况</span></span><br><span class="line">            p1 = p1.<span class="built_in">next</span></span><br><span class="line">            p2 = p2.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> p1 <span class="keyword">is</span> p2:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>



<h2 id="524-通过删除字母匹配到字典里最长单词"><a href="#524-通过删除字母匹配到字典里最长单词" class="headerlink" title="524. 通过删除字母匹配到字典里最长单词"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/">524. 通过删除字母匹配到字典里最长单词</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 双指针</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLongestWord</span>(<span class="params">self, s: <span class="built_in">str</span>, dictionary: List[<span class="built_in">str</span>]</span>) -&gt; str:</span></span><br><span class="line">        res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> d <span class="keyword">in</span> dictionary:</span><br><span class="line">            i = j = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(d) <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(s):</span><br><span class="line">                <span class="keyword">if</span> d[i] == s[j]:</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i == <span class="built_in">len</span>(d):</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(d) &gt; <span class="built_in">len</span>(res) <span class="keyword">or</span> (<span class="built_in">len</span>(d) == <span class="built_in">len</span>(res) <span class="keyword">and</span> d &lt; res):</span><br><span class="line">                    res = d</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment"># 排序</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLongestWord</span>(<span class="params">self, s: <span class="built_in">str</span>, dictionary: List[<span class="built_in">str</span>]</span>) -&gt; str:</span></span><br><span class="line">        d = dictionary</span><br><span class="line">        <span class="comment"># - 用好python内置函数sort()、find(),比双指针效率更高</span></span><br><span class="line">        <span class="comment"># 可以用元组表示多关键字排序，第一关键字是长度降序，第二关键字是字符串本身字典序</span></span><br><span class="line">        d.sort(key = <span class="keyword">lambda</span> x: [-<span class="built_in">len</span>(x), x])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> d:</span><br><span class="line">            p1 = <span class="number">0</span></span><br><span class="line">            p2 = <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> p1 &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> p2 &lt; <span class="built_in">len</span>(word):</span><br><span class="line">                <span class="keyword">if</span> s[p1] == word[p2]:</span><br><span class="line">                    p1 += <span class="number">1</span></span><br><span class="line">                    p2 += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    p1 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(word) == p2:</span><br><span class="line">                <span class="keyword">return</span> word</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>



<h2 id="38-外观数列"><a href="#38-外观数列" class="headerlink" title="38. 外观数列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-and-say/">38. 外观数列</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countAndSay</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; str:</span></span><br><span class="line">        pre = <span class="string">&#x27;1&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            l = r = <span class="number">0</span></span><br><span class="line">            tmp = <span class="string">&#x27;&#x27;</span></span><br><span class="line">            <span class="keyword">while</span> r &lt; <span class="built_in">len</span>(pre):</span><br><span class="line">                <span class="keyword">while</span> r &lt; <span class="built_in">len</span>(pre) <span class="keyword">and</span> pre[l] == pre[r]:</span><br><span class="line">                    r += <span class="number">1</span></span><br><span class="line">                tmp += <span class="built_in">str</span>(r-l) + pre[l]</span><br><span class="line">                l = r</span><br><span class="line">            pre = tmp</span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure>



<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215. 数组中的第K个最大元素"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">return</span> nums[-k]</span><br></pre></td></tr></table></figure>



<h2 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347. 前 K 个高频元素"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">　　collections是日常工作中的重点、高频模块，常用类型有：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">　　计数器（Counter）</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">　　双向队列（deque）</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">　　默认字典（defaultdict）</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">　　有序字典（OrderedDict）</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">　　可命名元组（namedtuple）　</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topKFrequent</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">return</span> [i[<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> Counter(nums).most_common(k)]</span><br></pre></td></tr></table></figure>



<h2 id="451-根据字符出现频率排序"><a href="#451-根据字符出现频率排序" class="headerlink" title="451. 根据字符出现频率排序"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sort-characters-by-frequency/">451. 根据字符出现频率排序</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">frequencySort</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line">        <span class="comment"># s = &#x27;tree&#x27;</span></span><br><span class="line">        <span class="comment"># [(&#x27;e&#x27;, 2), (&#x27;t&#x27;, 1), (&#x27;r&#x27;, 1)]</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(i * j <span class="keyword">for</span> i, j <span class="keyword">in</span> Counter(s).most_common()) </span><br></pre></td></tr></table></figure>



<h2 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="75. 颜色分类"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sort-colors/">75. 颜色分类</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 0，1，2 排序。一次遍历，如果是0，则移动到表头，如果是2，则移动到表尾，不用考虑1。0和2处理完，1还会有错吗？</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 双指针，一次交换</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortColors</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        p0 = p1 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> nums[i] == <span class="number">1</span>:</span><br><span class="line">                nums[i], nums[p1] = nums[p1], nums[i]</span><br><span class="line">                p1 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[i] == <span class="number">0</span>:</span><br><span class="line">                nums[i], nums[p0] = nums[p0], nums[i]</span><br><span class="line">                <span class="keyword">if</span> p0 &lt; p1:</span><br><span class="line">                    nums[i], nums[p1] = nums[p1], nums[i]</span><br><span class="line">                p0 += <span class="number">1</span></span><br><span class="line">                p1 += <span class="number">1</span></span><br><span class="line"><span class="comment"># 两次交换</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortColors</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        idx = <span class="number">0</span> <span class="comment">#指针</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(idx, n):</span><br><span class="line">            <span class="keyword">if</span> nums[i] == <span class="number">0</span>:</span><br><span class="line">                nums[idx], nums[i] = nums[i], nums[idx]</span><br><span class="line">                idx += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(idx, n):</span><br><span class="line">            <span class="keyword">if</span> nums[i] == <span class="number">1</span>:</span><br><span class="line">                nums[idx], nums[i] = nums[i], nums[idx]</span><br><span class="line">                idx += <span class="number">1</span>                </span><br></pre></td></tr></table></figure>

<h2 id="排序算法比较"><a href="#排序算法比较" class="headerlink" title="排序算法比较"></a>排序算法比较</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gv890goha7j60qu0gc41z02.jpg" alt="849589-20171015233043168-1867817869.png"></p>
<ul>
<li>稳定性：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，A1=A2，且A1在A2之前，而在排序后的序列中，A1仍在A2之前，则称这种排序算法是稳定的；否则称为不稳定的。</li>
<li>排序方式</li>
</ul>
<h2 id="1-冒泡排序-BubbleSort"><a href="#1-冒泡排序-BubbleSort" class="headerlink" title="1 冒泡排序_BubbleSort"></a>1 冒泡排序_BubbleSort</h2><blockquote>
<p>冒泡排序是通过多次的比较和交换逐渐将序列排序的方法。大（小）的元素会经过交换<code>浮出</code>水面。</p>
</blockquote>
<ul>
<li>每次对相邻的两个数进行比较，若符合大小关系，则交换两个数；</li>
<li>每经过一次排序，将最大（小）的数放在后（前）面，剩下的未排序.length - 1。</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gbtoun6ic4g30m908r0wt.gif" alt="img"></p>
<p>算法分析：稳定排序，内排序，时间复杂度：O(n^2)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span>(<span class="params">nums</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 进行多次循环</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n - c):</span><br><span class="line">            <span class="keyword">if</span> nums[i - <span class="number">1</span>] &gt; nums[i]:</span><br><span class="line">                nums[i - <span class="number">1</span>], nums[i] = nums[i], nums[i - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>



<h2 id="2-选择排序-SelectionSort"><a href="#2-选择排序-SelectionSort" class="headerlink" title="2 选择排序_SelectionSort"></a>2 选择排序_SelectionSort</h2><blockquote>
<p>选择排序，每次遍历序列，找到最小（大）的数，并放在序列的最前面，对剩下未排序的序列重复上述操作。</p>
</blockquote>
<ul>
<li>每次初始设定为未序列的元素第一个为最小（大）元素，首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置；</li>
<li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾；</li>
<li>重复第二步，直到所有元素均排序完毕。</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gbtprp6xjfg30mj06wdsb.gif" alt="img"></p>
<p><strong>稳定性：</strong>用数组实现的选择排序是不稳定的，用链表实现的选择排序是稳定的；时间复杂度：O(n^2) ，<code>n</code>是数组长度</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selection_sort</span>(<span class="params">nums</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="comment"># n2</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, n):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; nums[j]:</span><br><span class="line">                nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>



<h2 id="3-插入排序-InsertionSort"><a href="#3-插入排序-InsertionSort" class="headerlink" title="3 插入排序_InsertionSort"></a>3 插入排序_InsertionSort</h2><blockquote>
<p>插入排序的基本操作就是从未排序的序列中取出一个数，插入到已经排序序列的正确位置中。</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gbtqzysve0g30mj0e1n6v.gif" alt="img"></p>
<p><strong>算法分析：</strong>稳定排序，内排序，时间复杂度：O(n^2)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertion_sort</span>(<span class="params">nums</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        <span class="keyword">while</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i - <span class="number">1</span>] &gt; nums[i]:</span><br><span class="line">            nums[i - <span class="number">1</span>], nums[i] = nums[i], nums[i - <span class="number">1</span>] <span class="comment"># 交换</span></span><br><span class="line">            i -= <span class="number">1</span> <span class="comment"># 倒回去比较</span></span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>





<h2 id="4-希尔排序-ShellSort"><a href="#4-希尔排序-ShellSort" class="headerlink" title="4 希尔排序_ShellSort"></a>4 希尔排序_ShellSort</h2><blockquote>
<p>先将整个序列划分为若若干子序列，分别进行插入排序排序。开始增量（Gap）= int(arr.length/2)，经过一次排序后，增量 int(arr.length/2)/2，一直到增量 = 1。</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gbuvgp28bag307p09kgsu.gif" alt="img"></p>
<p>算法分析：非稳定排序，内排序，O(nlogn)；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_sort</span>(<span class="params">nums</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    gap = n // <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> gap:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(gap, n):</span><br><span class="line">            <span class="keyword">while</span> i - gap &gt;= <span class="number">0</span> <span class="keyword">and</span> nums[i - gap] &gt; nums[i]:</span><br><span class="line">                nums[i - gap], nums[i] = nums[i], nums[i - gap] <span class="comment"># 交换 Gap 增量</span></span><br><span class="line">                i -= gap</span><br><span class="line">        gap //= <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>



<h2 id="5-归并排序-MergeSort"><a href="#5-归并排序-MergeSort" class="headerlink" title="5 归并排序_MergeSort"></a>5 归并排序_MergeSort</h2><blockquote>
<p>归并排序的思想：将序列分解成最小有序子序列，再逐个将有序的子序列进行合并，得到有序的子序列段，最终得到一个完整的有序序列。</p>
<p>分治：先将数组分成子序列，让子序列有序，再将子序列间有序，合并成有序数组。</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gbuvg1qamsg30mj0e1k05.gif" alt="img"></p>
<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gv87ene21hj611h0u0whh02.jpg" style="zoom:50%;" />

<p>算法分析：稳定排序，外排序（占用额外内存），时间复杂度O(nlogn)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span>(<span class="params">nums</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    mid = <span class="built_in">len</span>(nums) // <span class="number">2</span></span><br><span class="line">    <span class="comment"># 分</span></span><br><span class="line">    left = merge_sort(nums[:mid])</span><br><span class="line">    right = merge_sort(nums[mid:])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 合并</span></span><br><span class="line">    <span class="keyword">return</span> merge(left, right)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">left, right</span>):</span></span><br><span class="line">    res = []</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(left) <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(right):</span><br><span class="line">        <span class="keyword">if</span> left[i] &lt;= right[j]:</span><br><span class="line">            res.append(left[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res.append(right[j])</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">    res += left[i:]</span><br><span class="line">    res += right[j:]</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>





<h2 id="6-快速排序-QuickSort"><a href="#6-快速排序-QuickSort" class="headerlink" title="6 快速排序_QuickSort"></a>6 快速排序_QuickSort</h2><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p>
<ul>
<li>步骤1：从数列中挑出一个元素，称为 “基准”（pivot ）；</li>
<li>步骤2：重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后；该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>
<li>步骤3：递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>
</ul>
<p><img src="https://pic.leetcode-cn.com/d13bd82917a8eba049efa261bebd3beb74b9e7c1adf39ce51bf1c9dd60d49f57-Quicksort-example.gif"></p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gbuvm1jkf0g30mj070jyl.gif" alt="img"></p>
<p>算法分析：不稳定排序，内排序，时间复杂度度O(nlogn)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span>(<span class="params">nums</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quick</span>(<span class="params">left, right</span>):</span></span><br><span class="line">        <span class="keyword">if</span> left &gt;= right:</span><br><span class="line">            <span class="keyword">return</span> nums</span><br><span class="line">        </span><br><span class="line">        pivot = left <span class="comment"># 最左边</span></span><br><span class="line">        i = left</span><br><span class="line">        j = right</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> nums[j] &gt; nums[pivot]:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> nums[i] &lt;= nums[pivot]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">        nums[pivot], nums[j] = nums[j], nums[pivot]</span><br><span class="line">        <span class="comment"># 分区</span></span><br><span class="line">        quick(left, j - <span class="number">1</span>)</span><br><span class="line">        quick(j + <span class="number">1</span>, right)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    <span class="keyword">return</span> quick(<span class="number">0</span>, n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>





<h2 id="7-堆排序-HeapSort"><a href="#7-堆排序-HeapSort" class="headerlink" title="7 堆排序_HeapSort"></a>7 堆排序_HeapSort</h2><p>堆排序是利用堆这个数据结构设计的排序算法。</p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gbuvq87o7sg30f70a4hdt.gif" alt="img"></p>
<p>建堆，从底向上调整堆，使得父亲节点比孩子节点值大，构成大顶堆；<br>交换堆顶和最后一个元素，重新调整堆。</p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gbuvq613sbg30go0goabf.gif" alt="img"></p>
<p>算法分析：不稳定排序，内排序，时间复杂度为O(nlogn)</p>
<h2 id="8-计数排序-CountingSort"><a href="#8-计数排序-CountingSort" class="headerlink" title="8 计数排序_CountingSort"></a>8 计数排序_CountingSort</h2><p>计数排序是典型的空间换时间算法，开辟额外数据空间存储用索引号记录数组的值和数组值个数</p>
<p>算法描述：</p>
<ul>
<li>找出待排序的数组的最大值和最小值</li>
<li>统计数组值的个数</li>
<li>反向填充目标数组</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gbuvuexgkng30s40fhjww.gif" alt="img"></p>
<p>算法分析：稳定排序，外排序，时间复杂度O(n + k)，但是对于数据范围很大的数组，需要大量时间和内存。</p>
<h2 id="9-桶排序-BucketSort"><a href="#9-桶排序-BucketSort" class="headerlink" title="9 桶排序_BucketSort"></a>9 桶排序_BucketSort</h2><p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gbuvy7lbqqj308n03nt8q.jpg" alt="img"></p>
<p>桶排序是计数排序的升级版，原理是：输入数据服从均匀分布的，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的算法或是以递归方式继续使用桶排序，此文编码采用递归方式）</p>
<p>算法描述：</p>
<ul>
<li>人为设置一个桶的BucketSize，作为每个桶放置多少个不同数值（意思就是BucketSize = 5，可以放5个不同数字比如[1, 2, 3,4,5]也可以放 100000个3，只是表示该桶能存几个不同的数值）</li>
<li>遍历待排序数据，并且把数据一个一个放到对应的桶里去</li>
<li>对每个不是桶进行排序，可以使用其他排序方法，也递归排序</li>
<li>不是空的桶里数据拼接起来</li>
</ul>
<p>算法分析：稳定排序，外排序，时间复杂度O(n + k)<em>O</em>(<em>n</em>+<em>k</em>)，<code>k</code>为桶的个数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bucket_sort</span>(<span class="params">nums, bucketSize</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    _min = <span class="built_in">min</span>(nums)</span><br><span class="line">    _max = <span class="built_in">max</span>(nums)</span><br><span class="line">    <span class="comment"># 需要桶个数</span></span><br><span class="line">    bucketNum = (_max - _min) // bucketSize + <span class="number">1</span></span><br><span class="line">    buckets = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(bucketNum)]</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="comment"># 放入相应的桶中</span></span><br><span class="line">        buckets[(num - _min) // bucketSize].append(num)</span><br><span class="line">    res = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> bucket <span class="keyword">in</span> buckets:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> bucket: <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> bucketSize == <span class="number">1</span>:</span><br><span class="line">            res.extend(bucket)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 当都装在一个桶里,说明桶容量大了</span></span><br><span class="line">            <span class="keyword">if</span> bucketNum == <span class="number">1</span>:</span><br><span class="line">                bucketSize -= <span class="number">1</span></span><br><span class="line">            res.extend(bucket_sort(bucket, bucketSize))</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>





<h2 id="10-基数排序-RadixSort"><a href="#10-基数排序-RadixSort" class="headerlink" title="10 基数排序_RadixSort"></a>10 基数排序_RadixSort</h2><p>基数排序是对数字每一位进行排序，从最低位开始排序</p>
<p>算法描述：</p>
<ul>
<li>找到数组最大值，得最大位数；</li>
<li>从最低位开始取每个位组成radix数组；</li>
<li>对radix进行计数排序（计数排序适用于小范围的特点）。</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gbuw3cz71lg30s40fywic.gif" alt="img"></p>
<p>算法分析：稳定排序，外排序，时间复杂度 posCount * (n + n)posCount∗(n+n) ，其中 posCount 为数组中最大元素的最高位数；简化下得：$O( k *n ) $；其中k为常数，n为元素个数。</p>
<h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><p>保证每次操作都是局部最优的，并且最后得到的结果是全局最优的。</p>
<h2 id="455-分发饼干"><a href="#455-分发饼干" class="headerlink" title="455. 分发饼干"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/assign-cookies/">455. 分发饼干</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findContentChildren</span>(<span class="params">self, g: List[<span class="built_in">int</span>], s: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        g.sort() <span class="comment"># 胃口值</span></span><br><span class="line">        s.sort() <span class="comment"># 饼干尺寸</span></span><br><span class="line">        </span><br><span class="line">        idx = <span class="built_in">len</span>(s) - <span class="number">1</span> <span class="comment"># 饼干 Index</span></span><br><span class="line">        </span><br><span class="line">        res = <span class="number">0</span>  <span class="comment"># result</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 也就是用局部的最优（当前孩子获得大于等于其胃口的饼干中大小最小的饼干），来达到全局最优（满意度最高）</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(g) - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>): <span class="comment"># n, n-1, n-2, ... 3, 2, 1, 0 遍历胃口值，小 -&gt; 大 排序。 </span></span><br><span class="line">            <span class="keyword">if</span> idx &gt;= <span class="number">0</span> <span class="keyword">and</span> s[idx] &gt;= g[i]:</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">                idx -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>



<h2 id="435-无重叠区间"><a href="#435-无重叠区间" class="headerlink" title="435. 无重叠区间"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/non-overlapping-intervals/">435. 无重叠区间</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eraseOverlapIntervals</span>(<span class="params">self, intervals: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># []</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> intervals:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 右边界排序</span></span><br><span class="line">        intervals.sort(key = <span class="keyword">lambda</span> x: x[<span class="number">1</span>])</span><br><span class="line">				</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        right = intervals[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">				<span class="comment"># 第二个区间开始</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(intervals)):</span><br><span class="line">            <span class="keyword">if</span> intervals[i][<span class="number">0</span>] &lt; right:</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = intervals[i][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>



<h2 id="452-用最少数量的箭引爆气球"><a href="#452-用最少数量的箭引爆气球" class="headerlink" title="452. 用最少数量的箭引爆气球"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/">452. 用最少数量的箭引爆气球</a></h2><ul>
<li>重叠区间求解</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMinArrowShots</span>(<span class="params">self, points: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> points:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        points.sort(key = <span class="keyword">lambda</span> x: x[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        res = <span class="built_in">len</span>(points)</span><br><span class="line">        right = points[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(points)):</span><br><span class="line">            <span class="keyword">if</span> points[i][<span class="number">0</span>] &lt;= right:</span><br><span class="line">                res -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = points[i][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> res </span><br></pre></td></tr></table></figure>



<h2 id="406-根据身高重建队列"><a href="#406-根据身高重建队列" class="headerlink" title="406. 根据身高重建队列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/">406. 根据身高重建队列</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reconstructQueue</span>(<span class="params">self, people: List[List[<span class="built_in">int</span>]]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        people.sort(key=<span class="keyword">lambda</span> x: (x[<span class="number">0</span>], -x[<span class="number">1</span>]), reverse=<span class="literal">True</span>)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> people:</span><br><span class="line">            res.insert(i[<span class="number">1</span>], i) <span class="comment"># insert(index, obj)</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>



<h2 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># 未获取合适结果默认返回0</span></span><br><span class="line">        ret = <span class="number">0</span></span><br><span class="line">        start = <span class="number">0</span> <span class="comment"># start 指针</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(prices)):</span><br><span class="line">            <span class="comment"># 当最小价格小于start指针切换至当前</span></span><br><span class="line">            <span class="keyword">if</span> prices[i] - prices[start] &lt; <span class="number">0</span>:</span><br><span class="line">                start = i</span><br><span class="line">            <span class="comment"># 每次比较最优抛售价格</span></span><br><span class="line">            ret = <span class="built_in">max</span>(prices[i] - prices[start], ret)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122. 买卖股票的最佳时机 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        ret = <span class="number">0</span></span><br><span class="line">        strat = <span class="number">0</span></span><br><span class="line">        profits = []</span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(prices)):</span><br><span class="line">            profits.append(prices[p] - prices[p-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> profits:</span><br><span class="line">            <span class="keyword">if</span> p &gt;= <span class="number">0</span>:</span><br><span class="line">                ret = ret + p</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>



<h2 id="605-种花问题"><a href="#605-种花问题" class="headerlink" title="605. 种花问题"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/can-place-flowers/">605. 种花问题</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canPlaceFlowers</span>(<span class="params">self, flowerbed: List[<span class="built_in">int</span>], n: <span class="built_in">int</span></span>) -&gt; bool:</span></span><br><span class="line">      	<span class="comment"># 添加哨兵</span></span><br><span class="line">        flower = [<span class="number">0</span>] + flowerbed + [<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> f <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(flower)-<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 跳过三个相邻的花盆中已种花</span></span><br><span class="line">            <span class="keyword">if</span> flower[f-<span class="number">1</span>] == <span class="number">1</span>: <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> flower[f] == <span class="number">1</span>: <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> flower[f+<span class="number">1</span>] == <span class="number">1</span>: <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            flower[f] = <span class="number">1</span></span><br><span class="line">            n = n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>



<h2 id="392-判断子序列"><a href="#392-判断子序列" class="headerlink" title="392. 判断子序列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/is-subsequence/">392. 判断子序列</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubsequence</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        t = <span class="built_in">iter</span>(t)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">all</span>(i <span class="keyword">in</span> t <span class="keyword">for</span> i <span class="keyword">in</span> s) </span><br></pre></td></tr></table></figure>



<h2 id="665-非递减数列"><a href="#665-非递减数列" class="headerlink" title="665. 非递减数列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/non-decreasing-array/">665. 非递减数列</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkPossibility</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; bool:</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; nums[i+<span class="number">1</span>]:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> cnt &gt; <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">                <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i+<span class="number">1</span>] &lt; nums[i-<span class="number">1</span>]:</span><br><span class="line">                    nums[i+<span class="number">1</span>] = nums[i]</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53. 最大子序和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-subarray/">53. 最大子序和</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        max_value = nums[<span class="number">0</span>]</span><br><span class="line">        pre = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            pre = <span class="built_in">max</span>(pre + nums[i], nums[i])</span><br><span class="line">            max_value = <span class="built_in">max</span>(pre, max_value)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max_value</span><br></pre></td></tr></table></figure>



<h2 id="763-划分字母区间"><a href="#763-划分字母区间" class="headerlink" title="763. 划分字母区间"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/partition-labels/">763. 划分字母区间</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partitionLabels</span>(<span class="params">self, S: <span class="string">&quot;str&quot;</span></span>) -&gt; &quot;list[int]&quot;:</span></span><br><span class="line">        maxIndex = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="comment"># 记录每个字符最后的位置</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(S)):</span><br><span class="line">            maxIndex[S[i]] = i <span class="comment"># 通过更新字典</span></span><br><span class="line"></span><br><span class="line">        ans = <span class="built_in">list</span>()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 当前片段开始位置和结束位置</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        end = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历整个字符串S，寻找所有合适的解</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(S)):</span><br><span class="line">            end = <span class="built_in">max</span>(maxIndex[S[i]], end)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> i == end:</span><br><span class="line">                ans.append(end - start + <span class="number">1</span>)</span><br><span class="line">                start = end + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="1221-分割平衡字符串"><a href="#1221-分割平衡字符串" class="headerlink" title="1221. 分割平衡字符串"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/split-a-string-in-balanced-strings/">1221. 分割平衡字符串</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">balancedStringSplit</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> ch == <span class="string">&#x27;L&#x27;</span>:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> ch == <span class="string">&#x27;R&#x27;</span>:</span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> left == right:</span><br><span class="line">                ans += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="1402-做菜顺序"><a href="#1402-做菜顺序" class="headerlink" title="1402. 做菜顺序"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reducing-dishes/">1402. 做菜顺序</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSatisfaction</span>(<span class="params">self, satisfaction: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        satisfaction.sort(reverse=<span class="literal">True</span>)</span><br><span class="line">        presum, ans = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> si <span class="keyword">in</span> satisfaction:</span><br><span class="line">            <span class="keyword">if</span> presum + si &gt; <span class="number">0</span>:</span><br><span class="line">                presum += si</span><br><span class="line">                ans += presum</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>



<h1 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h1><p>二分查找也称为折半查找，每次都能将查找区间减半，这种折半特性的算法时间复杂度为 O(logN)。</p>
<p><strong>m 计算</strong></p>
<p>有两种计算中值 m 的方式：</p>
<ul>
<li>m = (l + h) / 2</li>
<li>m = l + (h - l) / 2</li>
</ul>
<p>l + h 可能出现加法溢出，也就是说加法的结果大于整型能够表示的范围。但是 l 和 h 都为正数，因此 h - l 不会出现加法溢出问题。所以，最好使用第二种计算法方法。</p>
<h2 id="解题模版"><a href="#解题模版" class="headerlink" title="解题模版"></a>解题模版</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 模版一</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">nums: List[<span class="built_in">int</span>], left: <span class="built_in">int</span>, right: <span class="built_in">int</span>, target: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        <span class="comment"># 选择中位数时下取整，防止加法溢出</span></span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> check(mid):</span><br><span class="line">            <span class="comment"># 下一轮搜索区间是 [mid + 1, right]</span></span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 下一轮搜索区间是 [left, mid]</span></span><br><span class="line">            right = mid</span><br><span class="line">    <span class="comment"># 退出循环的时候，程序只剩下一个元素没有看到。</span></span><br><span class="line">    <span class="comment"># 视情况，是否需要单独判断 left（或者 right）这个下标的元素是否符合题意</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 模版二    </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">nums: List[<span class="built_in">int</span>], left: <span class="built_in">int</span>, right: <span class="built_in">int</span>, target: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">    <span class="keyword">while</span> left + <span class="number">1</span> &lt; right:</span><br><span class="line">        <span class="comment"># 选择中位数时下取整</span></span><br><span class="line">        mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> nums[left] == target:</span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line">    <span class="keyword">if</span> nums[right] == target:</span><br><span class="line">        <span class="keyword">return</span> right</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>



<h2 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35. 搜索插入位置"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/search-insert-position/">35. 搜索插入位置</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = n</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">                left = mid + <span class="number">1</span>  <span class="comment"># [mid + 1, right]</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid     <span class="comment"># [left, mid]    </span></span><br><span class="line">        <span class="keyword">return</span> left </span><br></pre></td></tr></table></figure>



<h2 id="69-x-的平方根"><a href="#69-x-的平方根" class="headerlink" title="69. x 的平方根"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sqrtx/">69. x 的平方根</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">1</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        left = <span class="number">1</span></span><br><span class="line">        right = x</span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left + (right - left)//<span class="number">2</span> <span class="comment"># mid</span></span><br><span class="line">            <span class="keyword">if</span> mid * mid == x:</span><br><span class="line">              <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> mid * mid &gt; x:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> right</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 解法二</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        left, right = <span class="number">1</span>, x // <span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left + (right - left + <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">            <span class="comment"># 不使用 mid * mid &gt; x，防止 overflow</span></span><br><span class="line">            <span class="comment"># Python 使用 BigInteger，所以不用担心溢出，但还是推荐使用如下形式</span></span><br><span class="line">            <span class="keyword">if</span> mid &gt; x // mid:</span><br><span class="line">                <span class="comment"># 下一轮搜索的区间是 [left, mid - 1]</span></span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 下一轮搜索的区间是 [mid, right]</span></span><br><span class="line">                left = mid</span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>



<h2 id="875-爱吃香蕉的珂珂"><a href="#875-爱吃香蕉的珂珂" class="headerlink" title="875. 爱吃香蕉的珂珂"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/koko-eating-bananas/">875. 爱吃香蕉的珂珂</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minEatingSpeed</span>(<span class="params">self, piles: List[<span class="built_in">int</span>], H: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        maxVal = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> pile <span class="keyword">in</span> piles:</span><br><span class="line">            maxVal = <span class="built_in">max</span>(maxVal, pile)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 速度最小的时候，耗时最长</span></span><br><span class="line">        left = <span class="number">1</span></span><br><span class="line">        <span class="comment"># 速度最大的时候，耗时最短</span></span><br><span class="line">        right = maxVal</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.calculateSum(piles, mid) &gt; H:</span><br><span class="line">                <span class="comment"># 耗时太多，说明速度太慢了，下一轮搜索区间在</span></span><br><span class="line">                <span class="comment"># [mid + 1, right]</span></span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid</span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculateSum</span>(<span class="params">self, piles: List[<span class="built_in">int</span>], speed: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;如果返回的小时数严格大于 H，就不符合题意</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            piles:</span></span><br><span class="line"><span class="string">            speed:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            需要的小时数</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> pile <span class="keyword">in</span> piles:</span><br><span class="line">            <span class="comment"># 上取整可以这样写</span></span><br><span class="line">            <span class="built_in">sum</span> += (pile + speed - <span class="number">1</span>) // speed</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span></span><br></pre></td></tr></table></figure>





<h2 id="744-寻找比目标字母大的最小字母"><a href="#744-寻找比目标字母大的最小字母" class="headerlink" title="744. 寻找比目标字母大的最小字母"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/">744. 寻找比目标字母大的最小字母</a></h2><ul>
<li>若target大于letters里面的所有元素，那么退出循环时候left就会指向索引为len(letters)的位置，所以我们通过取余操作达到循环的效果。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextGreatestLetter</span>(<span class="params">self, letters: List[<span class="built_in">str</span>], target: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(letters) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> letters[mid] &lt;= target:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> letters[mid] &gt; target:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> letters[left % <span class="built_in">len</span>(letters)]</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="540-有序数组中的单一元素"><a href="#540-有序数组中的单一元素" class="headerlink" title="540. 有序数组中的单一元素"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/single-element-in-a-sorted-array/">540. 有序数组中的单一元素</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNonDuplicate</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        </span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left + (right - left )//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> mid % <span class="number">2</span> == <span class="number">1</span>: <span class="comment"># mid 奇数，左移一位</span></span><br><span class="line">                mid -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == nums[mid+<span class="number">1</span>]:</span><br><span class="line">                left = mid + <span class="number">2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid</span><br><span class="line">        <span class="keyword">return</span> nums[left]</span><br></pre></td></tr></table></figure>

<ul>
<li>异或</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNonDuplicate</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">            res ^= x</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>



<h2 id="278-第一个错误的版本"><a href="#278-第一个错误的版本" class="headerlink" title="278. 第一个错误的版本"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/first-bad-version/">278. 第一个错误的版本</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The isBadVersion API is already defined for you.</span></span><br><span class="line"><span class="comment"># @param version, an integer</span></span><br><span class="line"><span class="comment"># @return an integer</span></span><br><span class="line"><span class="comment"># def isBadVersion(version):</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstBadVersion</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        left = <span class="number">1</span></span><br><span class="line">        right = n</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> n ==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid =left + (right - left)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> isBadVersion(mid):</span><br><span class="line">                right = mid </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>



<h2 id="153-寻找旋转排序数组中的最小值"><a href="#153-寻找旋转排序数组中的最小值" class="headerlink" title="153. 寻找旋转排序数组中的最小值"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">153. 寻找旋转排序数组中的最小值</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># [3,4,5,1,2]</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMin</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">       </span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; nums[right]:</span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nums[left]</span><br></pre></td></tr></table></figure>



<h2 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchRange</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[int]:</span></span><br><span class="line">      </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">binarysearchleft</span>(<span class="params">nums, target</span>):</span></span><br><span class="line">            left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">                mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> nums[mid] &gt;= target:</span><br><span class="line">                    right = mid -<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">          </span><br><span class="line">        start = binarysearchleft(nums, target)</span><br><span class="line">        end = binarysearchleft(nums, target + <span class="number">1</span>) - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> start == <span class="built_in">len</span>(nums) <span class="keyword">or</span> nums[start] != target:</span><br><span class="line">            <span class="keyword">return</span> [-<span class="number">1</span>, -<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> [start, end]</span><br></pre></td></tr></table></figure>



<h2 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, nums, target</span>):</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> nums[left] &lt;= nums[mid]:</span><br><span class="line">                <span class="keyword">if</span> nums[left] &lt;= target &lt; nums[mid]:</span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[mid] &lt; target &lt;= nums[right]:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>



<h2 id="287-寻找重复数"><a href="#287-寻找重复数" class="headerlink" title="287. 寻找重复数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-the-duplicate-number/">287. 寻找重复数</a></h2><ul>
<li><strong>抽屉原理</strong>：“如果每个<strong>抽屉</strong>代表一个集合，每一个苹果就可以代表一个元素，假如有n+1个元素放到n个集合中去，其中必定有一个集合里至少有两个元素。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findDuplicate</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment">#二分法</span></span><br><span class="line">        left = <span class="number">1</span></span><br><span class="line">        right = <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">if</span> num &lt;= mid:</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> count &gt; mid:</span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>



<h2 id="410-分割数组的最大值"><a href="#410-分割数组的最大值" class="headerlink" title="410. 分割数组的最大值"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/split-array-largest-sum/">410. 分割数组的最大值</a></h2><ul>
<li>查找范围：二分查找的范围是<code>[max(数组), sum(数组)]</code></li>
<li>查找思路：<ul>
<li>假设这个中点 mid 就是 “每一个数组和中的最大值” 的最小值<br>  那么每一个数组和必定 &lt;=mid，你用这个值来对数组进行从头分割，一旦当前数组和&gt;mid,就结束该数组，开启一个新数组<br>  如果你用这个mid创建的数组数量，比m还多，说明你这个值定小了，所以二分查找取哪一半？右半！<br>  如果你用这个mid创建的数组数量，比m少了，说明你这个值定大了，所以二分查找取哪一半？左半！</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">splitArray</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], m: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="comment">#二分查找</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#指定二分查找范围</span></span><br><span class="line">        left, right = <span class="built_in">max</span>(nums), <span class="built_in">sum</span>(nums)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#定义 测试中点是大还是小的 测试函数</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">test_mid</span>(<span class="params">mid</span>):</span></span><br><span class="line">            <span class="comment">#初始化</span></span><br><span class="line">            num = <span class="number">1</span> <span class="comment">#num表示使用该mid我们会得到几个数组</span></span><br><span class="line">            s = <span class="number">0</span> <span class="comment">#s表示当前数组的和</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">if</span> s+i &gt; mid: <span class="comment">#如果当前数组已经超过mid，要停止这个数组</span></span><br><span class="line">                    s = i <span class="comment">#这个数变为下一个数组的开头</span></span><br><span class="line">                    num += <span class="number">1</span> <span class="comment">#会得到的数组数量+1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    s += i</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> num &gt; m <span class="comment">#数组总数是否&gt;m, 大于的话说明mid太小，二分查找取右边</span></span><br><span class="line">            <span class="comment">#这里有一个注意点，如果num已经等于m了, 但此时如果left不等于right，范围还是会继续收敛的，</span></span><br><span class="line">            <span class="comment">#且取的是左半边，目的是让我们能最终找到一个确切的值，这个值恰好就是取得了最大值的那个数组的和</span></span><br><span class="line">            <span class="comment">#(因为小于这个和的话，就不能通过num=m的测试；而大于这个m的话，即使通过了num=m的测试，</span></span><br><span class="line">            <span class="comment">#范围也会继续向左边收敛，直到我们找到的就是这个和)。</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#进行二分查找</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right: <span class="comment">#当left == right的时候就终止查找，返回任意一个</span></span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            if_right = test_mid(mid)</span><br><span class="line">            <span class="keyword">if</span> if_right:</span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid <span class="comment">#num &lt;= m的情况</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>





<h1 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h1><h2 id="241-为运算表达式设计优先级"><a href="#241-为运算表达式设计优先级" class="headerlink" title="241. 为运算表达式设计优先级"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/different-ways-to-add-parentheses/">241. 为运算表达式设计优先级</a></h2><p><strong>分治算法三步走</strong>：</p>
<ol>
<li>分解：按运算符分成左右两部分，分别求解</li>
<li>解决：实现一个递归函数，输入算式，返回算式解</li>
<li>合并：根据运算符合并左右两部分的解，得出最终解</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">diffWaysToCompute</span>(<span class="params">self, <span class="built_in">input</span>: <span class="built_in">str</span></span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="comment"># 如果只有数字，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">input</span>.isdigit():</span><br><span class="line">            <span class="keyword">return</span> [<span class="built_in">int</span>(<span class="built_in">input</span>)]</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i, char <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">input</span>):</span><br><span class="line">            <span class="keyword">if</span> char <span class="keyword">in</span> [<span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;*&#x27;</span>]:</span><br><span class="line">                <span class="comment"># 1.分解：遇到运算符，计算左右两侧的结果集</span></span><br><span class="line">                <span class="comment"># 2.解决：diffWaysToCompute 递归函数求出子问题的解</span></span><br><span class="line">                left = self.diffWaysToCompute(<span class="built_in">input</span>[:i])</span><br><span class="line">                right = self.diffWaysToCompute(<span class="built_in">input</span>[i+<span class="number">1</span>:])</span><br><span class="line">                <span class="comment"># 3.合并：根据运算符合并子问题的解</span></span><br><span class="line">                <span class="keyword">for</span> l <span class="keyword">in</span> left:</span><br><span class="line">                    <span class="keyword">for</span> r <span class="keyword">in</span> right:</span><br><span class="line">                        <span class="keyword">if</span> char == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                            res.append(l + r)</span><br><span class="line">                        <span class="keyword">elif</span> char == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                            res.append(l - r)</span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            res.append(l * r)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res </span><br></pre></td></tr></table></figure>



<h2 id="95-不同的二叉搜索树-II"><a href="#95-不同的二叉搜索树-II" class="headerlink" title="95. 不同的二叉搜索树 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/">95. 不同的二叉搜索树 II</a></h2><ul>
<li>二叉搜索树（BST）又称<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/7077965">二叉查找树</a>或<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/10905079">二叉排序树</a>。其特点如下：设x为二叉查找树中的一个结点，x节点包含关键字key，一句话就是左孩子比父节点小，右孩子比父节点大，还有一个特性就是”中序遍历“可以让结点有序。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">思路：分治</span></span><br><span class="line"><span class="string">以整数区间a..b中每一个元组作为子树的根节点，另外的元素作为左右子树，</span></span><br><span class="line"><span class="string">递归生成左右子树的后，根节点与左右子树进行组合</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">时间复杂度：x， O(2^n)&lt; x &lt;O(n!)</span></span><br><span class="line"><span class="string">空间复杂度：O(n)，最大递归深度n</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateTrees</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; List[TreeNode]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">makeTree</span>(<span class="params">start, end</span>):</span></span><br><span class="line">            ans = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, end):</span><br><span class="line">                leftTrees, rightTrees = [<span class="literal">None</span>], [<span class="literal">None</span>]</span><br><span class="line">                <span class="keyword">if</span> i &gt; start:</span><br><span class="line">                    leftTrees = makeTree(start, i)</span><br><span class="line">                <span class="keyword">if</span> i &lt; end - <span class="number">1</span>:</span><br><span class="line">                    rightTrees = makeTree(i + <span class="number">1</span>, end)</span><br><span class="line">                <span class="keyword">for</span> leftTree <span class="keyword">in</span> leftTrees:</span><br><span class="line">                    <span class="keyword">for</span> rightTree <span class="keyword">in</span> rightTrees:</span><br><span class="line">                        node = TreeNode(i, leftTree, rightTree)</span><br><span class="line">                        ans.append(node)</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> makeTree(<span class="number">1</span>, n + <span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h1><p>深度优先搜索和广度优先搜索广泛运用于树和图中</p>
<h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><ul>
<li> BFS：广度优先 (Breadth first search, BFS)</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gu01l8sllfj606m076t8p02.jpg"></p>
<p>广度优先搜索一层一层地进行遍历，每层遍历都是以上一层遍历的结果作为起点，遍历一个距离能访问到的所有节点。需要注意的是，遍历过的节点不能再次被遍历。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gu0e7vr8qaj60ej0603yj02.jpg"></p>
<p>第一层：</p>
<ul>
<li>0 -&gt; {6,2,1,5}</li>
</ul>
<p>第二层：</p>
<ul>
<li>6 -&gt; {4}</li>
<li>2 -&gt; {}</li>
<li>1 -&gt; {}</li>
<li>5 -&gt; {3}</li>
</ul>
<p>第三层：</p>
<ul>
<li>4 -&gt; {}</li>
<li>3 -&gt; {}</li>
</ul>
<h3 id="Baseline"><a href="#Baseline" class="headerlink" title="Baseline"></a>Baseline</h3><p><strong>BFS 算法组成的 3 元素：</strong>队列，入队出队的节点，已访问的集合。</p>
<ul>
<li><p>队列：先入先出的容器；</p>
</li>
<li><p>节点：最好写成单独的类，比如本例写成 <code>(value, step)</code> 元组。也可写成<code> (value, visited)</code>，看自己喜好和题目；</p>
</li>
<li><p>已访问集合：为了避免队列中插入重复的值</p>
</li>
</ul>
<p><strong>BFS算法组成的套路：</strong></p>
<ol>
<li><p>初始化三元素：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">队列      Node = node(n) </span><br><span class="line"></span><br><span class="line">节点      queue = [Node] </span><br><span class="line"></span><br><span class="line">已访问集合 visited = <span class="built_in">set</span>([Node.value])</span><br></pre></td></tr></table></figure></li>
<li><p>操作队列 — 弹出队首节点：<br><code>vertex = queue.pop(0)</code></p>
</li>
<li><p>操作弹出的节点 — 根据业务生成子节点（一个或多个）：<br><code>[node(vertex.value - n*n, Node.step+1) for n in range(1,int(vertex.value**.5)+1)]</code></p>
</li>
<li><p>判断这些节点 —符合业务条件，则return，不符合业务条件，且不在已访问集合，则追加到队尾，并加入已访问集合：</p>
</li>
</ol>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> i==<span class="number">0</span>:                   </span><br><span class="line">	  <span class="keyword">return</span> new_vertex.step</span><br><span class="line"><span class="keyword">elif</span> i <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">	  queue.append(new_vertex)</span><br><span class="line">	  visited.add(i)</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>若以上遍历完成仍未<code>return</code>，下面操作返回未找到代码：<br><code>return -1</code></li>
</ol>
<h3 id="1091-二进制矩阵中的最短路径"><a href="#1091-二进制矩阵中的最短路径" class="headerlink" title="1091. 二进制矩阵中的最短路径"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shortest-path-in-binary-matrix/">1091. 二进制矩阵中的最短路径</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shortestPathBinaryMatrix</span>(<span class="params">self, grid: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> deque <span class="comment"># 队列</span></span><br><span class="line">        n = <span class="built_in">len</span>(grid)</span><br><span class="line">        <span class="keyword">if</span> grid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span> <span class="keyword">or</span> grid[n - <span class="number">1</span>][n - <span class="number">1</span>] == <span class="number">1</span>:  <span class="comment"># 若起始点或终点堵塞，则不可能有这样的路径</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        res = <span class="number">1</span>  <span class="comment"># 注意题目的描述，是返回从 1 到 k 的路径，第一个节点被定为下标 1，</span></span><br><span class="line">        path = deque()</span><br><span class="line">        path.append([<span class="number">0</span>, <span class="number">0</span>])  <span class="comment"># 先压入起点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># BFS模板</span></span><br><span class="line">        <span class="keyword">while</span> path:  </span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(path)):  <span class="comment"># 对BFS的某一层的中所有点向8个方向进行扩展</span></span><br><span class="line">                x, y = path.popleft() <span class="comment"># 弹出第一个元素</span></span><br><span class="line">                <span class="keyword">for</span> new_x, new_y <span class="keyword">in</span> [[x - <span class="number">1</span>, y - <span class="number">1</span>], [x - <span class="number">1</span>, y], [x - <span class="number">1</span>, y + <span class="number">1</span>], [x, y - <span class="number">1</span>],</span><br><span class="line">                                     [x, y + <span class="number">1</span>], [x + <span class="number">1</span>, y - <span class="number">1</span>], [x + <span class="number">1</span>, y], [x + <span class="number">1</span>, y + <span class="number">1</span>]]:</span><br><span class="line">                    <span class="comment"># 下面几种continue可以合并一行，这里为看的清楚就分开写了</span></span><br><span class="line">                    <span class="keyword">if</span> new_x == n - <span class="number">1</span> <span class="keyword">and</span> new_y == n - <span class="number">1</span>:  <span class="comment"># 如果扩展的点到达了终点</span></span><br><span class="line">                        <span class="keyword">return</span> res + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> <span class="number">0</span> &lt;= new_x &lt; n <span class="keyword">or</span> <span class="keyword">not</span> <span class="number">0</span> &lt;= new_y &lt; n:  <span class="comment"># 扩展的点超出边界，则跳过</span></span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">if</span> grid[new_x][new_y] == <span class="number">1</span>:  <span class="comment"># 若扩展的点为阻塞，则跳过</span></span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">if</span> grid[new_x][new_y] == -<span class="number">1</span>:  <span class="comment"># 若扩展的点已经访问过，则跳过</span></span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">if</span> grid[new_x][new_y] == <span class="number">0</span>:  <span class="comment"># 若为通畅点</span></span><br><span class="line">                        grid[new_x][new_y] = -<span class="number">1</span>  <span class="comment"># 当前层次下已经访问该点</span></span><br><span class="line">                        path.append([new_x, new_y])  <span class="comment"># 将扩展的点加入path，到下一层的时候继续扩展</span></span><br><span class="line">            res += <span class="number">1</span>  <span class="comment"># 对某一层的元素都求判定过后，距离加1(同一个层次中的所有点的距离距离起点都是相等的）</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279. 完全平方数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/perfect-squares/">279. 完全平方数</a></h3><p><img src="https://pic.leetcode-cn.com/1618493683-GOwVrO-image.png" alt="image.png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSquares</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        ps = [i * i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">int</span>(n**<span class="number">0.5</span>)+<span class="number">1</span>)][::-<span class="number">1</span>] <span class="comment"># 从大到小减去，帮助加速</span></span><br><span class="line">        pset = <span class="built_in">set</span>(ps) <span class="comment"># set</span></span><br><span class="line">        queue, cache = [n], &#123;n:<span class="number">1</span>&#125;</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            val = queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> val <span class="keyword">in</span> pset: <span class="keyword">return</span> cache[val]</span><br><span class="line">            <span class="keyword">for</span> p <span class="keyword">in</span> ps:</span><br><span class="line">                <span class="keyword">if</span> val-p &gt; <span class="number">0</span> <span class="keyword">and</span> val-p <span class="keyword">not</span> <span class="keyword">in</span> cache:</span><br><span class="line">                    queue.append(val-p)</span><br><span class="line">                    cache[val-p] = cache[val] + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="127-单词接龙"><a href="#127-单词接龙" class="headerlink" title="127. 单词接龙"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/word-ladder/">127. 单词接龙</a></h3><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/word-ladder/solution/python-shen-du-jiang-jie-bfsde-jie-gou-by-allen-23/">https://leetcode-cn.com/problems/word-ladder/solution/python-shen-du-jiang-jie-bfsde-jie-gou-by-allen-23/</a></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="comment"># defaultdict与普通dict的最大作用在于：</span></span><br><span class="line"><span class="comment">## 可以直接call一个不存在的key， 如果不存在这个key，那就先直接创建这个key，并根据默认值的设置，赋值value，而后在继续操作。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ladderLength</span>(<span class="params">self, beginWord, endWord, wordList</span>):</span></span><br><span class="line">        <span class="comment"># 建立通用list, </span></span><br><span class="line">        size, general_dic = <span class="built_in">len</span>(beginWord), defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> wordList:</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">                general_dic[w[:_]+<span class="string">&quot;*&quot;</span>+w[_+<span class="number">1</span>:]].append(w)</span><br><span class="line">        <span class="comment"># BFS</span></span><br><span class="line">        queue = deque()</span><br><span class="line">        queue.append((beginWord, <span class="number">1</span>))  <span class="comment"># 因为在BFS中，queue中通常会同时混合多层的node，这就无法区分层了，要区分层就要queue中直接加入当前node所属层数。</span></span><br><span class="line">        mark_dic = defaultdict(<span class="built_in">bool</span>)  <span class="comment"># bool 的默认值是false，因此所有不在list里的是false</span></span><br><span class="line">        mark_dic[beginWord] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            cur_word, level = queue.popleft()   <span class="comment"># queue头出来一个</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):               <span class="comment"># 找邻居，这里的所有邻居都在level+1层</span></span><br><span class="line">                <span class="keyword">for</span> neighbour <span class="keyword">in</span> general_dic[cur_word[:i]+<span class="string">&quot;*&quot;</span>+cur_word[i+<span class="number">1</span>:]]:</span><br><span class="line">                    <span class="keyword">if</span> neighbour == endWord: <span class="keyword">return</span> level + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> mark_dic[neighbour]:</span><br><span class="line">                        mark_dic[neighbour] = <span class="literal">True</span></span><br><span class="line">                        queue.append((neighbour, level+<span class="number">1</span>))  <span class="comment">#符合条件（neighbour + unmarked)的进去</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><h3 id="695-岛屿的最大面积"><a href="#695-岛屿的最大面积" class="headerlink" title="695. 岛屿的最大面积"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/max-area-of-island/">695. 岛屿的最大面积</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxAreaOfIsland</span>(<span class="params">self, grid: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line"></span><br><span class="line">        m = <span class="built_in">len</span>(grid)</span><br><span class="line">        n = <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">0</span>: </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">i, j</span>):</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span> <span class="keyword">or</span> i &gt;= m) <span class="keyword">or</span> (j &lt; <span class="number">0</span> <span class="keyword">or</span> j &gt;= n):</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> grid[i][j] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            grid[i][j] = <span class="number">0</span></span><br><span class="line">            top = dfs(i+<span class="number">1</span>, j)</span><br><span class="line">            bottom = dfs(i-<span class="number">1</span>, j)</span><br><span class="line">            left = dfs(i, j-<span class="number">1</span>)</span><br><span class="line">            right = dfs(i, j+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">sum</span>([top, bottom, left, right])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, dfs(i, j))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-islands/">200. 岛屿数量</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">输入：grid = [</span></span><br><span class="line"><span class="string">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span></span><br><span class="line"><span class="string">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span></span><br><span class="line"><span class="string">  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span></span><br><span class="line"><span class="string">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">输出：3</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numIslands</span>(<span class="params">self, grid: List[List[<span class="built_in">str</span>]]</span>) -&gt; int:</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        ans = <span class="number">0</span> </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">i, j</span>):</span></span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> i &gt;= m <span class="keyword">or</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> j &gt;= n:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> grid[i][j] == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            grid[i][j] = <span class="string">&#x27;0&#x27;</span> <span class="comment"># 遍历后置为 0</span></span><br><span class="line">            top = dfs(i+<span class="number">1</span>, j)</span><br><span class="line">            bottom = dfs(i-<span class="number">1</span>, j)</span><br><span class="line">            left = dfs(i, j-<span class="number">1</span>)</span><br><span class="line">            right = dfs(i, j+<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                    dfs(i, j)</span><br><span class="line">                    ans += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="130-被围绕的区域"><a href="#130-被围绕的区域" class="headerlink" title="130. 被围绕的区域"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/surrounded-regions/">130. 被围绕的区域</a></h3><p>我们只要找到四周边界上存在O且与这些O连接着的O，在搜索时先修改成其他字母，比如“#”。<br>然后遍历二维矩阵，将为O修改为X，将#修改为O即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solve</span>(<span class="params">self, board: List[List[<span class="built_in">str</span>]]</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> board:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        n, m = <span class="built_in">len</span>(board), <span class="built_in">len</span>(board[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">x, y</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="number">0</span> &lt;= x &lt; n <span class="keyword">or</span> <span class="keyword">not</span> <span class="number">0</span> &lt;= y &lt; m <span class="keyword">or</span> board[x][y] != <span class="string">&#x27;O&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            board[x][y] = <span class="string">&quot;A&quot;</span></span><br><span class="line">            dfs(x + <span class="number">1</span>, y)</span><br><span class="line">            dfs(x - <span class="number">1</span>, y)</span><br><span class="line">            dfs(x, y + <span class="number">1</span>)</span><br><span class="line">            dfs(x, y - <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            dfs(i, <span class="number">0</span>)</span><br><span class="line">            dfs(i, m - <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m - <span class="number">1</span>):</span><br><span class="line">            dfs(<span class="number">0</span>, i)</span><br><span class="line">            dfs(n - <span class="number">1</span>, i)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="string">&quot;A&quot;</span>:</span><br><span class="line">                    board[i][j] = <span class="string">&quot;O&quot;</span></span><br><span class="line">                <span class="keyword">elif</span> board[i][j] == <span class="string">&quot;O&quot;</span>:</span><br><span class="line">                    board[i][j] = <span class="string">&quot;X&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="417-太平洋大西洋水流问题"><a href="#417-太平洋大西洋水流问题" class="headerlink" title="417. 太平洋大西洋水流问题"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/pacific-atlantic-water-flow/">417. 太平洋大西洋水流问题</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pacificAtlantic</span>(<span class="params">self, heights</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type heights: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 双BFS</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">bfs</span>(<span class="params">r, c, visited</span>):</span></span><br><span class="line">            queue = [(r, c)]</span><br><span class="line">            visited.add((r, c))</span><br><span class="line">            <span class="keyword">while</span> queue:</span><br><span class="line">                r, c = queue.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">for</span> x, y <span class="keyword">in</span> [(-<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, -<span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>)]:</span><br><span class="line">                    br, bc = r + x, c + y</span><br><span class="line">                    <span class="keyword">if</span> <span class="number">0</span> &lt;= br &lt; row <span class="keyword">and</span> <span class="number">0</span> &lt;= bc &lt; col <span class="keyword">and</span> heights[br][bc] &gt;= heights[r][c] <span class="keyword">and</span> (br, bc) <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                        queue.append((br, bc))</span><br><span class="line">                        visited.add((br, bc))</span><br><span class="line">        res = []</span><br><span class="line">        row = <span class="built_in">len</span>(heights)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> row: <span class="keyword">return</span> res</span><br><span class="line">        col = <span class="built_in">len</span>(heights[<span class="number">0</span>])</span><br><span class="line">        </span><br><span class="line">        visited_taiping = <span class="built_in">set</span>()     <span class="comment"># 存放能流入太平洋的坐标</span></span><br><span class="line">        visited_daxi = <span class="built_in">set</span>()        <span class="comment"># 存放能流入大西洋的坐标</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(row):</span><br><span class="line">            bfs(r, <span class="number">0</span>, visited_taiping)</span><br><span class="line">            bfs(r, col - <span class="number">1</span>, visited_daxi)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(col):</span><br><span class="line">            bfs(<span class="number">0</span>, c, visited_taiping)</span><br><span class="line">            bfs(row - <span class="number">1</span>, c, visited_daxi)</span><br><span class="line">            </span><br><span class="line">        res = <span class="built_in">list</span>(visited_taiping &amp; visited_daxi) <span class="comment"># 与</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>



<h2 id="Backtracking（回溯）"><a href="#Backtracking（回溯）" class="headerlink" title="Backtracking（回溯）"></a>Backtracking（回溯）</h2><ul>
<li>普通 DFS 主要用在 <strong>可达性问题</strong> ，这种问题只需要执行到特点的位置然后返回即可。</li>
<li>而 Backtracking 主要用于求解 <strong>排列组合</strong> 问题，例如有 { ‘a’,’b’,’c’ } 三个字符，求解所有由这三个字符排列得到的字符串，这种问题在执行到特定的位置返回之后还会继续执行求解过程。</li>
</ul>
<p>因为 Backtracking 不是立即返回，而要继续求解，因此在程序实现时，需要注意对元素的标记问题：</p>
<ul>
<li>在访问一个新元素进入新的递归调用时，需要将新元素标记为已经访问，这样才能在继续递归调用时不用重复访问该元素；</li>
<li>但是在递归返回时，需要将元素标记为未访问，因为只需要保证在一个递归链中不同时访问一个元素，可以访问已经访问过但是不在当前递归链中的元素。</li>
</ul>
<h3 id="模板1"><a href="#模板1" class="headerlink" title="模板1"></a>模板1</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">res = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">路径, 选择列表</span>):</span></span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        res.append(路径)</span><br><span class="line">        <span class="keyword">return</span>  </span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> 满足剪枝条件：</span><br><span class="line">    	<span class="keyword">return</span></span><br><span class="line">    	</span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure>

<h3 id="t模板2"><a href="#t模板2" class="headerlink" title="t模板2"></a>t模板2</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">res = []</span><br><span class="line">path = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">未探索区域, res, path</span>):</span></span><br><span class="line">    <span class="keyword">if</span> path 满足条件:</span><br><span class="line">        res.add(path) <span class="comment"># 深度拷贝</span></span><br><span class="line">        <span class="comment"># return  # 如果不用继续搜索需要 return</span></span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 未探索区域当前可能的选择:</span><br><span class="line">        <span class="keyword">if</span> 当前选择符合要求:</span><br><span class="line">            path.add(当前选择)</span><br><span class="line">            backtrack(新的未探索区域, res, path)</span><br><span class="line">            path.pop()</span><br></pre></td></tr></table></figure>



<h3 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gudrmzy0fyj615q0e6wge02.jpg"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span>(<span class="params">self, digits: <span class="built_in">str</span></span>) -&gt; List[str]:</span></span><br><span class="line">        <span class="comment">#数字对应的英 [0     1     2      3      4      5      6      7       8      9]</span></span><br><span class="line">        word_list = [<span class="string">&quot;0&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>, <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#如果是空字符串直接返回空列表</span></span><br><span class="line">        <span class="keyword">if</span> digits == <span class="string">&quot;&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#保存结果列表</span></span><br><span class="line">        result = []</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#输入的digits的长度，作为回溯函数返回的判断条件</span></span><br><span class="line">        lenth = <span class="built_in">len</span>(digits)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#回溯函数（path当前路径，默认为&quot;&quot;）</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">back_trac</span> <span class="title">k</span>(<span class="params">digits, index, path</span>):</span></span><br><span class="line">            <span class="comment">#如果目前path的长度和digits的长度相等，说明已经遍历完一趟，返回结果列表</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(path) == lenth:</span><br><span class="line">                <span class="comment">#加入result列表</span></span><br><span class="line">                result.append(path)</span><br><span class="line">                <span class="comment">#返回</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">#遍历当前索引的数字对应的英文列表</span></span><br><span class="line">            <span class="keyword">for</span> word <span class="keyword">in</span> word_list[<span class="built_in">int</span>(digits[index])]: <span class="comment"># [0 1 2 3 4 5 6 7 8 9]</span></span><br><span class="line">                <span class="comment">#路径加上当前字母  </span></span><br><span class="line">                path = path + word</span><br><span class="line">                <span class="comment">#递归下一个数字对应的英文列表 ad ae af</span></span><br><span class="line">                back_track(digits, index + <span class="number">1</span>, path)</span><br><span class="line">                </span><br><span class="line">                <span class="comment">#撤销当前字母, ad ae af --&gt; a</span></span><br><span class="line">                path = path[:-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        back_track(digits, <span class="number">0</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h3 id="93-复原-IP-地址"><a href="#93-复原-IP-地址" class="headerlink" title="93. 复原 IP 地址"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/restore-ip-addresses/">93. 复原 IP 地址</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">restoreIpAddresses</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; List[str]:</span></span><br><span class="line">        <span class="comment">#结果存储函数</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="comment">#当前路径</span></span><br><span class="line">        path = []</span><br><span class="line">        <span class="comment">#回溯函数</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">back_track</span>(<span class="params">s, index</span>):</span></span><br><span class="line">            <span class="comment">#减枝，如果搜索路径大于4，直接返回</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(path) &gt; <span class="number">4</span>:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="comment">#全部搜素完成，搜索路径等于4，则加入结果列表</span></span><br><span class="line">            <span class="keyword">if</span> index == <span class="built_in">len</span>(s) <span class="keyword">and</span> <span class="built_in">len</span>(path) == <span class="number">4</span>:</span><br><span class="line">                result.append(<span class="string">&quot;.&quot;</span>.join(path))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="comment">#遍历整个字符串，对每一个满足的子串递归回溯</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index, <span class="built_in">len</span>(s)):</span><br><span class="line">                <span class="comment">#减枝，如果当前值在0-255之前，则开始回溯</span></span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span> &lt;= <span class="built_in">int</span>(s[index : i+ <span class="number">1</span>]) &lt;= <span class="number">255</span>:</span><br><span class="line">                    <span class="comment">#如果当前值是0，但是不是一个单&quot;0&quot;则剪掉</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">int</span>(s[index : i+ <span class="number">1</span>]) == <span class="number">0</span> <span class="keyword">and</span> i != index:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="comment">#如果当前值不是0，但是缺以&quot;0XXX&quot;开头，也应该剪掉</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">int</span>(s[index : i+ <span class="number">1</span>]) &gt; <span class="number">0</span> <span class="keyword">and</span> s[index] == <span class="string">&quot;0&quot;</span>:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="comment">#加入当前path</span></span><br><span class="line">                    path.append(s[index: i+ <span class="number">1</span>])</span><br><span class="line">                    <span class="comment">#从当前节点开始递归</span></span><br><span class="line">                    back_track(s, i + <span class="number">1</span>)</span><br><span class="line">                    <span class="comment">#回溯</span></span><br><span class="line">                    path.pop() <span class="comment"># pop list[-1]</span></span><br><span class="line">        back_track(s, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h3 id="79-单词搜索"><a href="#79-单词搜索" class="headerlink" title="79. 单词搜索"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/word-search/">79. 单词搜索</a></h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gue755aje8j608y06qjrf02.jpg"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gue75ugpuaj308y06qjre.jpg"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gue7644gpbj608y06qdft02.jpg"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exist</span>(<span class="params">self, board, word</span>):</span></span><br><span class="line">        </span><br><span class="line">        row, col = <span class="built_in">len</span>(board), <span class="built_in">len</span>(board[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">x, y, index</span>):</span></span><br><span class="line">            <span class="keyword">if</span> board[x][y] != word[index]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> index == <span class="built_in">len</span>(word) - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line">            board[x][y] = <span class="string">&#x27;1&#x27;</span>         <span class="comment"># 访问标记</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> choice <span class="keyword">in</span> [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, -<span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>], [-<span class="number">1</span>, <span class="number">0</span>]]:</span><br><span class="line">                new_x, new_y = x + choice[<span class="number">0</span>], y + choice[<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span> &lt;= new_x &lt; row <span class="keyword">and</span> <span class="number">0</span> &lt;= new_y &lt; col <span class="keyword">and</span> dfs(new_x, new_y, index + <span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            board[x][y] = word[index] <span class="comment"># 取消访问标记</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(col):</span><br><span class="line">                <span class="keyword">if</span> dfs(i, j, <span class="number">0</span>):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h3 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257. 二叉树的所有路径"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-paths/">257. 二叉树的所有路径</a></h3><p><strong>BFS</strong>：维护一个队列，存储节点以及根到该节点的路径。一开始这个队列里只有根节点。在每一步迭代中，我们取出队列中的首节点，如果它是叶子节点，则将它对应的路径加入到答案中。如果它不是叶子节点，则将它的所有孩子节点加入到队列的末尾。当队列为空时广度优先搜索结束，我们即能得到答案。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">binaryTreePaths</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[str]:</span></span><br><span class="line">        paths = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> paths</span><br><span class="line"></span><br><span class="line">        node_queue = collections.deque([root])</span><br><span class="line">        path_queue = collections.deque([<span class="built_in">str</span>(root.val)])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> node_queue:</span><br><span class="line">            node = node_queue.popleft()</span><br><span class="line">            path = path_queue.popleft()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right: <span class="comment"># 首节点</span></span><br><span class="line">                paths.append(path)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    node_queue.append(node.left)</span><br><span class="line">                    path_queue.append(path + <span class="string">&#x27;-&gt;&#x27;</span> + <span class="built_in">str</span>(node.left.val))</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    node_queue.append(node.right)</span><br><span class="line">                    path_queue.append(path + <span class="string">&#x27;-&gt;&#x27;</span> + <span class="built_in">str</span>(node.right.val))</span><br><span class="line">        <span class="keyword">return</span> paths</span><br></pre></td></tr></table></figure>



<h3 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutations/">46. 全排列</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        path, res = [], []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">back_track</span>(<span class="params">nums</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="built_in">len</span>(nums):</span><br><span class="line">                res.append(path[:])</span><br><span class="line">                <span class="keyword">return</span> <span class="comment"># return None</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> nums[i] <span class="keyword">in</span> path:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                </span><br><span class="line">                path.append(nums[i])</span><br><span class="line">                back_track(nums)</span><br><span class="line">                path.pop()</span><br><span class="line">            </span><br><span class="line">        back_track(nums)    </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h3 id="77-组合"><a href="#77-组合" class="headerlink" title="77. 组合"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combinations/">77. 组合</a></h3><ul>
<li>当depth = 0，i 需要 &lt;= 2。如果&gt; 2，则需剪枝</li>
<li>当depth = 1，i 需要 &lt;= 3。如果&gt; 3，则需剪枝</li>
<li>当depth = 2，i 需要 &lt;= 4。如果&gt; 4，则需剪枝</li>
</ul>
<p>归纳后发现，i 需要始终 &lt;= n - k + 1 + depth = 4 - 3 + 1 + depth = 2 + depth。</p>
<ul>
<li>时间复杂度：O(C(n, k) * k)，枚举结果总数为C(n, k)，每次得到一个结果需要O(k)时间。</li>
<li>空间复杂度：O(n)，最大是n层递归栈。这里不计返回值所占空间。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combine</span>(<span class="params">self, n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">        </span><br><span class="line">        self.res = []</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">startIdx, depth, path</span>):</span></span><br><span class="line">            <span class="keyword">if</span> depth == k:</span><br><span class="line">                self.res.append(path[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startIdx, n + <span class="number">1</span>): <span class="comment"># 注意这里i循环到n [1, n]</span></span><br><span class="line">                <span class="keyword">if</span> i &lt;= n - k + <span class="number">1</span> + depth: <span class="comment"># 剪枝: depth为当前path的长度。</span></span><br><span class="line">                    dfs(i + <span class="number">1</span>, depth + <span class="number">1</span>, path + [i])</span><br><span class="line">   </span><br><span class="line">        dfs(<span class="number">1</span>, <span class="number">0</span>, []) <span class="comment"># startIdx初始为1，深度初始为0，path初始为[]。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure>

<h3 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum/">39. 组合总和</a></h3><ul>
<li>可以无限制重复被选取</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span>(<span class="params">self, candidates, target</span>):</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">combination</span>(<span class="params">candidates, target, res_list</span>):</span></span><br><span class="line">            <span class="keyword">if</span> target &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> target == <span class="number">0</span>:</span><br><span class="line">                res.append(res_list)</span><br><span class="line">            <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(candidates): <span class="comment"># 列出数据下标和数据 index, candidates[i]</span></span><br><span class="line">                <span class="comment"># 为了避免重复 (例如candiactes=[2,3,6,7],target=7，输出[[2,2,3],[3,2,2][7]])</span></span><br><span class="line">                <span class="comment"># 传到的下一个candicate为candicates[i:]</span></span><br><span class="line">                combination(candidates[i:], target - c, res_list + [c])</span><br><span class="line">        </span><br><span class="line">        combination(candidates, target, [])</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">      </span><br><span class="line"><span class="comment">#######################################################################################</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span>(<span class="params">self, candidates: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> candidates: <span class="comment">#先解决空输入的情况</span></span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        candidates.sort()  <span class="comment">#排序</span></span><br><span class="line">        res=[]</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">i, temp_sum, temp_list</span>):</span> </span><br><span class="line">            <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            i：遍历到candidates数组中第几个元素</span></span><br><span class="line"><span class="string">            temp_sum：目前遍历数组的和</span></span><br><span class="line"><span class="string">            temp_list：目前遍历的数组</span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span></span><br><span class="line">            <span class="keyword">if</span> temp_sum == target:</span><br><span class="line">                res.append(temp_list)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> temp_sum &gt; target:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i,<span class="built_in">len</span>(candidates)):</span><br><span class="line">                backtrack(j, temp_sum+candidates[j], temp_list+[candidates[j]])</span><br><span class="line">        backtrack(<span class="number">0</span>, <span class="number">0</span>, [])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>



<h3 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40. 组合总和 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum-ii/">40. 组合总和 II</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum2</span>(<span class="params">self, candidates: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> candidates:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        candidates.sort()</span><br><span class="line">		</span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">index, temp_sum, temp_list</span>):</span></span><br><span class="line">            <span class="keyword">if</span> temp_sum &gt; target:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> temp_sum == target:</span><br><span class="line">                res.append(temp_list)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(index, <span class="built_in">len</span>(candidates)):</span><br><span class="line">                <span class="keyword">if</span> j &gt; index <span class="keyword">and</span> candidates[j] == candidates[j - <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                backtrack(j + <span class="number">1</span>, temp_sum + candidates[j], temp_list + [candidates[j]])</span><br><span class="line">        backtrack(<span class="number">0</span>, <span class="number">0</span>, [])</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="216-组合总和-III"><a href="#216-组合总和-III" class="headerlink" title="216. 组合总和 III"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum-iii/">216. 组合总和 III</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum3</span>(<span class="params">self, k: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">        candidates = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>))</span><br><span class="line">        res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">i, temp_sum, temp_list</span>):</span></span><br><span class="line">            <span class="keyword">if</span> temp_sum==n <span class="keyword">and</span> <span class="built_in">len</span>(temp_list)==k:</span><br><span class="line">                res.append(temp_list)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(temp_list)==k:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, <span class="built_in">len</span>(candidates)):</span><br><span class="line">                backtrack(j+<span class="number">1</span>, temp_sum+candidates[j], temp_list+[candidates[j]])</span><br><span class="line">        backtrack(<span class="number">0</span>,<span class="number">0</span>,[])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h3 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subsets/">78. 子集</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsets</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">index, temp_res</span>):</span></span><br><span class="line">            res.append(temp_res)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index, <span class="built_in">len</span>(nums)):</span><br><span class="line">                backtrack(i + <span class="number">1</span>, temp_res + [nums[i]])</span><br><span class="line">        </span><br><span class="line">        backtrack(<span class="number">0</span>, [])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h3 id="90-子集-II"><a href="#90-子集-II" class="headerlink" title="90. 子集 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subsets-ii/">90. 子集 II</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsetsWithDup</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[List[int]]:</span></span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        nums.sort() <span class="comment"># 排序</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">index, tmp_res</span>):</span></span><br><span class="line">            res.append(tmp_res)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(index, <span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> j &gt; index <span class="keyword">and</span> nums[j] == nums[j-<span class="number">1</span>]: <span class="comment"># 去重</span></span><br><span class="line">                    <span class="keyword">continue</span> <span class="comment"># pass the same number</span></span><br><span class="line">                backtrack(j + <span class="number">1</span>, tmp_res + [nums[j]])</span><br><span class="line">        </span><br><span class="line">        backtrack(<span class="number">0</span>, [])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h3 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131. 分割回文串"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/palindrome-partitioning/">131. 分割回文串</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        self.isPalindrome = <span class="keyword">lambda</span> s : s == s[::-<span class="number">1</span>]</span><br><span class="line">        res = []</span><br><span class="line">        self.backtrack(s, res, [])</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">self, s, res, path</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            res.append(path)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(s) + <span class="number">1</span>): <span class="comment">#注意起始和结束位置</span></span><br><span class="line">            <span class="keyword">if</span> self.isPalindrome(s[:i]):</span><br><span class="line">                self.backtrack(s[i:], res, path + [s[:i]])</span><br></pre></td></tr></table></figure>

<h3 id="37-解数独"><a href="#37-解数独" class="headerlink" title="37. 解数独"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sudoku-solver/">37. 解数独</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solveSudoku</span>(<span class="params">self, board: List[List[<span class="built_in">str</span>]]</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify board in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        rem_num = [[[<span class="built_in">str</span>(k) <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)] <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># rem_num 存储九宫格中每个格子还未填入的数字为 “.“，初始化为1-9所有数字，下面的循环将已经填过的数字剔除</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">                row, col = i//<span class="number">3</span>, j//<span class="number">3</span></span><br><span class="line">                <span class="keyword">if</span> board[i][j] != <span class="string">&#x27;.&#x27;</span>: rem_num[row][col].remove(board[i][j])</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">i, j</span>):</span></span><br><span class="line">            <span class="keyword">if</span> j &gt; <span class="number">8</span>: <span class="comment"># 从左往右，从上往下遍历每个格子，若列数超过最大值，则行数+1列数归0</span></span><br><span class="line">                i, j = i + <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">8</span>: <span class="keyword">return</span> <span class="literal">True</span> <span class="comment"># 行数超过最大值，说明遍历完成，返回True</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> board[i][j] != <span class="string">&#x27;.&#x27;</span>: <span class="keyword">return</span> dfs(i, j+<span class="number">1</span>) <span class="comment"># 若当前格子已填充，递归下一个格子</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 若当前格子未填充，则对当前格子所在九宫格中未填过数字（即rem_num[row][col]中的数字）逐一尝试填入</span></span><br><span class="line">            row, col = i//<span class="number">3</span>, j//<span class="number">3</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(rem_num[row][col])):</span><br><span class="line">                num_cur = rem_num[row][col].pop(k)<span class="comment"># 弹出一个数字，若该数字所在行和列无重复，则赋给当前格子</span></span><br><span class="line">                <span class="keyword">if</span> num_cur <span class="keyword">not</span> <span class="keyword">in</span> [board[ii][j] <span class="keyword">for</span> ii <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>)] <span class="keyword">and</span> num_cur <span class="keyword">not</span> <span class="keyword">in</span> board[i][:]:</span><br><span class="line">                    board[i][j] = num_cur</span><br><span class="line">                    <span class="keyword">if</span> dfs(i, j+<span class="number">1</span>): <span class="keyword">return</span> <span class="literal">True</span> <span class="comment"># 递归下一个格子，若为真，返回True</span></span><br><span class="line">                    <span class="comment"># 递归下一个格子返回False，说明当前填法不正确，回溯（下面两语句为状态恢复）          </span></span><br><span class="line">                    board[i][j] = <span class="string">&#x27;.&#x27;</span>  <span class="comment"># 恢复当前格子为未填充状态</span></span><br><span class="line">                rem_num[row][col].insert(k, num_cur) <span class="comment"># 将之前从九宫格未填数字列表中取出的数字放回</span></span><br><span class="line">            <span class="keyword">else</span>: <span class="keyword">return</span> <span class="literal">False</span> <span class="comment"># 所有尝试都不成功，说明当前路径行不通，返回False</span></span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h3 id="51-N-皇后"><a href="#51-N-皇后" class="headerlink" title="51. N 皇后"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/n-queens/">51. N 皇后</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solveNQueens</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; List[List[str]]:</span></span><br><span class="line">        res = [] <span class="comment"># 记录结果</span></span><br><span class="line">        col, diagr, diagl, board = [<span class="literal">True</span>]*n, [<span class="literal">True</span>]*(<span class="number">2</span>*n-<span class="number">1</span>), [<span class="literal">True</span>]*(<span class="number">2</span>*n-<span class="number">1</span>), [[<span class="string">&#x27;.&#x27;</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="comment"># col, diagr, diagl 的元素分别表示当前列、右对角线、左对角线是否还可以放置；board为记录摆放位置的n*n矩阵</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">traceback</span>(<span class="params">i, j</span>):</span></span><br><span class="line">            <span class="keyword">if</span> i &gt;= n: <span class="keyword">return</span> <span class="comment"># 当前行超过最大行号，返回</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> col[j] <span class="keyword">or</span> <span class="keyword">not</span> diagr[j-i+n-<span class="number">1</span>] <span class="keyword">or</span> <span class="keyword">not</span> diagl[j+i]: <span class="keyword">return</span> <span class="comment"># 当前列或右对角线或左对角线不能放置皇后，返回</span></span><br><span class="line">            board[i][j] = <span class="string">&#x27;Q&#x27;</span> <span class="comment"># 当前位置可以放置，将board对应位置的元素赋为&#x27;Q&#x27;</span></span><br><span class="line">            <span class="keyword">if</span> i == n - <span class="number">1</span> <span class="keyword">and</span> col[j] <span class="keyword">and</span> diagr[j-i+n-<span class="number">1</span>] <span class="keyword">and</span> diagl[j+i]: <span class="comment"># 当前已到最后一行，且当前位置可以放置，将摆放结果按正确的形式加入res中</span></span><br><span class="line">                res.append([<span class="string">&#x27;&#x27;</span>.join(line) <span class="keyword">for</span> line <span class="keyword">in</span> board])</span><br><span class="line">            <span class="comment"># 此后说明，当前位置可放置且未到最后一行</span></span><br><span class="line">            col[j], diagr[j-i+n-<span class="number">1</span>], diagl[j+i] = <span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span> <span class="comment"># 将当前位置对应的列、左右对角线的记为不能放置，并继续下一行的遍历</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                traceback(i+<span class="number">1</span>, k)</span><br><span class="line">            col[j], diagr[j-i+n-<span class="number">1</span>], diagl[j+i], board[i][j] = <span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">True</span>, <span class="string">&#x27;.&#x27;</span> <span class="comment"># 恢复当前位置的各参数，回溯（关键！）</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n): <span class="comment"># 从首行开始，遍历每一列</span></span><br><span class="line">            traceback(<span class="number">0</span>, j)</span><br><span class="line">        <span class="keyword">return</span> res <span class="comment"># 返回结果</span></span><br></pre></td></tr></table></figure>



<h1 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h1><p>动态规划：保存历史记录（<code>dp[]、dp[][]</code>），避免重复计算</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化 base case</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>][...] = base</span><br><span class="line"><span class="comment"># 进行状态转移</span></span><br><span class="line"><span class="keyword">for</span> 状态<span class="number">1</span> <span class="keyword">in</span> 状态<span class="number">1</span>的所有取值：</span><br><span class="line">    <span class="keyword">for</span> 状态<span class="number">2</span> <span class="keyword">in</span> 状态<span class="number">2</span>的所有取值：</span><br><span class="line">        <span class="keyword">for</span> ...</span><br><span class="line">            dp[状态<span class="number">1</span>][状态<span class="number">2</span>][...] = 求最值(选择<span class="number">1</span>，选择<span class="number">2.</span>..)</span><br></pre></td></tr></table></figure>



<p><strong>一般步骤：</strong></p>
<ol>
<li>定义数组元素的含义<ul>
<li><code>dp = [[0] * n for _ in range(m)] 区别 dp = [[0] * n] * m</code></li>
</ul>
</li>
<li>找出数组元素之间的关系<ul>
<li>推 <code>dp[i] 与 dp[i - 1]</code>，<code>dp[i][j] 与 dp[i][j - 1] dp[i - 1][j] </code></li>
<li>小 <code>dp[i][j] = min(dp[i - 1][j], dp[i][j - 1] + arr[i][j])</code></li>
<li>大 <code>dp[i][j] = max(dp[i - 1][j], dp[i][j - 1] + arr[i][j])</code></li>
</ul>
</li>
<li>找出初始值<ul>
<li>一维边界 <code>dp[0] dp[1]</code></li>
<li>二维边界 <code>dp[0][j] dp[i][0]</code></li>
</ul>
</li>
</ol>
<p><code>递归</code>和<code>动态规划</code>都是将原问题拆成多个子问题然后求解，他们之间最本质的区别是，动态规划保存了子问题的解，避免重复计算。递归的解法，是「<strong>自顶向下</strong>」的思路。如果转成「<strong>自底向上</strong>」的思路，就变成了动态规划。</p>
<p>步骤：</p>
<ol>
<li>确定子问题</li>
<li>写出子问题的递推关系和边界</li>
<li>确定 DP 的计算顺序<ul>
<li>在确定了子问题的递推关系之后，下一步就是依次计算出这些子问题了。在很多教程中都会写，动态规划有两种计算顺序，一种是自顶向下的、使用备忘录的递归方法，一种是自底向上的、使用 dp 数组的循环方法。不过在普通的动态规划题目中，99% 的情况我们都不需要用到备忘录方法，所以我们最好坚持用自底向上的 dp 数组。</li>
</ul>
</li>
<li>空间优化</li>
</ol>
<h2 id="CD17-机器人达到指定位置方法数"><a href="#CD17-机器人达到指定位置方法数" class="headerlink" title="CD17 机器人达到指定位置方法数"></a><strong>CD17</strong> <strong>机器人达到指定位置方法数</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">n, m, k, p = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">eps = <span class="number">1e9</span> + <span class="number">7</span></span><br><span class="line"></span><br><span class="line">last = [<span class="number">0</span>] * (n + <span class="number">2</span>)</span><br><span class="line">curr = [<span class="number">0</span>] * (n + <span class="number">2</span>)</span><br><span class="line">last[m] = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, k+<span class="number">1</span>):</span><br><span class="line">    l = <span class="built_in">max</span>(<span class="number">1</span>, m-i)</span><br><span class="line">    r = <span class="built_in">min</span>(n, m+i)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(l, r+<span class="number">1</span>):</span><br><span class="line">        curr[j] = (last[j-<span class="number">1</span>] + last[j + <span class="number">1</span>]) % eps</span><br><span class="line">    last[:] = curr[:]</span><br><span class="line">print(<span class="built_in">int</span>(curr[p]))</span><br></pre></td></tr></table></figure>



<h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><h3 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/climbing-stairs/">70. 爬楼梯</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">or</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.climbStairs(n - <span class="number">1</span>) + self.climbStairs(n - <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一维dp，自底向上, f(n) = f(n-1) + f(n-2)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">设 dp[n] 为第 n 阶楼梯的方案数，那么有 dp[n] = dp[n - 1] + dp[n - 2]。</span></span><br><span class="line"><span class="string">注意，边界值 dp[0] = dp[1] = 1</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="comment"># dp_list length = n+1, [0, n]</span></span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">1</span> <span class="comment"># 边界 注意 dp[0]</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>): <span class="comment"># [2, n]</span></span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br><span class="line"><span class="comment"># dp[1] dp[2]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, n + <span class="number">1</span>):</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i-<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br><span class="line"><span class="comment"># f(n) 只依赖于 f(n-1) 和 f(n-2)，只需要两项就足够了</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        a = b = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>): <span class="comment">#[2, n]</span></span><br><span class="line">            a, b = b, a + b</span><br><span class="line">        <span class="keyword">return</span> b</span><br></pre></td></tr></table></figure>

<h3 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746. 使用最小花费爬楼梯"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/">746. 使用最小花费爬楼梯</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCostClimbingStairs</span>(<span class="params">self, cost: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (<span class="built_in">len</span>(cost))</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 第一步 1 个台阶 </span></span><br><span class="line">        dp[<span class="number">0</span>] = cost[<span class="number">0</span>] </span><br><span class="line">        <span class="comment"># 第一步 2 个台阶</span></span><br><span class="line">        dp[<span class="number">1</span>] = cost[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">len</span>(cost)):</span><br><span class="line">            dp[i] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>]) + cost[i]</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(dp[<span class="built_in">len</span>(cost) - <span class="number">1</span>], dp[<span class="built_in">len</span>(cost) - <span class="number">2</span>]) <span class="comment"># min(倒数第二步，倒数第一步)</span></span><br><span class="line">    </span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCostClimbingStairs</span>(<span class="params">self, cost: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        dp = [<span class="number">0</span>] * <span class="built_in">len</span>(cost)</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = cost[<span class="number">0</span>]</span><br><span class="line">        dp[<span class="number">1</span>] = cost[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">len</span>(cost)):</span><br><span class="line">            dp[i] =<span class="built_in">min</span>(dp[i - <span class="number">2</span>], dp[i - <span class="number">1</span>]) + cost[i]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(dp[-<span class="number">1</span>], dp[-<span class="number">2</span>])  </span><br></pre></td></tr></table></figure>



<h3 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/house-robber/">198. 打家劫舍</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        size = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> size == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        dp = [<span class="number">0</span>] * size</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, size):</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[size - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h3 id="213-打家劫舍-II"><a href="#213-打家劫舍-II" class="headerlink" title="213. 打家劫舍 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/house-robber-ii/">213. 打家劫舍 II</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"># 如果不偷窃最后一间房屋，则偷窃房屋的下标范围是 [0, n-2][0, n−2]</span></span><br><span class="line"><span class="string"># 如果不偷窃第一间房屋，则偷窃房屋的下标范围是 [1, n-1][1, n−1]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">robRange</span>(<span class="params">start: <span class="built_in">int</span>, end: <span class="built_in">int</span></span>):</span></span><br><span class="line">            first = nums[start] </span><br><span class="line">            second = <span class="built_in">max</span>(nums[start], nums[start + <span class="number">1</span>]) <span class="comment"># nums[0] + nums[2] ? &gt; nums[1]</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start + <span class="number">2</span>, end + <span class="number">1</span>): <span class="comment"># 边界</span></span><br><span class="line">                first, second = second, <span class="built_in">max</span>(first + nums[i], second) </span><br><span class="line">            <span class="keyword">return</span> second</span><br><span class="line">        </span><br><span class="line">        length = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> length == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">elif</span> length == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(robRange(<span class="number">0</span>, length - <span class="number">2</span>), robRange(<span class="number">1</span>, length - <span class="number">1</span>) )</span><br></pre></td></tr></table></figure>

<h2 id="矩阵路径"><a href="#矩阵路径" class="headerlink" title="矩阵路径"></a>矩阵路径</h2><h3 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64. 最小路径和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-path-sum/">64. 最小路径和</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minPathSum</span>(<span class="params">self, grid: [[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(grid)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(grid[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> i == j == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">elif</span> i == <span class="number">0</span>:</span><br><span class="line">                    grid[i][j] = grid[i][j] + grid[i][j - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">elif</span> j == <span class="number">0</span>:</span><br><span class="line">                    grid[i][j] = grid[i][j] + grid[i - <span class="number">1</span>][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    grid[i][j] = grid[i][j] + <span class="built_in">min</span>(grid[i - <span class="number">1</span>][j], grid[i][j - <span class="number">1</span>])  </span><br><span class="line">        <span class="keyword">return</span> grid[-<span class="number">1</span>][-<span class="number">1</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-paths/">62. 不同路径</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span> <span class="comment"># 动态规划</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span>(<span class="params">self, m: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># dp = [[1 for i in range(n)] for j in range(m)]</span></span><br><span class="line">        <span class="comment"># [[1] * n]: [1, 1, 1...], [[1] + [0] * (n - 1) for _ in range(m - 1)]: [1, 0 , 0...] * (m -1)</span></span><br><span class="line">        dp = dp = [[<span class="number">1</span>] * n] + [[<span class="number">1</span>] + [<span class="number">0</span>] * (n - <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m - <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">                dp[i][j] = dp[i][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j]</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h3 id="63-不同路径-II"><a href="#63-不同路径-II" class="headerlink" title="63. 不同路径 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-paths-ii/">63. 不同路径 II</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePathsWithObstacles</span>(<span class="params">self, obstacleGrid: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># 构造一个DP table</span></span><br><span class="line">        row = <span class="built_in">len</span>(obstacleGrid)</span><br><span class="line">        col = <span class="built_in">len</span>(obstacleGrid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(col)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(row)]</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span> <span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] != <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果第一个格子就是障碍，return 0</span></span><br><span class="line">        <span class="keyword">if</span> dp[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span>  </span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 初始化</span></span><br><span class="line">        <span class="comment">## 第一列</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, col):</span><br><span class="line">            <span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][i] != <span class="number">1</span>:</span><br><span class="line">                dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment">## 第一行</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, row):</span><br><span class="line">            <span class="keyword">if</span> obstacleGrid[i][<span class="number">0</span>] != <span class="number">1</span>:</span><br><span class="line">                dp[i][<span class="number">0</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, row):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, col):</span><br><span class="line">                <span class="keyword">if</span> obstacleGrid[i][j] != <span class="number">1</span>:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>]</span><br><span class="line">                    </span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>



<h2 id="数组区间"><a href="#数组区间" class="headerlink" title="数组区间"></a>数组区间</h2><h3 id="303-区域和检索-数组不可变"><a href="#303-区域和检索-数组不可变" class="headerlink" title="303. 区域和检索 - 数组不可变"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/range-sum-query-immutable/">303. 区域和检索 - 数组不可变</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>):</span></span><br><span class="line">        self.sums = [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            self.sums.append(self.sums[-<span class="number">1</span>] + num)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumRange</span>(<span class="params">self, left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        _sums = self.sums</span><br><span class="line">        <span class="keyword">return</span> _sums[right + <span class="number">1</span>] - _sums[left]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = NumArray(nums)</span></span><br><span class="line"><span class="comment"># param_1 = obj.sumRange(left,right)</span></span><br></pre></td></tr></table></figure>

<h3 id="413-等差数列划分"><a href="#413-等差数列划分" class="headerlink" title="413. 等差数列划分"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/arithmetic-slices/">413. 等差数列划分</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numberOfArithmeticSlices</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        dp = [<span class="number">0</span>] * (<span class="built_in">len</span>(nums) + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] - nums[i - <span class="number">1</span>] == nums[i - <span class="number">1</span>] - nums[i - <span class="number">2</span>]:</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                res += dp[i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="分割整数"><a href="#分割整数" class="headerlink" title="分割整数"></a>分割整数</h2><h3 id="343-整数拆分"><a href="#343-整数拆分" class="headerlink" title="343. 整数拆分"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/integer-break/">343. 整数拆分</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">integerBreak</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 假设对正整数 i 拆分出的第一个正整数是 j（1 &lt;= j &lt; i），则有以下两种方案：</span></span><br><span class="line">            <span class="comment"># 1) 将 i 拆分成 j 和 i−j 的和，且 i−j 不再拆分成多个正整数，此时的乘积是 j * (i-j)</span></span><br><span class="line">            <span class="comment"># 2) 将 i 拆分成 j 和 i−j 的和，且 i−j 继续拆分成多个正整数，此时的乘积是 j * dp[i-j]</span></span><br><span class="line">            <span class="comment"># 3）dp[i] 下一次</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, i - <span class="number">1</span>):</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i], j * (i - j), j * dp[i - j])  </span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>

<h3 id="279-完全平方数-1"><a href="#279-完全平方数-1" class="headerlink" title="279. 完全平方数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/perfect-squares/">279. 完全平方数</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSquares</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        dp=[i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)] <span class="comment"># 全1组成</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">int</span>(i**(<span class="number">0.5</span>)) + <span class="number">1</span>):</span><br><span class="line">                dp[i] = <span class="built_in">min</span>(dp[i], dp[i - j*j] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h3 id="91-解码方法"><a href="#91-解码方法" class="headerlink" title="91. 解码方法"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/decode-ways/">91. 解码方法</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numDecodings</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> s.startswith(<span class="string">&#x27;0&#x27;</span>):  <span class="comment"># 开头有 ‘0’ 直接返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        dp = [<span class="number">1</span>] * (n + <span class="number">1</span>)  <span class="comment"># 重点是 dp[0], dp[1] = 1, 1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> s[i - <span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span> <span class="keyword">and</span> s[i - <span class="number">2</span>] <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">&#x27;12&#x27;</span>:  <span class="comment"># 出现前导 ‘0’ 的情况，不能解码，直接返回</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> s[i - <span class="number">2</span>: i] <span class="keyword">in</span> [<span class="string">&#x27;10&#x27;</span>, <span class="string">&#x27;20&#x27;</span>]:  <span class="comment"># 只有组合在一起才能解码</span></span><br><span class="line">                dp[i] = dp[i - <span class="number">2</span>]</span><br><span class="line">            <span class="keyword">elif</span> <span class="string">&#x27;10&#x27;</span> &lt; s[i - <span class="number">2</span>: i] &lt;= <span class="string">&#x27;26&#x27;</span>: <span class="comment"># 两种解码方式</span></span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]</span><br><span class="line">            <span class="keyword">else</span>:                         <span class="comment"># &#x27;01&#x27;到 ‘09’ 或 &gt; &#x27;26&#x27;，只有单独才能解码</span></span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96. 不同的二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numTrees</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>], dp[<span class="number">1</span>] = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, i + <span class="number">1</span>):</span><br><span class="line">                dp[i] += dp[j - <span class="number">1</span>] * dp[i - j] <span class="comment"># j-1 为j为头结点左子树节点数量，i-j 为以j为头结点右子树节点数量</span></span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>



<h2 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h2><h3 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300. 最长递增子序列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">300. 最长递增子序列</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [<span class="number">1</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">                <span class="keyword">if</span> nums[j] &lt; nums[i]: </span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp)</span><br></pre></td></tr></table></figure>

<h3 id="646-最长数对链"><a href="#646-最长数对链" class="headerlink" title="646. 最长数对链"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-length-of-pair-chain/">646. 最长数对链</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span> <span class="comment">#Time Limit Exceeded</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLongestChain</span>(<span class="params">self, pairs</span>):</span></span><br><span class="line">        pairs.sort()</span><br><span class="line">        dp = [<span class="number">1</span>] * <span class="built_in">len</span>(pairs)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(pairs)):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(j):</span><br><span class="line">                <span class="keyword">if</span> pairs[i][<span class="number">1</span>] &lt; pairs[j][<span class="number">0</span>]:</span><br><span class="line">                    dp[j] = <span class="built_in">max</span>(dp[j], dp[i] + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="376-摆动序列"><a href="#376-摆动序列" class="headerlink" title="376. 摆动序列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/wiggle-subsequence/">376. 摆动序列</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wiggleMaxLength</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        up, down = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; nums[i-<span class="number">1</span>]:</span><br><span class="line">                up = down + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[i] &lt; nums[i-<span class="number">1</span>]:</span><br><span class="line">                down = up + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(up, down)</span><br></pre></td></tr></table></figure>

<h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><h3 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143. 最长公共子序列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-common-subsequence/">1143. 最长公共子序列</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonSubsequence</span>(<span class="params">self, text1, text2</span>):</span></span><br><span class="line">        M, N = <span class="built_in">len</span>(text1), <span class="built_in">len</span>(text2)</span><br><span class="line">        dp = [[<span class="number">0</span>] * (N + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(M + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, M + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, N + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> text1[i - <span class="number">1</span>] == text2[j - <span class="number">1</span>]:</span><br><span class="line">                    <span class="comment"># dp[i][j] 的含义是 text1[0:i-1] 和 text2[0:j-1] </span></span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[M][N]</span><br></pre></td></tr></table></figure>

<h2 id="背包"><a href="#背包" class="headerlink" title="背包"></a>背包</h2><p>有一个容量为 N 的背包，要用这个背包装下物品的价值最大，这些物品有两个属性：体积 w 和价值 v。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gukptbo52hj60pc0dqwf902.jpg" alt="动态规划-背包问题1"></p>
<p>从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。</p>
<p><code>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])</code></p>
<ul>
<li><p>不选： <code>dp[i - 1][j]</code> </p>
</li>
<li><p>选：<code>dp[i - 1][j - weight[i]] + value[i]</code>  </p>
</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1guk09hcbzzj60d601874502.jpg" alt="img"></p>
<h3 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416. 分割等和子集"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">416. 分割等和子集</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canPartition</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; bool:</span></span><br><span class="line">        sumAll = <span class="built_in">sum</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> sumAll % <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        target = sumAll // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        dp = [<span class="literal">False</span>] * (target + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(target, nums[i] - <span class="number">1</span>, -<span class="number">1</span>): <span class="comment"># 从后往前，先计算 dp[i] 再计算 dp[i - num]</span></span><br><span class="line">                dp[j] = dp[j] <span class="keyword">or</span> dp[j - nums[i]]</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 二维数组</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findTargetSumWays</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        sums = <span class="built_in">sum</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> sums &lt; <span class="built_in">abs</span>(target) <span class="keyword">or</span> (sums + target) % <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        target = (sums + target) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        dp = [[<span class="number">0</span>] * (target + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 注意遍历范围</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(target + <span class="number">1</span>):</span><br><span class="line">                num = nums[i - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> j &lt; num:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i - <span class="number">1</span>][j - num]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h3 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494. 目标和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/target-sum/">494. 目标和</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">1.先数学计算，找规律和约束条件</span></span><br><span class="line"><span class="string">正数和为x，负数和绝对值为y</span></span><br><span class="line"><span class="string">x + y = sum(nums)</span></span><br><span class="line"><span class="string">x - y = target</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">x = (sum+target) / 2</span></span><br><span class="line"><span class="string">y = (sum - target) / 2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">以x或y为目标和。01背包问题</span></span><br><span class="line"><span class="string">注意内循环要逆序。以确保更新时用的是旧值</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findTargetSumWays</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        sums = <span class="built_in">sum</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> sums &lt; <span class="built_in">abs</span>(target) <span class="keyword">or</span> (sums + target) % <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        target = (sums + target) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        dp = [<span class="number">1</span>] + [<span class="number">0</span>] * target</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="comment"># 倒序遍历</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(target, num - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                dp[j] += dp[j - num]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h3 id="474-一和零"><a href="#474-一和零" class="headerlink" title="474. 一和零"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ones-and-zeroes/">474. 一和零</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="518-零钱兑换-II"><a href="#518-零钱兑换-II" class="headerlink" title="518. 零钱兑换 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/coin-change-2/">518. 零钱兑换 II</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">change</span>(<span class="params">self, amount: <span class="built_in">int</span>, coins: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        dp = [<span class="number">1</span>] + [<span class="number">0</span>] * amount</span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(coin, amount + <span class="number">1</span>):</span><br><span class="line">                dp[j] += dp[j - coin]</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>



<h3 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/coin-change/">322. 零钱兑换</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">coinChange</span>(<span class="params">self, coins: List[<span class="built_in">int</span>], amount: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        dp = [<span class="number">0</span>] + [<span class="number">10001</span>] * amount</span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(coin, amount + <span class="number">1</span>):</span><br><span class="line">                <span class="comment"># 当前填满容量j最少需要的硬币 = min( 之前填满容量j最少需要的硬币, 填满容量 j - coin 需要的硬币 + 1个当前硬币）</span></span><br><span class="line">                dp[j] = <span class="built_in">min</span>(dp[j], dp[j - coin] + <span class="number">1</span>) </span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>] <span class="keyword">if</span> dp[-<span class="number">1</span>] != <span class="number">10001</span> <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">coinChange</span>(<span class="params">self, coins: List[<span class="built_in">int</span>], amount: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 初始化</span></span><br><span class="line">        dp = [amount + <span class="number">1</span>]*(amount + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 遍历物品</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, amount + <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 遍历背包</span></span><br><span class="line">            <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">                <span class="keyword">if</span> j &gt;= coin:</span><br><span class="line">                	dp[j] = <span class="built_in">min</span>(dp[j], dp[j - coin] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[amount] <span class="keyword">if</span> dp[amount] &lt; amount + <span class="number">1</span> <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139. 单词拆分"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/word-break/">139. 单词拆分</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="377-组合总和-Ⅳ"><a href="#377-组合总和-Ⅳ" class="headerlink" title="377. 组合总和 Ⅳ"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum-iv/">377. 组合总和 Ⅳ</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="983-最低票价"><a href="#983-最低票价" class="headerlink" title="983. 最低票价"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-cost-for-tickets/">983. 最低票价</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mincostTickets</span>(<span class="params">self, days: List[<span class="built_in">int</span>], costs: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (days[-<span class="number">1</span>] + <span class="number">1</span>)</span><br><span class="line">        <span class="comment">#dp = [0 for _ in range(days[-1] + 1)]  # dp数组，每个元素代表到当前天数最少钱数，为下标方便对应，多加一个 0 位置</span></span><br><span class="line">        days_idx = <span class="number">0</span>  <span class="comment"># 设定一个days指标，标记应该处理 days 数组中哪一个元素</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(dp)):</span><br><span class="line">            <span class="keyword">if</span> i != days[days_idx]:  <span class="comment"># 若当前天数不是待处理天数，则其花费费用和前一天相同</span></span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 若 i 走到了待处理天数，则从三种方式中选一个最小的</span></span><br><span class="line">                dp[i] = <span class="built_in">min</span>(dp[<span class="built_in">max</span>(<span class="number">0</span>, i - <span class="number">1</span>)] + costs[<span class="number">0</span>],</span><br><span class="line">                            dp[<span class="built_in">max</span>(<span class="number">0</span>, i - <span class="number">7</span>)] + costs[<span class="number">1</span>],</span><br><span class="line">                            dp[<span class="built_in">max</span>(<span class="number">0</span>, i - <span class="number">30</span>)] + costs[<span class="number">2</span>])</span><br><span class="line">                days_idx += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]  <span class="comment"># 返回最后一天对应的费用即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 二分法 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mincostTickets</span>(<span class="params">self, days: List[<span class="built_in">int</span>], costs: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        ans = [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i, day <span class="keyword">in</span> <span class="built_in">enumerate</span>(days):</span><br><span class="line">            ans.append(<span class="built_in">min</span>(</span><br><span class="line">                ans[-<span class="number">1</span>] + costs[<span class="number">0</span>],</span><br><span class="line">                ans[bisect.bisect(days, day - <span class="number">7</span>)] + costs[<span class="number">1</span>],</span><br><span class="line">                ans[bisect.bisect(days, day - <span class="number">30</span>)] + costs[<span class="number">2</span>]</span><br><span class="line">            ))</span><br><span class="line">        <span class="keyword">return</span> ans[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>



<h2 id="股票交易"><a href="#股票交易" class="headerlink" title="股票交易"></a>股票交易</h2><h3 id="309-最佳买卖股票时机含冷冻期"><a href="#309-最佳买卖股票时机含冷冻期" class="headerlink" title="309. 最佳买卖股票时机含冷冻期"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309. 最佳买卖股票时机含冷冻期</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(prices) &lt; <span class="number">2</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        dp0 = <span class="number">0</span> <span class="comment"># 手里没股票，没有处于冷冻期</span></span><br><span class="line">        dp1 = <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>) <span class="comment"># 手里没股票，并且处于冷冻期</span></span><br><span class="line">        dp2 = - prices[<span class="number">0</span>] <span class="comment"># 手里有股票</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(prices)):</span><br><span class="line">            new_dp0 = <span class="built_in">max</span>(dp0, dp1)</span><br><span class="line">            new_dp1 = dp2 + prices[i]</span><br><span class="line">            new_dp2 = <span class="built_in">max</span>(dp2, dp0 - prices[i])</span><br><span class="line">            dp0, dp1, dp2 = new_dp0, new_dp1, new_dp2</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp0, dp1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        n = <span class="built_in">len</span>(prices)</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [[<span class="number">0</span>,<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]   <span class="comment">#dp的初始化</span></span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>     <span class="comment">#第0天不持股自然就为0了</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>]   <span class="comment">#第0天持股，那么价格就是-prices[0]了</span></span><br><span class="line">        <span class="comment">#第1天不持股，要么第0天就不持股，要么就是第0天持股，然后第1天卖出</span></span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="built_in">max</span>(dp[<span class="number">0</span>][<span class="number">0</span>],dp[<span class="number">0</span>][<span class="number">1</span>]+prices[<span class="number">1</span>]) </span><br><span class="line">        <span class="comment">#第一天持股，要么就是第0天就持股了，要么就是第0天不持股第1天持股</span></span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>(dp[<span class="number">0</span>][<span class="number">1</span>],dp[<span class="number">0</span>][<span class="number">0</span>]-prices[<span class="number">1</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,n):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>]+prices[i])</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">1</span>],dp[i-<span class="number">2</span>][<span class="number">0</span>]-prices[i])</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<h3 id="714-买卖股票的最佳时机含手续费"><a href="#714-买卖股票的最佳时机含手续费" class="headerlink" title="714. 买卖股票的最佳时机含手续费"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">714. 买卖股票的最佳时机含手续费</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[<span class="built_in">int</span>], fee: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        n = <span class="built_in">len</span>(prices)</span><br><span class="line">        dp  = [[<span class="number">0</span>, <span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>], dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>, -<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i - <span class="number">1</span>])</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i - <span class="number">1</span>] - fee)</span><br><span class="line">        <span class="keyword">return</span> dp[n][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<h3 id="123-买卖股票的最佳时机-III"><a href="#123-买卖股票的最佳时机-III" class="headerlink" title="123. 买卖股票的最佳时机 III"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/">123. 买卖股票的最佳时机 III</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="188-买卖股票的最佳时机-IV"><a href="#188-买卖股票的最佳时机-IV" class="headerlink" title="188. 买卖股票的最佳时机 IV"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/">188. 买卖股票的最佳时机 IV</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="字符串编辑"><a href="#字符串编辑" class="headerlink" title="字符串编辑"></a>字符串编辑</h2><h3 id="583-两个字符串的删除操作"><a href="#583-两个字符串的删除操作" class="headerlink" title="583. 两个字符串的删除操作"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/delete-operation-for-two-strings/">583. 两个字符串的删除操作</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72. 编辑距离"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/edit-distance/">72. 编辑距离</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="650-只有两个键的键盘"><a href="#650-只有两个键的键盘" class="headerlink" title="650. 只有两个键的键盘"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/2-keys-keyboard/">650. 只有两个键的键盘</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h1><h2 id="素数、公约数、公倍数"><a href="#素数、公约数、公倍数" class="headerlink" title="素数、公约数、公倍数"></a>素数、公约数、公倍数</h2><h3 id="素数分解"><a href="#素数分解" class="headerlink" title="素数分解"></a>素数分解</h3><p>每一个数都可以分解成素数的乘积，例如 84 = 22 * 31 * 50 * 71 * 110 * 130 * 170 * …</p>
<h3 id="204-计数质数"><a href="#204-计数质数" class="headerlink" title="204. 计数质数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-primes/">204. 计数质数</a></h3><p>统计所有小于非负整数 <em><code>n</code></em> 的质数的数量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 10</span><br><span class="line">输出：4</span><br><span class="line">解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">埃氏筛的原理</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countPrimes</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># 定义数组标记是否是质数</span></span><br><span class="line">        is_prime = [<span class="number">1</span>] * n</span><br><span class="line">        </span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n): <span class="comment"># 2-n 倍</span></span><br><span class="line">            <span class="comment"># 将质数的倍数标记为合数</span></span><br><span class="line">            <span class="keyword">if</span> is_prime[i]:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 从 i*i 开始标记</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i*i, n, i):</span><br><span class="line">                    is_prime[j] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>

<h3 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hcf</span>(<span class="params">x, y</span>):</span></span><br><span class="line">   <span class="string">&quot;&quot;&quot;该函数返回两个数的最大公约数&quot;&quot;&quot;</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment"># 获取最小值</span></span><br><span class="line">   <span class="keyword">if</span> x &gt; y:</span><br><span class="line">       smaller = y</span><br><span class="line">   <span class="keyword">else</span>:</span><br><span class="line">       smaller = x</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, smaller + <span class="number">1</span>):</span><br><span class="line">       <span class="keyword">if</span>((x % i == <span class="number">0</span>) <span class="keyword">and</span> (y % i == <span class="number">0</span>)):</span><br><span class="line">           hcf = i</span><br><span class="line">   <span class="keyword">return</span> hcf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 位操作</span></span><br></pre></td></tr></table></figure>

<h3 id="最小公倍数"><a href="#最小公倍数" class="headerlink" title="最小公倍数"></a>最小公倍数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 最小公倍数为两数的乘积除以最大公约数。</span></span><br><span class="line"></span><br><span class="line">对于 a 和 b 的最大公约数 f(a, b)，有：</span><br><span class="line">- 如果 a 和 b 均为偶数，f(a, b) = <span class="number">2</span>*f(a/<span class="number">2</span>, b/<span class="number">2</span>);</span><br><span class="line">- 如果 a 是偶数 b 是奇数，f(a, b) = f(a/<span class="number">2</span>, b);</span><br><span class="line">- 如果 b 是偶数 a 是奇数，f(a, b) = f(a, b/<span class="number">2</span>);</span><br><span class="line">- 如果 a 和 b 均为奇数，f(a, b) = f(b, a-b);</span><br></pre></td></tr></table></figure>

<h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><h3 id="504-七进制数"><a href="#504-七进制数" class="headerlink" title="504. 七进制数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/base-7/">504. 七进制数</a></h3><p>给定一个整数 <code>num</code>，将其转化为 <strong>7 进制</strong>，并以字符串形式输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: num &#x3D; 100</span><br><span class="line">输出: &quot;202&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">convertToBase7</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> num &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;-&quot;</span> + self.convertToBase7(-num)</span><br><span class="line">        <span class="keyword">if</span> num &lt; <span class="number">7</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">str</span>(num)</span><br><span class="line">        <span class="keyword">return</span> self.convertToBase7(num // <span class="number">7</span>) + <span class="built_in">str</span>(num % <span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 迭代</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">convertToBase7</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        ans = []</span><br><span class="line">        is_negative = num &lt; <span class="number">0</span></span><br><span class="line">        num = <span class="built_in">abs</span>(num)</span><br><span class="line">        <span class="keyword">while</span> num &gt; <span class="number">0</span>:</span><br><span class="line">            num, remain = num // <span class="number">7</span>, num % <span class="number">7</span></span><br><span class="line">            ans.append(<span class="built_in">str</span>(remain))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;-&quot;</span> + <span class="string">&quot;&quot;</span>.join(ans[::-<span class="number">1</span>]) <span class="keyword">if</span> is_negative <span class="keyword">else</span> <span class="string">&quot;&quot;</span>.join(ans[::-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<h3 id="405-数字转换为十六进制数"><a href="#405-数字转换为十六进制数" class="headerlink" title="405. 数字转换为十六进制数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/convert-a-number-to-hexadecimal/">405. 数字转换为十六进制数</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 判断转换</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">toHex</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; str:</span></span><br><span class="line">        res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> num &lt; <span class="number">0</span>:</span><br><span class="line">            num =( <span class="built_in">abs</span>(num) ^ (<span class="number">2</span>**<span class="number">32</span>-<span class="number">1</span>)) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> num == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;0&#x27;</span></span><br><span class="line">        <span class="keyword">while</span> num:</span><br><span class="line">            a = num % <span class="number">16</span></span><br><span class="line">            <span class="keyword">if</span> a &gt; <span class="number">9</span>:</span><br><span class="line">                a = <span class="built_in">chr</span>(a+<span class="number">87</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                a = <span class="built_in">str</span>(a)</span><br><span class="line">            res += a </span><br><span class="line">            num &gt;&gt;= <span class="number">4</span></span><br><span class="line">        <span class="keyword">return</span> res[::-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 库函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">toHex</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; str:</span></span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">hex</span>(num&amp;<span class="number">0xFFFFFFFF</span>)[<span class="number">2</span>:]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 位运算</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">toHex</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; str:</span></span><br><span class="line">        num &amp;= <span class="number">0xFFFFFFFF</span></span><br><span class="line">        s = <span class="string">&quot;0123456789abcdef&quot;</span></span><br><span class="line">        res = <span class="string">&quot;&quot;</span></span><br><span class="line">        mask = <span class="number">0b1111</span></span><br><span class="line">        <span class="keyword">while</span> num &gt; <span class="number">0</span>:</span><br><span class="line">            res += s[num &amp; mask]</span><br><span class="line">            num &gt;&gt;= <span class="number">4</span></span><br><span class="line">        <span class="keyword">return</span> res[::-<span class="number">1</span>] <span class="keyword">if</span> res <span class="keyword">else</span> <span class="string">&quot;0&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="168-Excel表列名称"><a href="#168-Excel表列名称" class="headerlink" title="168. Excel表列名称"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/excel-sheet-column-title/">168. Excel表列名称</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">convertToTitle</span>(<span class="params">self, columnNumber: <span class="built_in">int</span></span>) -&gt; str:</span></span><br><span class="line">        ans = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">while</span> columnNumber &gt; <span class="number">0</span>:</span><br><span class="line">            columnNumber -= <span class="number">1</span></span><br><span class="line">            ans.append(<span class="built_in">chr</span>(columnNumber % <span class="number">26</span> + <span class="built_in">ord</span>(<span class="string">&quot;A&quot;</span>)))</span><br><span class="line">            columnNumber //= <span class="number">26</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(ans[::-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<h2 id="阶乘"><a href="#阶乘" class="headerlink" title="阶乘"></a>阶乘</h2><h3 id="172-阶乘后的零"><a href="#172-阶乘后的零" class="headerlink" title="172. 阶乘后的零"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/factorial-trailing-zeroes/">172. 阶乘后的零</a></h3><p>尾部的 0 由 2 * 5 得来，2 的数量明显多于 5 的数量，因此只要统计有多少个 5 即可。</p>
<p>对于一个数 N，它所包含 5 的个数为：N/5 + N/52 + N/53 + …，其中 N/5 表示不大于 N 的数中 5 的倍数贡献一个 5，N/52 表示不大于 N 的数中 52 的倍数再贡献一个 5 …。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trailingZeroes</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        i=<span class="number">5</span></span><br><span class="line">        count=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n//i: </span><br><span class="line">            count+=n//i</span><br><span class="line">            i*=<span class="number">5</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>

<h2 id="字符串加减法"><a href="#字符串加减法" class="headerlink" title="字符串加减法"></a>字符串加减法</h2><h3 id="67-二进制求和"><a href="#67-二进制求和" class="headerlink" title="67. 二进制求和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/add-binary/">67. 二进制求和</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addBinary</span>(<span class="params">self, a: <span class="built_in">str</span>, b: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bin</span>(<span class="built_in">int</span>(a, <span class="number">2</span>)+<span class="built_in">int</span>(b, <span class="number">2</span>))[<span class="number">2</span>:]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addBinary</span>(<span class="params">self, a, b</span>) -&gt; str:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#123;0:b&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">int</span>(a, <span class="number">2</span>) + <span class="built_in">int</span>(b, <span class="number">2</span>))</span><br><span class="line">      </span><br><span class="line"><span class="comment"># 位运算</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addBinary</span>(<span class="params">self, a, b</span>) -&gt; str:</span></span><br><span class="line">        x, y = <span class="built_in">int</span>(a, <span class="number">2</span>), <span class="built_in">int</span>(b, <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">while</span> y:</span><br><span class="line">            answer = x ^ y</span><br><span class="line">            carry = (x &amp; y) &lt;&lt; <span class="number">1</span></span><br><span class="line">            x, y = answer, carry</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bin</span>(x)[<span class="number">2</span>:]</span><br></pre></td></tr></table></figure>

<h3 id="415-字符串相加"><a href="#415-字符串相加" class="headerlink" title="415. 字符串相加"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/add-strings/">415. 字符串相加</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：num1 &#x3D; &quot;11&quot;, num2 &#x3D; &quot;123&quot;</span><br><span class="line">输出：&quot;134&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addStrings</span>(<span class="params">self, num1: <span class="built_in">str</span>, num2: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(<span class="built_in">int</span>(num1)+<span class="built_in">int</span>(num2))</span><br><span class="line">      </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addStrings</span>(<span class="params">self, num1: <span class="built_in">str</span>, num2: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line">        i = <span class="built_in">len</span>(num1)-<span class="number">1</span></span><br><span class="line">        j = <span class="built_in">len</span>(num2)-<span class="number">1</span></span><br><span class="line">        res = <span class="string">&quot;&quot;</span></span><br><span class="line">        carry = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;=<span class="number">0</span> <span class="keyword">or</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">            n1 = num1[i] <span class="keyword">if</span> i &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="string">&#x27;0&#x27;</span></span><br><span class="line">            n2 = num2[j] <span class="keyword">if</span> j &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="string">&#x27;0&#x27;</span></span><br><span class="line">            temp = <span class="built_in">ord</span>(n1) + <span class="built_in">ord</span>(n2) - <span class="number">2</span>*<span class="built_in">ord</span>(<span class="string">&#x27;0&#x27;</span>) + carry</span><br><span class="line">            cur = temp%<span class="number">10</span> </span><br><span class="line">            carry = temp//<span class="number">10</span></span><br><span class="line">            res = <span class="built_in">chr</span>(cur+<span class="number">48</span>) + res</span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;1&#x27;</span> + res <span class="keyword">if</span> carry != <span class="number">0</span> <span class="keyword">else</span> res</span><br></pre></td></tr></table></figure>

<h2 id="相遇问题"><a href="#相遇问题" class="headerlink" title="相遇问题"></a>相遇问题</h2><h3 id="462-最少移动次数使数组元素相等-II"><a href="#462-最少移动次数使数组元素相等-II" class="headerlink" title="462. 最少移动次数使数组元素相等 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements-ii/">462. 最少移动次数使数组元素相等 II</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 找中位数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minMoves2</span>(<span class="params">self, a: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        a.sort()</span><br><span class="line">        i, j = <span class="number">0</span>, <span class="built_in">len</span>(a)-<span class="number">1</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;j:</span><br><span class="line">            ans += a[j]-a[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span>     </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="多数投票"><a href="#多数投票" class="headerlink" title="多数投票"></a>多数投票</h2><h3 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169. 多数元素"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/majority-element/">169. 多数元素</a></h3><p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[3,2,3]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        half = <span class="built_in">len</span>(nums) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> nums[half]</span><br><span class="line">      </span><br><span class="line"><span class="comment"># 摩尔投票</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        major = <span class="number">0</span> <span class="comment"># 选中</span></span><br><span class="line">        count = <span class="number">0</span> <span class="comment"># 计数</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> count == <span class="number">0</span>:</span><br><span class="line">                major = n</span><br><span class="line">            <span class="keyword">if</span> n == major:</span><br><span class="line">                count = count + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count = count - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> major</span><br></pre></td></tr></table></figure>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="367-有效的完全平方数"><a href="#367-有效的完全平方数" class="headerlink" title="367. 有效的完全平方数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-perfect-square/">367. 有效的完全平方数</a></h3><p>给定一个 正整数 num ，编写一个函数，如果 num 是一个完全平方数，则返回 true ，否则返回 false 。</p>
<p>进阶：不要 使用任何内置的库函数，如  sqrt 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：num &#x3D; 16</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPerfectSquare</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; bool:</span></span><br><span class="line">        x = <span class="built_in">int</span>(num ** <span class="number">0.5</span>)</span><br><span class="line">        <span class="keyword">if</span> x ** <span class="number">2</span> == num:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">          </span><br><span class="line">      </span><br></pre></td></tr></table></figure>

<h3 id="326-3的幂"><a href="#326-3的幂" class="headerlink" title="326. 3的幂"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/power-of-three/">326. 3的幂</a></h3><p>给定一个整数，写一个函数来判断它是否是 3 的幂次方。如果是，返回 true ；否则，返回 false 。</p>
<p>整数 n 是 3 的幂次方需满足：存在整数 x 使得 n == 3x</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 27</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一直除 3，判断最后的结果是否为 1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPowerOfThree</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">0</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> n &gt; <span class="number">1</span>:</span><br><span class="line">            n =  n / <span class="number">3</span></span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="238-除自身以外数组的乘积"><a href="#238-除自身以外数组的乘积" class="headerlink" title="238. 除自身以外数组的乘积"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/product-of-array-except-self/">238. 除自身以外数组的乘积</a></h3><p>给你一个长度为 n 的整数数组 nums，其中 n &gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4]</span><br><span class="line">输出: [24,12,8,6]</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">productExceptSelf</span>(<span class="params">self, nums: [<span class="built_in">int</span>]</span>) -&gt; [int]:</span></span><br><span class="line">        res, p, q = [<span class="number">1</span>], <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) - <span class="number">1</span>): <span class="comment"># bottom triangle</span></span><br><span class="line">            p *= nums[i]</span><br><span class="line">            res.append(p)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) - <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>): <span class="comment"># top triangle</span></span><br><span class="line">            q *= nums[i]</span><br><span class="line">            res[i - <span class="number">1</span>] *= q</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h3 id="628-三个数的最大乘积"><a href="#628-三个数的最大乘积" class="headerlink" title="628. 三个数的最大乘积"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-product-of-three-numbers/">628. 三个数的最大乘积</a></h3><p>给你一个整型数组 <code>nums</code> ，在数组中找出由三个数组成的最大乘积，并输出这个乘积。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3]</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximumProduct</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="comment"># 全正数 或者 全负数</span></span><br><span class="line">        res1 = nums[-<span class="number">1</span>]*nums[-<span class="number">2</span>]*nums[-<span class="number">3</span>]</span><br><span class="line">        <span class="comment"># 有正数有负数</span></span><br><span class="line">        res2 = nums[<span class="number">0</span>]*nums[<span class="number">1</span>]*nums[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(res1, res2)</span><br></pre></td></tr></table></figure>



<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">160. 相交链表</a></h2><p>一种比较巧妙的方式是，分别为链表A和链表B设置指针A和指针B，然后开始遍历链表，如果遍历完当前链表，则将指针指向另外一个链表的头部继续遍历，直至两个指针相遇。<br>最终两个指针分别走过的路径为：<br>指针A :a+c+b<br>指针B :b+c+a<br>明显 a+c+b = b+c+a,因而如果两个链表相交，则指针A和指针B必定在相交结点相遇。</p>
<p>这一方法的时间复杂度为o(m+n),其中m和n分别为两个指针的长度，空间复杂度为o(1)。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> headA <span class="keyword">or</span> <span class="keyword">not</span> headB:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        nodeA = headA <span class="comment"># A 节点</span></span><br><span class="line">        nodeB = headB <span class="comment"># B 节点</span></span><br><span class="line">        <span class="comment"># 相遇 A+C+B = B+C+A</span></span><br><span class="line">        <span class="keyword">while</span>(nodeA !=nodeB):</span><br><span class="line">            nodeA = nodeA.<span class="built_in">next</span> <span class="keyword">if</span> nodeA <span class="keyword">else</span> headB</span><br><span class="line">            nodeB = nodeB.<span class="built_in">next</span> <span class="keyword">if</span> nodeB <span class="keyword">else</span> headA</span><br><span class="line">        <span class="keyword">return</span> nodeA</span><br></pre></td></tr></table></figure>

<h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-linked-list/">206. 反转链表</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 迭代</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        pre, cur = <span class="literal">None</span>, head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            nxt = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = nxt</span><br><span class="line">        <span class="keyword">return</span> pre</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        newHead = self.reverseList(head.<span class="built_in">next</span>)</span><br><span class="line">        head.<span class="built_in">next</span>.<span class="built_in">next</span> = head</span><br><span class="line">        head.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> newHead</span><br></pre></td></tr></table></figure>

<h2 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">92. 反转链表 II</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBetween</span>(<span class="params">self, head: ListNode, left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="comment"># 设置 dummyNode 是这一类问题的一般做法</span></span><br><span class="line">        dummy_node = ListNode()</span><br><span class="line">        dummy_node.<span class="built_in">next</span> = head</span><br><span class="line">        pre = dummy_node</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(left - <span class="number">1</span>):</span><br><span class="line">            pre = pre.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        cur = pre.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(right - left):</span><br><span class="line">            nxt = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = nxt.<span class="built_in">next</span></span><br><span class="line">            nxt.<span class="built_in">next</span> = pre.<span class="built_in">next</span></span><br><span class="line">            pre.<span class="built_in">next</span> = nxt</span><br><span class="line">        <span class="keyword">return</span> dummy_node.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>



<h2 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></h2><p>如果 l1 或者 l2 一开始就是空链表 ，那么没有任何操作需要合并，所以我们只需要返回非空链表。否则，我们要判断 l1 和 l2 哪一个链表的头节点的值更小，然后递归地决定下一个添加到结果里的节点。如果两个链表有一个为空，递归结束。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 递归</span></span><br><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="comment"># 终止条件，直到两个链表都空</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l1: <span class="keyword">return</span> l2  </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l2: <span class="keyword">return</span> l1</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 递归调用</span></span><br><span class="line">        <span class="keyword">if</span> l1.val &lt;= l2.val:  </span><br><span class="line">            l1.<span class="built_in">next</span> = self.mergeTwoLists(l1.<span class="built_in">next</span>, l2)</span><br><span class="line">            <span class="keyword">return</span> l1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l2.<span class="built_in">next</span> = self.mergeTwoLists(l1, l2.<span class="built_in">next</span>)</span><br><span class="line">            <span class="keyword">return</span> l2</span><br></pre></td></tr></table></figure>

<h2 id="83-删除排序链表中的重复元素"><a href="#83-删除排序链表中的重复元素" class="headerlink" title="83. 删除排序链表中的重复元素"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">83. 删除排序链表中的重复元素</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 递归</span></span><br><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="keyword">if</span> head.val != head.<span class="built_in">next</span>.val:</span><br><span class="line">            head.<span class="built_in">next</span> = self.deleteDuplicates(head.<span class="built_in">next</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            move = head.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">while</span> move.<span class="built_in">next</span> <span class="keyword">and</span> head.val == move.<span class="built_in">next</span>.val:</span><br><span class="line">                move = move.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span> self.deleteDuplicates(move)</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 递归 删除相同元素</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>: <span class="keyword">return</span> head</span><br><span class="line">        head.<span class="built_in">next</span> = self.deleteDuplicates(head.<span class="built_in">next</span>)</span><br><span class="line">        <span class="keyword">return</span> head <span class="keyword">if</span> head.val != head.<span class="built_in">next</span>.val <span class="keyword">else</span> head.<span class="built_in">next</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 一次遍历</span></span><br><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        prev, cur = head, head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> cur.val == prev.val:</span><br><span class="line">                prev.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                prev = cur</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>

<h2 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">一种容易想到的方法是，我们首先从头节点开始对链表进行一次遍历，得到链表的长度 L。随后我们再从头节点开始对链表进行一次遍历，当遍历到第 L-n+1 个节点时，它就是我们需要删除的节点。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span>(<span class="params">self, head: ListNode, n: <span class="built_in">int</span></span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">getLength</span>(<span class="params">head: ListNode</span>) -&gt; int:</span></span><br><span class="line">            length = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> head:</span><br><span class="line">                length += <span class="number">1</span></span><br><span class="line">                head = head.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span> length</span><br><span class="line">        </span><br><span class="line">        dummy = ListNode(<span class="number">0</span>, head)</span><br><span class="line">        length = getLength(head)</span><br><span class="line">        cur = dummy</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, length - n + <span class="number">1</span>):</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        cur.<span class="built_in">next</span> = cur.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">我们也可以在遍历链表的同时将所有节点依次入栈。根据栈「先进后出」的原则，我们弹出栈的第 n 个节点就是需要删除的节点，并且目前栈顶的节点就是待删除节点的前驱节点。这样一来，删除操作就变得十分方便了。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span>(<span class="params">self, head: ListNode, n: <span class="built_in">int</span></span>) -&gt; ListNode:</span></span><br><span class="line">        dummy = ListNode(<span class="number">0</span>, head)</span><br><span class="line">        stack = <span class="built_in">list</span>()</span><br><span class="line">        cur = dummy</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            stack.append(cur)</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            stack.pop()</span><br><span class="line"></span><br><span class="line">        prev = stack[-<span class="number">1</span>]</span><br><span class="line">        prev.<span class="built_in">next</span> = prev.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<h2 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        newHead = head.<span class="built_in">next</span></span><br><span class="line">        head.<span class="built_in">next</span> = self.swapPairs(newHead.<span class="built_in">next</span>)</span><br><span class="line">        newHead.<span class="built_in">next</span> = head</span><br><span class="line">        <span class="keyword">return</span> newHead</span><br><span class="line"></span><br><span class="line"><span class="comment"># 迭代</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        dummy = ListNode()</span><br><span class="line">        dummy.<span class="built_in">next</span> = head</span><br><span class="line">        tmp = dummy</span><br><span class="line">        <span class="keyword">while</span> tmp.<span class="built_in">next</span> <span class="keyword">and</span> tmp.<span class="built_in">next</span>.<span class="built_in">next</span>:</span><br><span class="line">            node1 = tmp.<span class="built_in">next</span></span><br><span class="line">            node2 = node1.<span class="built_in">next</span></span><br><span class="line">            tmp.<span class="built_in">next</span> = node2</span><br><span class="line">            node1.<span class="built_in">next</span> = node2.<span class="built_in">next</span></span><br><span class="line">            node2.<span class="built_in">next</span> = node1</span><br><span class="line">            tmp = node1</span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<h2 id="445-两数相加-II"><a href="#445-两数相加-II" class="headerlink" title="445. 两数相加 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/add-two-numbers-ii/">445. 两数相加 II</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> l1 == <span class="literal">None</span>: <span class="keyword">return</span> l2</span><br><span class="line">        <span class="keyword">if</span> l2 == <span class="literal">None</span>: <span class="keyword">return</span> l1</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">listnode2stack</span>(<span class="params">node</span>):</span>  <span class="comment"># 将链表转换为各位的数字并压入栈中，返回一个 stack,栈底为数字的高位，栈顶为数字的低位</span></span><br><span class="line">            res = []</span><br><span class="line">            <span class="keyword">while</span> node:</span><br><span class="line">                res.append(node.val)</span><br><span class="line">                node = node.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        stack1, stack2 = listnode2stack(l1), listnode2stack(l2)</span><br><span class="line">        remaining = <span class="number">0</span>  <span class="comment"># 存储 10 进制下进位数</span></span><br><span class="line">        dummynode = ListNode()  <span class="comment"># 创建一个 dummynode，链表通常都需要创建一个 dummynode</span></span><br><span class="line">        <span class="keyword">while</span> stack1 != [] <span class="keyword">or</span> stack2 != [] <span class="keyword">or</span> remaining != <span class="number">0</span>:  <span class="comment"># 当 stack 或进位数不为空</span></span><br><span class="line">            tmp_sum = remaining  <span class="comment"># 定义 tmp_sum 为某一位数上累计的值</span></span><br><span class="line">            <span class="comment"># 栈顶为数字的低位，如果有则累加到这一位对应的 tmp_sum 中</span></span><br><span class="line">            <span class="keyword">if</span> stack1 != []:</span><br><span class="line">                tmp_sum += stack1.pop()</span><br><span class="line">            <span class="keyword">if</span> stack2 != []:</span><br><span class="line">                tmp_sum += stack2.pop()</span><br><span class="line">            new_node = ListNode(tmp_sum % <span class="number">10</span>)  <span class="comment"># 创建新节点存储当前位的数字，由于存在进位，所以新节点的值为 tmp_sum 对 10 取余数</span></span><br><span class="line">            remaining = tmp_sum // <span class="number">10</span>  <span class="comment"># 更新 remainging,即进到下一高位的值，即 tmp 对 10 的商</span></span><br><span class="line">            new_node.<span class="built_in">next</span> = dummynode.<span class="built_in">next</span>  <span class="comment"># 将新节点的 next 指向 dummynode 的 next</span></span><br><span class="line">            dummynode.<span class="built_in">next</span> = new_node  <span class="comment"># 更新 dummynode 的 next 让它指向新节点</span></span><br><span class="line">        <span class="keyword">return</span> dummynode.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<h2 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/palindrome-linked-list/">234. 回文链表</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数组</span></span><br><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, head: ListNode</span>) -&gt; bool:</span></span><br><span class="line">        vals = []</span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            vals.append(cur.val)</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> vals == vals[::-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, head: ListNode</span>) -&gt; bool:</span></span><br><span class="line"></span><br><span class="line">        self.front_pointer = head</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">recursively_check</span>(<span class="params">current_node=head</span>):</span></span><br><span class="line">            <span class="keyword">if</span> current_node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> recursively_check(current_node.<span class="built_in">next</span>):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">if</span> self.front_pointer.val != current_node.val:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                self.front_pointer = self.front_pointer.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> recursively_check()</span><br></pre></td></tr></table></figure>

<h2 id="725-分隔链表"><a href="#725-分隔链表" class="headerlink" title="725. 分隔链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/split-linked-list-in-parts/">725. 分隔链表</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">splitListToParts</span>(<span class="params">self, root, k</span>):</span></span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">for</span> N <span class="keyword">in</span> xrange(<span class="number">1001</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur: <span class="keyword">break</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        width, remainder = <span class="built_in">divmod</span>(N, k)</span><br><span class="line"></span><br><span class="line">        ans = []</span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(k):</span><br><span class="line">            head = write = ListNode(<span class="literal">None</span>)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(width + (i &lt; remainder)):</span><br><span class="line">                write.<span class="built_in">next</span> = write = ListNode(cur.val)</span><br><span class="line">                <span class="keyword">if</span> cur: cur = cur.<span class="built_in">next</span></span><br><span class="line">            ans.append(head.<span class="built_in">next</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="328-奇偶链表"><a href="#328-奇偶链表" class="headerlink" title="328. 奇偶链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/odd-even-linked-list/">328. 奇偶链表</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">oddEvenList</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        half = mid = head.<span class="built_in">next</span></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> mid <span class="keyword">and</span> mid.<span class="built_in">next</span>:</span><br><span class="line">            cur.<span class="built_in">next</span> = mid.<span class="built_in">next</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">            mid.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">            mid = mid.<span class="built_in">next</span></span><br><span class="line">        cur.<span class="built_in">next</span> = half</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>

<h1 id="树-1"><a href="#树-1" class="headerlink" title="树"></a>树</h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><h3 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 深度优先遍历，树高为root的左子树和右子树中最高的高度加1（root节点）</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">树的总深度 = max(左子树深度，右子树深度) + 当前节点所在的一层深度</span></span><br><span class="line"><span class="string">左子树深度 = max(左子树的左子树深度，左子树的右子树深度) + 当前节点所在的一层深度</span></span><br><span class="line"><span class="string">右子树深度 = max(右子树的左子树深度，右子树的右子树深度) + 当前节点所在的一层深度</span></span><br><span class="line"><span class="string">递归，直到节点为null</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span>(<span class="params">self, root: TreeNode</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        l = self.maxDepth(root.left)</span><br><span class="line">        r = self.maxDepth(root.right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(l, r) + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110. 平衡二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/balanced-binary-tree/">110. 平衡二叉树</a></h3><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
<p>本题中，一棵高度平衡二叉树定义为：</p>
<blockquote>
<p>一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1 。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 求左右子树的高度</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span>(<span class="params">self, root: TreeNode</span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(self.height(root.right)-self.height(root.left))&lt;<span class="number">2</span> <span class="keyword">and</span> self.isBalanced(root.left) <span class="keyword">and</span> self.isBalanced(root.right)</span><br><span class="line">	<span class="comment"># 求高度</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">height</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+<span class="built_in">max</span>(self.height(node.right),self.height(node.left))</span><br></pre></td></tr></table></figure>

<h3 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543. 二叉树的直径"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">543. 二叉树的直径</a></h3><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">diameterOfBinaryTree</span>(<span class="params">self, root: TreeNode</span>) -&gt; int:</span></span><br><span class="line">        self.ans = <span class="number">1</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">depth</span>(<span class="params">node</span>):</span></span><br><span class="line">            <span class="comment"># 访问到空节点了，返回0</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="comment"># 左儿子为根的子树的深度</span></span><br><span class="line">            L = depth(node.left)</span><br><span class="line">            <span class="comment"># 右儿子为根的子树的深度</span></span><br><span class="line">            R = depth(node.right)</span><br><span class="line">            <span class="comment"># 计算d_node即L+R+1 并更新ans</span></span><br><span class="line">            self.ans = <span class="built_in">max</span>(self.ans, L + R + <span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 返回该节点为根的子树的深度</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(L, R) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        depth(root)</span><br><span class="line">        <span class="keyword">return</span> self.ans - <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/invert-binary-tree/">226. 翻转二叉树</a></h3><p>只要把二叉树上的每一个节点的左右子节点进行交换，最后的结果就是完全翻转之后的二叉树。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span>(<span class="params">self, root: TreeNode</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        </span><br><span class="line">        left = self.invertTree(root.left)</span><br><span class="line">        right = self.invertTree(root.right)</span><br><span class="line">        </span><br><span class="line">        root.left, root.right = right, left <span class="comment"># 交换</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h3 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617. 合并二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-two-binary-trees/">617. 合并二叉树</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTrees</span>(<span class="params">self, t1: TreeNode, t2: TreeNode</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> t1:</span><br><span class="line">            <span class="keyword">return</span> t2</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> t2:</span><br><span class="line">            <span class="keyword">return</span> t1</span><br><span class="line">        </span><br><span class="line">        merged = TreeNode(t1.val + t2.val)</span><br><span class="line">        merged.left = self.mergeTrees(t1.left, t2.left)</span><br><span class="line">        merged.right = self.mergeTrees(t1.right, t2.right)</span><br><span class="line">        <span class="keyword">return</span> merged</span><br></pre></td></tr></table></figure>

<h3 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum/">112. 路径总和</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPathSum</span>(<span class="params">self, root: TreeNode, <span class="built_in">sum</span>: <span class="built_in">int</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">sum</span> == root.val</span><br><span class="line">        <span class="keyword">return</span> self.hasPathSum(root.left, <span class="built_in">sum</span> - root.val) <span class="keyword">or</span> self.hasPathSum(root.right, <span class="built_in">sum</span> - root.val)</span><br></pre></td></tr></table></figure>

<h3 id="437-路径总和-III"><a href="#437-路径总和-III" class="headerlink" title="437. 路径总和 III"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum-iii/">437. 路径总和 III</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span>(<span class="params">self, root: TreeNode, <span class="built_in">sum</span>: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root, sumlist</span>):</span></span><br><span class="line">            <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">            sumlist = [num + root.val <span class="keyword">for</span> num <span class="keyword">in</span> sumlist]</span><br><span class="line">            sumlist.append(root.val)</span><br><span class="line">            </span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> sumlist:</span><br><span class="line">                <span class="keyword">if</span> num == <span class="built_in">sum</span>:</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">            <span class="comment"># count = sumlist.count(sum)</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> count + dfs(root.left, sumlist) + dfs(root.right, sumlist)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(root, [])</span><br></pre></td></tr></table></figure>

<h3 id="572-另一棵树的子树"><a href="#572-另一棵树的子树" class="headerlink" title="572. 另一棵树的子树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subtree-of-another-tree/">572. 另一棵树的子树</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">而判断 t 是否为 s 的子树的三个条件是或的关系，即：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">当前两棵树相等；</span></span><br><span class="line"><span class="string">或者，t 是 s 的左子树；</span></span><br><span class="line"><span class="string">或者，t 是 s 的右子树。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubtree</span>(<span class="params">self, s, t</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: TreeNode</span></span><br><span class="line"><span class="string">        :type t: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">and</span> <span class="keyword">not</span> t:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">or</span> <span class="keyword">not</span> t:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> self.isSameTree(s, t) <span class="keyword">or</span> self.isSubtree(s.left, t) <span class="keyword">or</span> self.isSubtree(s.right, t)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSameTree</span>(<span class="params">self, s, t</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">and</span> <span class="keyword">not</span> t:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">or</span> <span class="keyword">not</span> t:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> s.val == t.val <span class="keyword">and</span> self.isSameTree(s.left, t.left) <span class="keyword">and</span> self.isSameTree(s.right, t.right)</span><br></pre></td></tr></table></figure>

<h3 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/symmetric-tree/">101. 对称二叉树</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span>(<span class="params">self, root</span>):</span></span><br><span class="line">		<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">		:type root: TreeNode</span></span><br><span class="line"><span class="string">		:rtype: bool</span></span><br><span class="line"><span class="string">		&quot;&quot;&quot;</span></span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">left,right</span>):</span></span><br><span class="line">			<span class="comment"># 递归的终止条件是两个节点都为空</span></span><br><span class="line">			<span class="comment"># 或者两个节点中有一个为空</span></span><br><span class="line">			<span class="comment"># 或者两个节点的值不相等</span></span><br><span class="line">			<span class="keyword">if</span> <span class="keyword">not</span> (left <span class="keyword">or</span> right):</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">			<span class="keyword">if</span> <span class="keyword">not</span> (left <span class="keyword">and</span> right):</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">			<span class="keyword">if</span> left.val!=right.val:</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">			<span class="keyword">return</span> dfs(left.left,right.right) <span class="keyword">and</span> dfs(left.right,right.left)</span><br><span class="line">		<span class="comment"># 用递归函数，比较左节点，右节点</span></span><br><span class="line">		<span class="keyword">return</span> dfs(root.left,root.right)</span><br></pre></td></tr></table></figure>

<h3 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111. 二叉树的最小深度"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDepth</span>(<span class="params">self, root: TreeNode</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">node</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">min</span>(dfs(node.left) , dfs(node.right)) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dfs(root)</span><br></pre></td></tr></table></figure>

<h3 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404. 左叶子之和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sum-of-left-leaves/">404. 左叶子之和</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumOfLeftLeaves</span>(<span class="params">self, root: TreeNode</span>) -&gt; int:</span></span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root, flag = <span class="literal">False</span></span>):</span>            <span class="comment"># 初始化flag = False</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="number">0</span>               <span class="comment"># 先判断root是否为None，否则下面的判断语句会报错</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.right <span class="keyword">and</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> flag:    <span class="comment"># 前两个条件保证是否是叶子节点，flag保证是否是左孩子</span></span><br><span class="line">                <span class="keyword">return</span> root.val                 <span class="comment"># 如果是左叶子结点就加上其值</span></span><br><span class="line">            <span class="keyword">return</span> dfs(root.right, <span class="literal">False</span>) + dfs(root.left, <span class="literal">True</span>)   <span class="comment"># 递归root的左孩子并让flag = True, 右孩子flag = False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(root)                        <span class="comment"># 返回结果</span></span><br></pre></td></tr></table></figure>

<h3 id="687-最长同值路径"><a href="#687-最长同值路径" class="headerlink" title="687. 最长同值路径"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-univalue-path/">687. 最长同值路径</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestUnivaluePath</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        self.ans = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">arrow_length</span>(<span class="params">node</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            left_length = arrow_length(node.left)</span><br><span class="line">            right_length = arrow_length(node.right)</span><br><span class="line">            left_arrow = right_arrow = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> node.left <span class="keyword">and</span> node.left.val == node.val:</span><br><span class="line">                left_arrow = left_length + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> node.right <span class="keyword">and</span> node.right.val == node.val:</span><br><span class="line">                right_arrow = right_length + <span class="number">1</span></span><br><span class="line">            self.ans = <span class="built_in">max</span>(self.ans, left_arrow + right_arrow)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(left_arrow, right_arrow)</span><br><span class="line"></span><br><span class="line">        arrow_length(root)</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br></pre></td></tr></table></figure>

<h3 id="337-打家劫舍-III"><a href="#337-打家劫舍-III" class="headerlink" title="337. 打家劫舍 III"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/house-robber-iii/">337. 打家劫舍 III</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span>(<span class="params">self, root: TreeNode</span>) -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">_rob</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span>  <span class="comment"># 偷，不偷</span></span><br><span class="line"></span><br><span class="line">            left = _rob(root.left)</span><br><span class="line">            right = _rob(root.right)</span><br><span class="line">            <span class="comment"># 偷当前节点, 则左右子树都不能偷</span></span><br><span class="line">            v1 = root.val + left[<span class="number">1</span>] + right[<span class="number">1</span>]</span><br><span class="line">            <span class="comment"># 不偷当前节点, 则取左右子树中最大的值</span></span><br><span class="line">            v2 = <span class="built_in">max</span>(left) + <span class="built_in">max</span>(right)</span><br><span class="line">            <span class="keyword">return</span> v1, v2</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(_rob(root))</span><br></pre></td></tr></table></figure>

<h3 id="671-二叉树中第二小的节点"><a href="#671-二叉树中第二小的节点" class="headerlink" title="671. 二叉树中第二小的节点"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/">671. 二叉树中第二小的节点</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findSecondMinimumValue</span>(<span class="params">self, root: TreeNode</span>) -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">find_sec</span>(<span class="params">node</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> node.val!=root.val:</span><br><span class="line">                <span class="keyword">return</span> node.val</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">min</span>(find_sec(node.left), find_sec(node.right))</span><br><span class="line">        x=find_sec(root)</span><br><span class="line">        <span class="keyword">if</span> x==<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>):</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>

<h3 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116. 填充每个节点的下一个右侧节点指针"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/">116. 填充每个节点的下一个右侧节点指针</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; &#x27;Node&#x27;:</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 从根节点开始</span></span><br><span class="line">        leftmost = root</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> leftmost.left:</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 遍历这一层节点组织成的链表，为下一层的节点更新 next 指针</span></span><br><span class="line">            head = leftmost</span><br><span class="line">            <span class="keyword">while</span> head:</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># CONNECTION 1</span></span><br><span class="line">                head.left.<span class="built_in">next</span> = head.right</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># CONNECTION 2</span></span><br><span class="line">                <span class="keyword">if</span> head.<span class="built_in">next</span>:</span><br><span class="line">                    head.right.<span class="built_in">next</span> = head.<span class="built_in">next</span>.left</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 指针向后移动</span></span><br><span class="line">                head = head.<span class="built_in">next</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 去下一层的最左的节点</span></span><br><span class="line">            leftmost = leftmost.left</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root </span><br></pre></td></tr></table></figure>



<h2 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h2><h3 id="637-二叉树的层平均值"><a href="#637-二叉树的层平均值" class="headerlink" title="637. 二叉树的层平均值"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/">637. 二叉树的层平均值</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># BFS</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">averageOfLevels</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[float]:</span></span><br><span class="line">        <span class="comment"># 题目数组非空，</span></span><br><span class="line">        <span class="comment"># if not root:</span></span><br><span class="line">        <span class="comment">#     return []</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 返回结果</span></span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">        <span class="comment"># 定义队列</span></span><br><span class="line">        queue = deque()</span><br><span class="line">        <span class="comment"># 将根节点入队</span></span><br><span class="line">        queue.append(root)</span><br><span class="line">        <span class="comment"># 队列不为空，表达式二叉树还有节点，循环遍历</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            <span class="comment"># 先标记每层的节点数</span></span><br><span class="line">            size = <span class="built_in">len</span>(queue)</span><br><span class="line">            <span class="comment"># 定义变量，记录每次节点值</span></span><br><span class="line">            total = <span class="number">0</span></span><br><span class="line">            <span class="comment"># 这里开始遍历当前层的节点</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">                <span class="comment"># 出队</span></span><br><span class="line">                node = queue.popleft()</span><br><span class="line">                <span class="comment"># 先将当前节点的值存储</span></span><br><span class="line">                total += node.val</span><br><span class="line">                <span class="comment"># 节点的左右节点非空时，入队</span></span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">            <span class="comment"># 添加每层的节点值均值</span></span><br><span class="line">            res.append(total/size)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment"># DFS</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">averageOfLevels</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[float]:</span></span><br><span class="line">        totals = []</span><br><span class="line">        cnts = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">node, depth</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> depth &gt;= <span class="built_in">len</span>(totals):</span><br><span class="line">                totals.append(node.val)</span><br><span class="line">                cnts.append(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                totals[depth] += node.val</span><br><span class="line">                cnts[depth] += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            dfs(node.left, depth+<span class="number">1</span>)</span><br><span class="line">            dfs(node.right, depth+<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        dfs(root, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [total / cnt <span class="keyword">for</span> total, cnt <span class="keyword">in</span> <span class="built_in">zip</span>(totals, cnts)]</span><br></pre></td></tr></table></figure>

<h3 id="513-找树左下角的值"><a href="#513-找树左下角的值" class="headerlink" title="513. 找树左下角的值"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-bottom-left-tree-value/">513. 找树左下角的值</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findBottomLeftValue</span>(<span class="params">self, root: TreeNode</span>) -&gt; int:</span></span><br><span class="line">        queue = deque()</span><br><span class="line">        <span class="keyword">if</span> root: </span><br><span class="line">            queue.append(root)</span><br><span class="line">            </span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> queue: </span><br><span class="line">            q_len = <span class="built_in">len</span>(queue)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(q_len): </span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span>: </span><br><span class="line">                    result = queue[i].val </span><br><span class="line">                cur = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> cur.left: </span><br><span class="line">                    queue.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right: </span><br><span class="line">                    queue.append(cur.right)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h2 id="前中后序遍历"><a href="#前中后序遍历" class="headerlink" title="前中后序遍历"></a>前中后序遍历</h2><p>遍历方式</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1guiko5f8g3j60h20eagly02.jpg" alt="img"></p>
<ul>
<li>Preoder 根左右：<code>根节点 -&gt; 左孩子 -&gt; 右孩子</code> 的方式遍历，即「先序遍历」，每次先遍历根节点，遍历结果为 <code>1 2 4 5 3 6 7</code>；</li>
<li>Inorder 左根右：<code>左孩子 -&gt; 根节点 -&gt; 右孩子</code> 的方式遍历，即「中序序遍历」，遍历结果为 <code>4 2 5 1 6 3 7</code>；</li>
<li>Postoder 左右根：<code>左孩子 -&gt; 右孩子 -&gt; 根节点</code> 的方式遍历，即「后序序遍历」，遍历结果为 <code>4 5 2 6 7 3 1</code>；</li>
<li>上左右下：<code>层次遍历</code> 就是按照每一层从左向右的方式进行遍历，遍历结果为<code>1 2 3 4 5 6 7</code>。</li>
</ul>
<h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 递归</span></span><br><span class="line"><span class="comment"># 时间复杂度：O(n)，n为节点数，访问每个节点恰好一次。</span></span><br><span class="line"><span class="comment"># 空间复杂度：空间复杂度：O(h)，h为树的高度。最坏情况下需要空间O(n)，平均情况为O(logn)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归1：二叉树遍历最易理解和实现版本</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="comment"># 前序递归</span></span><br><span class="line">        <span class="keyword">return</span> [root.val] + self.preorderTraversal(root.left) + self.preorderTraversal(root.right)</span><br><span class="line">        <span class="comment"># 中序递归 </span></span><br><span class="line">        <span class="keyword">return</span> self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)</span><br><span class="line">        <span class="comment"># 后序递归</span></span><br><span class="line">        <span class="keyword">return</span> self.postorderTraversal(root.left) + self.postorderTraversal(root.right) + [root.val]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归2：通用模板，可以适应不同的题目，添加参数、增加返回条件、修改进入递归条件、自定义返回值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">cur</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur:</span><br><span class="line">                <span class="keyword">return</span>      </span><br><span class="line">            <span class="comment"># 前序递归</span></span><br><span class="line">            res.append(cur.val)</span><br><span class="line">            dfs(cur.left)</span><br></pre></td></tr></table></figure>



<h3 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></h3><p>按照访问根节点——左子树——右子树的方式遍历这棵树</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">preorder</span>(<span class="params">root: TreeNode</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            res.append(root.val) <span class="comment"># 根</span></span><br><span class="line">            preorder(root.left)  <span class="comment"># 左根</span></span><br><span class="line">            preorder(root.right) <span class="comment"># 右根</span></span><br><span class="line">        </span><br><span class="line">        res = <span class="built_in">list</span>()</span><br><span class="line">        preorder(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h3 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145. 二叉树的后序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a></h3><p>按照访问左子树——右子树——根节点的方式遍历这棵树</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">postorder</span>(<span class="params">root: TreeNode</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            postorder(root.left)</span><br><span class="line">            postorder(root.right)</span><br><span class="line">            res.append(root.val)</span><br><span class="line">        </span><br><span class="line">        res = <span class="built_in">list</span>()</span><br><span class="line">        postorder(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h3 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inorder</span>(<span class="params">root: TreeNode</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            inorder(root.left)</span><br><span class="line">            res.append(root.val)</span><br><span class="line">            inorder(root.right)</span><br><span class="line">            </span><br><span class="line">        </span><br><span class="line">        res = <span class="built_in">list</span>()</span><br><span class="line">        inorder(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="BST二叉查找树"><a href="#BST二叉查找树" class="headerlink" title="BST二叉查找树"></a>BST二叉查找树</h2><p>二叉搜索树是一个有序树：</p>
<ul>
<li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li>
<li>它的左、右子树也分别为二叉搜索树</li>
</ul>
<h3 id="二叉树迭代"><a href="#二叉树迭代" class="headerlink" title="二叉树迭代"></a>二叉树迭代</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchBST</span>(<span class="params">self, root: TreeNode, val: <span class="built_in">int</span></span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="comment"># 为什么要有返回值: </span></span><br><span class="line">        <span class="comment">#   因为搜索到目标节点就要立即return，</span></span><br><span class="line">        <span class="comment">#   这样才是找到节点就返回（搜索某一条边），如果不加return，就是遍历整棵树了。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">or</span> root.val == val: </span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> root.val &gt; val: </span><br><span class="line">            <span class="keyword">return</span> self.searchBST(root.left, val)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> root.val &lt; val: </span><br><span class="line">            <span class="keyword">return</span> self.searchBST(root.right, val)</span><br></pre></td></tr></table></figure>



<h3 id="669-修剪二叉搜索树"><a href="#669-修剪二叉搜索树" class="headerlink" title="669. 修剪二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/trim-a-binary-search-tree/">669. 修剪二叉搜索树</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"><span class="comment">### [230. 二叉搜索树中第K小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/)</span></span><br><span class="line"></span><br><span class="line">```python</span><br></pre></td></tr></table></figure>

<h3 id="538-把二叉搜索树转换为累加树"><a href="#538-把二叉搜索树转换为累加树" class="headerlink" title="538. 把二叉搜索树转换为累加树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/">538. 把二叉搜索树转换为累加树</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"><span class="comment">### [235. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)</span></span><br><span class="line"></span><br><span class="line">```python</span><br></pre></td></tr></table></figure>

<h3 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"><span class="comment">### [108. 将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)</span></span><br><span class="line"></span><br><span class="line">```python</span><br></pre></td></tr></table></figure>

<h3 id="109-有序链表转换二叉搜索树"><a href="#109-有序链表转换二叉搜索树" class="headerlink" title="109. 有序链表转换二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/">109. 有序链表转换二叉搜索树</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"><span class="comment">### [653. 两数之和 IV - 输入 BST](https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/)</span></span><br><span class="line"></span><br><span class="line">```python</span><br></pre></td></tr></table></figure>

<h3 id="530-二叉搜索树的最小绝对差"><a href="#530-二叉搜索树的最小绝对差" class="headerlink" title="530. 二叉搜索树的最小绝对差"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/">530. 二叉搜索树的最小绝对差</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"><span class="comment">### [501. 二叉搜索树中的众数](https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/)</span></span><br><span class="line"></span><br><span class="line">```python</span><br></pre></td></tr></table></figure>

<h2 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h2><p>Trie，又称前缀树或字典树，用于判断字符串是否存在或者是否具有某种字符串前缀。</p>
<h3 id="208-实现-Trie-前缀树"><a href="#208-实现-Trie-前缀树" class="headerlink" title="208. 实现 Trie (前缀树)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/">208. 实现 Trie (前缀树)</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"><span class="comment">### [677. 键值映射](https://leetcode-cn.com/problems/map-sum-pairs/)</span></span><br><span class="line"></span><br><span class="line">```python</span><br></pre></td></tr></table></figure>

<h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1><ul>
<li>队列是一种 先进先出（first in - first out， FIFO）的数据结构，队列中的元素都从后端（rear）入队（push），从前端（front）出队（pop）。</li>
<li>实现队列最直观的方法是用链表，但在这篇文章里我会介绍另一个方法 - 使用栈。</li>
<li>栈是一种 后进先出（last in - first out， LIFO）的数据结构，栈中元素从栈顶（top）压入（push)，也从栈顶弹出（pop）。</li>
</ul>
<h2 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232. 用栈实现队列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/implement-queue-using-stacks/">232. 用栈实现队列</a></h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvibrcdoldg60u00gwhdx02.gif" alt="232.gif"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为了满足队列的 FIFO 的特性，我们需要用到两个栈，用它们其中一个来反转元素的入队顺序，用另一个来存储元素的最终顺序。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.stack1 = []</span><br><span class="line">        self.stack2 = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.stack1.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.stack2:</span><br><span class="line">            <span class="keyword">while</span> self.stack1:</span><br><span class="line">                self.stack2.append(self.stack1.pop())</span><br><span class="line">        <span class="keyword">return</span> self.stack2.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.stack2:</span><br><span class="line">            <span class="keyword">while</span> self.stack1:</span><br><span class="line">                self.stack2.append(self.stack1.pop())</span><br><span class="line">        <span class="keyword">return</span> self.stack2[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">empty</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self.stack1 <span class="keyword">and</span> <span class="keyword">not</span> self.stack2</span><br></pre></td></tr></table></figure>

<h2 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225. 用队列实现栈"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/implement-stack-using-queues/">225. 用队列实现栈</a></h2><p><img src="https://assets.leetcode-cn.com/solution-static/225/225_fig1.gif" alt="fig1"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.queue1 = collections.deque()</span><br><span class="line">        self.queue2 = collections.deque()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Push element x onto stack.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.queue2.append(x)</span><br><span class="line">        <span class="keyword">while</span> self.queue1:</span><br><span class="line">            self.queue2.append(self.queue1.popleft())</span><br><span class="line">        self.queue1, self.queue2 = self.queue2, self.queue1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Removes the element on top of the stack and returns that element.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.queue1.popleft()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Get the top element.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.queue1[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">empty</span>(<span class="params">self</span>) -&gt; bool:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Returns whether the stack is empty.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self.queue1</span><br></pre></td></tr></table></figure>

<h2 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155. 最小栈"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/min-stack/">155. 最小栈</a></h2><p><img src="https://assets.leetcode-cn.com/solution-static/155/155_fig1.gif" alt="fig1"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.stack = []</span><br><span class="line">        self.min_stack = [math.inf]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.stack.append(x)</span><br><span class="line">        self.min_stack.append(<span class="built_in">min</span>(x, self.min_stack[-<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.stack.pop()</span><br><span class="line">        self.min_stack.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.stack[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMin</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.min_stack[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-parentheses/">20. 有效的括号</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        pairs = &#123;</span><br><span class="line">            <span class="string">&quot;)&quot;</span>: <span class="string">&quot;(&quot;</span>,</span><br><span class="line">            <span class="string">&quot;]&quot;</span>: <span class="string">&quot;[&quot;</span>,</span><br><span class="line">            <span class="string">&quot;&#125;&quot;</span>: <span class="string">&quot;&#123;&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        stack = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> ch <span class="keyword">in</span> pairs:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> stack <span class="keyword">or</span> stack[-<span class="number">1</span>] != pairs[ch]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                stack.pop()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.append(ch)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> stack</span><br></pre></td></tr></table></figure>

<h2 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739. 每日温度"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/daily-temperatures/">739. 每日温度</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dailyTemperatures</span>(<span class="params">self, temperatures: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        length = <span class="built_in">len</span>(temperatures)</span><br><span class="line">        ans = [<span class="number">0</span>] * length</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">            temperature = temperatures[i]</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> temperature &gt; temperatures[stack[-<span class="number">1</span>]]:</span><br><span class="line">                prev_index = stack.pop()</span><br><span class="line">                ans[prev_index] = i - prev_index</span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="503-下一个更大元素-II"><a href="#503-下一个更大元素-II" class="headerlink" title="503. 下一个更大元素 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/next-greater-element-ii/">503. 下一个更大元素 II</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextGreaterElements</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        ret = [-<span class="number">1</span>] * n</span><br><span class="line">        stk = <span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n * <span class="number">2</span> - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">while</span> stk <span class="keyword">and</span> nums[stk[-<span class="number">1</span>]] &lt; nums[i % n]:</span><br><span class="line">                ret[stk.pop()] = nums[i % n]</span><br><span class="line">            stk.append(i % n)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/two-sum/">1. 两数之和</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hash table</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[int]:</span></span><br><span class="line">        hashtable = <span class="built_in">dict</span>() </span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> target - num <span class="keyword">in</span> hashtable:</span><br><span class="line">                <span class="keyword">return</span> [hashtable[target - num], i]</span><br><span class="line">            hashtable[nums[i]] = i</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>

<h2 id="217-存在重复元素"><a href="#217-存在重复元素" class="headerlink" title="217. 存在重复元素"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/contains-duplicate/">217. 存在重复元素</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsDuplicate</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; bool:</span></span><br><span class="line">        hashtable = <span class="built_in">dict</span>() </span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">in</span> hashtable:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            hashtable[nums[i]] = i</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h2 id="594-最长和谐子序列"><a href="#594-最长和谐子序列" class="headerlink" title="594. 最长和谐子序列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-harmonious-subsequence/">594. 最长和谐子序列</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLHS</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        dicts = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            dicts[num] = dicts.get(num, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> dicts:</span><br><span class="line">            <span class="keyword">if</span> i + <span class="number">1</span> <span class="keyword">in</span> dicts:</span><br><span class="line">                res=<span class="built_in">max</span>(res, dicts[i] + dicts[i + <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="128-最长连续序列"><a href="#128-最长连续序列" class="headerlink" title="128. 最长连续序列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-consecutive-sequence/">128. 最长连续序列</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestConsecutive</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        longest_streak = <span class="number">0</span></span><br><span class="line">        num_set = <span class="built_in">set</span>(nums)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> num_set:</span><br><span class="line">            <span class="keyword">if</span> num - <span class="number">1</span> <span class="keyword">not</span> <span class="keyword">in</span> num_set:</span><br><span class="line">                current_num = num</span><br><span class="line">                current_streak = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> current_num + <span class="number">1</span> <span class="keyword">in</span> num_set:</span><br><span class="line">                    current_num += <span class="number">1</span></span><br><span class="line">                    current_streak += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                longest_streak = <span class="built_in">max</span>(longest_streak, current_streak)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> longest_streak</span><br></pre></td></tr></table></figure>

<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242. 有效的字母异位词"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-anagram/">242. 有效的字母异位词</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isAnagram</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="comment"># return sorted(list(s)) == sorted(list(t))</span></span><br><span class="line">    	<span class="keyword">return</span> <span class="built_in">sorted</span>(s) == <span class="built_in">sorted</span>(t)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment"># Counter    </span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isAnagram</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        s_ = Counter(s)</span><br><span class="line">        t_ = Counter(t)</span><br><span class="line">        <span class="keyword">return</span> s_ == t_</span><br></pre></td></tr></table></figure>

<h2 id="409-最长回文串"><a href="#409-最长回文串" class="headerlink" title="409. 最长回文串"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-palindrome/">409. 最长回文串</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        count = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> s:</span><br><span class="line">            count[a] += <span class="number">1</span></span><br><span class="line">        length = <span class="number">0</span></span><br><span class="line">        odd = []</span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> count.values():</span><br><span class="line">            <span class="keyword">if</span> value % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                length += value</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                odd.append(value)</span><br><span class="line">        <span class="keyword">if</span> odd != []:</span><br><span class="line">            length += <span class="built_in">sum</span>(odd) - <span class="built_in">len</span>(odd) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> length</span><br></pre></td></tr></table></figure>


<h2 id=""><a href="#" class="headerlink" title=""></a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"><span class="comment">## </span></span><br><span class="line"></span><br><span class="line">```python</span><br></pre></td></tr></table></figure>


<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"><span class="comment">## </span></span><br><span class="line"></span><br><span class="line">```python</span><br></pre></td></tr></table></figure>


<h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"><span class="comment">## </span></span><br><span class="line"></span><br><span class="line">```python</span><br></pre></td></tr></table></figure>

<h1 id="数组与矩阵"><a href="#数组与矩阵" class="headerlink" title="数组与矩阵"></a>数组与矩阵</h1><h2 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/move-zeroes/">283. 移动零</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 双指针</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">moveZeroes</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        left = right = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> right &lt; n:</span><br><span class="line">            <span class="keyword">if</span> nums[right] != <span class="number">0</span>:</span><br><span class="line">                nums[left], nums[right] = nums[right], nums[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># remove append</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">moveZeroes</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="number">0</span> <span class="keyword">in</span> nums:</span><br><span class="line">            nums.remove(<span class="number">0</span>)</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(cnt):</span><br><span class="line">            nums.append(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h2 id="566-重塑矩阵"><a href="#566-重塑矩阵" class="headerlink" title="566. 重塑矩阵"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reshape-the-matrix/">566. 重塑矩阵</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切片</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">matrixReshape</span>(<span class="params">self, nums, r, c</span>):</span></span><br><span class="line">        M, N = <span class="built_in">len</span>(nums), <span class="built_in">len</span>(nums[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> M * N != r * c:</span><br><span class="line">            <span class="keyword">return</span> nums</span><br><span class="line">        res = [[<span class="number">0</span>] * c <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(r)]</span><br><span class="line">        row, col = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(M):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">                <span class="keyword">if</span> col == c:</span><br><span class="line">                    row += <span class="number">1</span></span><br><span class="line">                    col = <span class="number">0</span></span><br><span class="line">                res[row][col] = nums[i][j]</span><br><span class="line">                col += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="485-最大连续-1-的个数"><a href="#485-最大连续-1-的个数" class="headerlink" title="485. 最大连续 1 的个数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/max-consecutive-ones/">485. 最大连续 1 的个数</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 转换为 str 非常耗时...</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMaxConsecutiveOnes</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">  </span><br><span class="line">        strNums = [<span class="built_in">str</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> nums]</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="string">&quot;&quot;</span>.join(strNums).split(<span class="string">&#x27;0&#x27;</span>))):</span><br><span class="line">            res = <span class="built_in">max</span>(res, <span class="built_in">len</span>(<span class="string">&quot;&quot;</span>.join(strNums).split(<span class="string">&#x27;0&#x27;</span>)[i]))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 一次遍历</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMaxConsecutiveOnes</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        maxCount = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num == <span class="number">1</span>:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                maxCount = <span class="built_in">max</span>(maxCount, count)</span><br><span class="line">                count = <span class="number">0</span></span><br><span class="line">        maxCount = <span class="built_in">max</span>(maxCount, count) <span class="comment"># [0, 1, 1, 1]</span></span><br><span class="line">        <span class="keyword">return</span> maxCount</span><br></pre></td></tr></table></figure>

<h2 id="240-搜索二维矩阵-II"><a href="#240-搜索二维矩阵-II" class="headerlink" title="240. 搜索二维矩阵 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/">240. 搜索二维矩阵 II</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchMatrix</span>(<span class="params">self, matrix: List[List[<span class="built_in">int</span>]], target: <span class="built_in">int</span></span>) -&gt; bool:</span></span><br><span class="line">        row = <span class="built_in">len</span>(matrix)</span><br><span class="line">        col = <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 双指针 </span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        j = col - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> matrix[i][j] != target:</span><br><span class="line">            <span class="keyword">if</span> matrix[i][j] &lt; target:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i &gt;= row <span class="keyword">or</span> j &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h2 id="378-有序矩阵中第-K-小的元素"><a href="#378-有序矩阵中第-K-小的元素" class="headerlink" title="378. 有序矩阵中第 K 小的元素"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/">378. 有序矩阵中第 K 小的元素</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span>(<span class="params">self, matrix: List[List[<span class="built_in">int</span>]], k: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        one_matrix = reduce(operator.add, matrix)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sorted</span>(one_matrix)[k - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span>(<span class="params">self, matrix: List[List[<span class="built_in">int</span>]], k: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        rec = <span class="built_in">sorted</span>(<span class="built_in">sum</span>(matrix, []))</span><br><span class="line">        <span class="keyword">return</span> rec[k - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h2 id="645-错误的集合"><a href="#645-错误的集合" class="headerlink" title="645. 错误的集合"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/set-mismatch/">645. 错误的集合</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findErrorNums</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        ln, total = <span class="built_in">len</span>(nums), <span class="built_in">sum</span>(<span class="built_in">set</span>(nums))</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">sum</span>(nums) - total, (<span class="number">1</span> + ln) * ln // <span class="number">2</span> - total] <span class="comment"># 1+2+...+n = n*(n+1)/2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="287-寻找重复数-1"><a href="#287-寻找重复数-1" class="headerlink" title="287. 寻找重复数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-the-duplicate-number/">287. 寻找重复数</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (<span class="built_in">sum</span>(nums) - <span class="built_in">sum</span>(<span class="built_in">set</span>(nums))) // (<span class="built_in">len</span>(nums) - <span class="built_in">len</span>(<span class="built_in">set</span>(nums)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 快慢指针</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findDuplicate</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        slow, fast = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            slow, fast = nums[slow], nums[nums[fast]]</span><br><span class="line">            <span class="keyword">if</span> slow == fast:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        slow = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> slow != fast:</span><br><span class="line">            slow, fast = nums[slow], nums[fast]</span><br><span class="line">        <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure>

<h2 id="667-优美的排列-II"><a href="#667-优美的排列-II" class="headerlink" title="667. 优美的排列 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/beautiful-arrangement-ii/">667. 优美的排列 II</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"><span class="comment">## [697. 数组的度](https://leetcode-cn.com/problems/degree-of-an-array/)</span></span><br><span class="line"></span><br><span class="line">```python</span><br></pre></td></tr></table></figure>

<h2 id="766-托普利茨矩阵"><a href="#766-托普利茨矩阵" class="headerlink" title="766. 托普利茨矩阵"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/toeplitz-matrix/">766. 托普利茨矩阵</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"><span class="comment">## [565. 数组嵌套](https://leetcode-cn.com/problems/array-nesting/)</span></span><br><span class="line"></span><br><span class="line">```python</span><br></pre></td></tr></table></figure>

<h2 id="769-最多能完成排序的块"><a href="#769-最多能完成排序的块" class="headerlink" title="769. 最多能完成排序的块"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/max-chunks-to-make-sorted/">769. 最多能完成排序的块</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"><span class="comment"># 图</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## [785. 判断二分图](https://leetcode-cn.com/problems/is-graph-bipartite/)</span></span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"><span class="comment"># DFS</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBipartite</span>(<span class="params">self, graph: List[List[<span class="built_in">int</span>]]</span>) -&gt; bool:</span></span><br><span class="line">        n = <span class="built_in">len</span>(graph)</span><br><span class="line">        UNCOLORED, RED, GREEN = <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">        color = [UNCOLORED] * n</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> color[i] == UNCOLORED:</span><br><span class="line">                q = collections.deque([i])</span><br><span class="line">                color[i] = RED</span><br><span class="line">                <span class="keyword">while</span> q:</span><br><span class="line">                    node = q.popleft()</span><br><span class="line">                    cNei = (GREEN <span class="keyword">if</span> color[node] == RED <span class="keyword">else</span> RED)</span><br><span class="line">                    <span class="keyword">for</span> neighbor <span class="keyword">in</span> graph[node]:</span><br><span class="line">                        <span class="keyword">if</span> color[neighbor] == UNCOLORED:</span><br><span class="line">                            q.append(neighbor)</span><br><span class="line">                            color[neighbor] = cNei</span><br><span class="line">                        <span class="keyword">elif</span> color[neighbor] != cNei:</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># BFS</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque   <span class="comment">#pycharm不在这导包直接用collections.deque会报错不知为何</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBipartite</span>(<span class="params">self, graph: List[List[<span class="built_in">int</span>]]</span>) -&gt; bool:</span></span><br><span class="line">        <span class="comment">#color[i]标记i结点状态，0为未着色，1为着红色，-1为着蓝色</span></span><br><span class="line">        color = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(graph))]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(graph)):</span><br><span class="line">            <span class="comment">#如果当前顶点未着色，以当前点为起始点bfs对当前连通图着色，起始点着红色</span></span><br><span class="line">            <span class="keyword">if</span> color[i] == <span class="number">0</span>:</span><br><span class="line">                <span class="comment">#对当前联通图顶点涂红色并入队</span></span><br><span class="line">                color[i] = <span class="number">1</span></span><br><span class="line">                queue = deque()</span><br><span class="line">                queue.append(i)</span><br><span class="line">                <span class="comment">#从当前顶点i开始bfs搜索当前连通图</span></span><br><span class="line">                <span class="keyword">while</span> queue:</span><br><span class="line">                    cur = queue.popleft()</span><br><span class="line">                    <span class="comment">#注意是取cur的颜色而不是i的颜色！！！！！！写错了导致彻底错误还不好检查</span></span><br><span class="line">                    col = color[cur]</span><br><span class="line">                    <span class="comment">#遍历当前顶点的所有邻居顶点       </span></span><br><span class="line">                    <span class="keyword">for</span> neighbor <span class="keyword">in</span> graph[cur]:</span><br><span class="line">                        <span class="comment">#如果当前邻居顶点颜色与当前顶点相同，说明不是二分图，直接return False</span></span><br><span class="line">                        <span class="keyword">if</span> color[neighbor] == col:</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                        <span class="comment">#如果当前邻居顶点颜色与当前顶点相反，说明当前邻居顶点已经入队过了，无需重复操作</span></span><br><span class="line">                        <span class="keyword">elif</span> color[neighbor] == -col:</span><br><span class="line">                            <span class="keyword">continue</span></span><br><span class="line">                        <span class="comment">#如果当前邻居顶点未着色，着色为当前顶点相反颜色并入队以便后续搜索当前邻居顶点的邻居顶点</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            color[neighbor] = -col</span><br><span class="line">                            queue.append(neighbor)</span><br><span class="line">        <span class="comment">#所有顶点都着色完毕还没有发现相邻顶点颜色相同，说明是二分图</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h2 id="207-课程表"><a href="#207-课程表" class="headerlink" title="207. 课程表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/course-schedule/">207. 课程表</a></h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvhh6uorykj61ag0e0tan02.jpg" alt="微信截图_20200517052852.png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canFinish</span>(<span class="params">self, numCourses: <span class="built_in">int</span>, prerequisites: List[List[<span class="built_in">int</span>]]</span>) -&gt; bool:</span></span><br><span class="line">        edges = collections.defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        indeg = [<span class="number">0</span>] * numCourses</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> info <span class="keyword">in</span> prerequisites: <span class="comment"># prerequisites = [[1,0],[0,1]]</span></span><br><span class="line">            edges[info[<span class="number">1</span>]].append(info[<span class="number">0</span>])</span><br><span class="line">            indeg[info[<span class="number">0</span>]] += <span class="number">1</span> <span class="comment"># 度</span></span><br><span class="line">        </span><br><span class="line">        q = collections.deque([u <span class="keyword">for</span> u <span class="keyword">in</span> <span class="built_in">range</span>(numCourses) <span class="keyword">if</span> indeg[u] == <span class="number">0</span>])</span><br><span class="line">        visited = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            visited += <span class="number">1</span></span><br><span class="line">            u = q.popleft()</span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> edges[u]:</span><br><span class="line">                indeg[v] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> indeg[v] == <span class="number">0</span>:</span><br><span class="line">                    q.append(v)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> visited == numCourses</span><br></pre></td></tr></table></figure>

<h2 id="210-课程表-II"><a href="#210-课程表-II" class="headerlink" title="210. 课程表 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/course-schedule-ii/">210. 课程表 II</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findOrder</span>(<span class="params">self, numCourses: <span class="built_in">int</span>, prerequisites: List[List[<span class="built_in">int</span>]]</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="comment"># 存储有向图</span></span><br><span class="line">        edges = collections.defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        <span class="comment"># 存储每个节点的入度</span></span><br><span class="line">        indeg = [<span class="number">0</span>] * numCourses</span><br><span class="line">        <span class="comment"># 存储答案</span></span><br><span class="line">        result = <span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> info <span class="keyword">in</span> prerequisites:</span><br><span class="line">            edges[info[<span class="number">1</span>]].append(info[<span class="number">0</span>])</span><br><span class="line">            indeg[info[<span class="number">0</span>]] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 将所有入度为 0 的节点放入队列中</span></span><br><span class="line">        q = collections.deque([u <span class="keyword">for</span> u <span class="keyword">in</span> <span class="built_in">range</span>(numCourses) <span class="keyword">if</span> indeg[u] == <span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            <span class="comment"># 从队首取出一个节点</span></span><br><span class="line">            u = q.popleft()</span><br><span class="line">            <span class="comment"># 放入答案中</span></span><br><span class="line">            result.append(u)</span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> edges[u]:</span><br><span class="line">                indeg[v] -= <span class="number">1</span></span><br><span class="line">                <span class="comment"># 如果相邻节点 v 的入度为 0，就可以选 v 对应的课程了</span></span><br><span class="line">                <span class="keyword">if</span> indeg[v] == <span class="number">0</span>:</span><br><span class="line">                    q.append(v)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(result) != numCourses:</span><br><span class="line">            result = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="684-冗余连接"><a href="#684-冗余连接" class="headerlink" title="684. 冗余连接"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/redundant-connection/">684. 冗余连接</a></h2><p>并查集</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="位运算-1"><a href="#位运算-1" class="headerlink" title="位运算"></a>位运算</h1><h2 id="定义总结"><a href="#定义总结" class="headerlink" title="定义总结"></a>定义总结</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 0s 代表 0000...</span></span><br><span class="line"><span class="comment"># 1s 代表 1111...</span></span><br><span class="line"><span class="comment"># ^ 异或：不同为 1</span></span><br><span class="line"><span class="comment"># &amp; 与：同 1 为 1</span></span><br><span class="line"><span class="comment"># | 或：有 1 为 1</span></span><br><span class="line"><span class="comment"># ～ 非</span></span><br><span class="line"><span class="comment"># &lt;&lt; 左移</span></span><br><span class="line"><span class="comment"># &gt;&gt; 右移</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x ^ 0s = x      </span><br><span class="line">x &amp; 0s = <span class="number">0</span>      </span><br><span class="line">x | 0s = x</span><br><span class="line">x ^ 1s = ~x <span class="comment"># 翻转 1100 -&gt; 0011   </span></span><br><span class="line">x &amp; 1s = x      </span><br><span class="line">x | 1s = 1s</span><br><span class="line">x ^ x = <span class="number">0</span>   <span class="comment"># 去重 1^1^2 = 2    </span></span><br><span class="line">x &amp; x = x       </span><br><span class="line">x | x = x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用 x &amp; 0s = 0 和 x &amp; 1s = x 的特点，可以实现掩码操作</span></span><br><span class="line">01011011 &amp; </span><br><span class="line">00111100   </span><br><span class="line">--------</span><br><span class="line">00011000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用 x | 0s = x 和 x | 1s = 1s 的特点，可以实现设值操作</span></span><br><span class="line">01011011 |</span><br><span class="line">00111100</span><br><span class="line">--------</span><br><span class="line">01111111</span><br><span class="line"></span><br><span class="line"><span class="comment"># n&amp;(n-1) 去除 n 的位级表示中最低的那一位 1</span></span><br><span class="line">01011011 &amp;</span><br><span class="line">01011010</span><br><span class="line">--------</span><br><span class="line">01011010</span><br><span class="line"></span><br><span class="line"><span class="comment"># n&amp;(-n) 得到 n 的位级表示中最低的那一位 1，-n=~n+1</span></span><br><span class="line"><span class="number">10110100</span> &amp;</span><br><span class="line">01001100</span><br><span class="line">--------</span><br><span class="line">00000100</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. num ^ num = 0</span></span><br><span class="line"><span class="comment"># 2. num ^ (-num) 可以使num中第一个1为1, 并使其他位全为0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不需要额外变量交换</span></span><br><span class="line">a = a ^ b</span><br><span class="line">b = a ^ b</span><br><span class="line">a = a ^ b</span><br></pre></td></tr></table></figure>



<h2 id="461-汉明距离"><a href="#461-汉明距离" class="headerlink" title="461. 汉明距离"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/hamming-distance/">461. 汉明距离</a></h2><p>两个整数之间的 汉明距离 指的是这两个数字对应二进制位不同的位置的数目。</p>
<p>给你两个整数 x 和 y，计算并返回它们之间的汉明距离。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：x = 1, y = 4</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">1   (0 0 0 1)</span><br><span class="line">4   (0 1 0 0)</span><br><span class="line"><span class="code">       ↑   ↑</span></span><br><span class="line"><span class="code">上面的箭头指出了对应二进制位不同的位置。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 异或</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingDistance</span>(<span class="params">self, x, y</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bin</span>(x ^ y).count(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 右移</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingDistance</span>(<span class="params">self, x: <span class="built_in">int</span>, y: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        n = x ^ y</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            <span class="keyword">if</span> (n &amp; <span class="number">1</span>): count += <span class="number">1</span> <span class="comment"># 最低位 1</span></span><br><span class="line">            n &gt;&gt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line"><span class="comment"># Brian Kernighan 算法 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingDistance</span>(<span class="params">self, x: <span class="built_in">int</span>, y: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        c = x ^ y</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> c:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            c = c &amp; (c-<span class="number">1</span>) <span class="comment">#  c = c &amp; (c-1) 可以将 c 的最低一位的 1 变为 0</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>

<h2 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136. 只出现一次的数字"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/single-number/">136. 只出现一次的数字</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            nums[<span class="number">0</span>] ^= nums[i]</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums) ):</span><br><span class="line">            nums[<span class="number">0</span>]^=nums[i]</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># reduce() 函数会对参数序列中元素进行累</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x, y: x ^ y, nums)</span><br></pre></td></tr></table></figure>

<h2 id="268-丢失的数字"><a href="#268-丢失的数字" class="headerlink" title="268. 丢失的数字"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/missing-number/">268. 丢失的数字</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">missingNumber</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        missing = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums): <span class="comment"># 不用zip</span></span><br><span class="line">            missing ^= i ^ num</span><br><span class="line">        <span class="keyword">return</span> missing</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 列表求和</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">missingNumber</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="built_in">len</span>(nums) + <span class="number">1</span>))) - <span class="built_in">sum</span>(nums)</span><br></pre></td></tr></table></figure>

<h2 id="260-只出现一次的数字-III"><a href="#260-只出现一次的数字-III" class="headerlink" title="260. 只出现一次的数字 III"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/single-number-iii/">260. 只出现一次的数字 III</a></h2><p>两个不相等的元素在位级表示上必定会有一位存在不同。</p>
<p>将数组的所有元素异或得到的结果为不存在重复的两个元素异或的结果。</p>
<p>diff &amp;= -diff 得到出 diff 最右侧不为 0 的位，也就是不存在重复的两个元素在位级表示上最右侧不同的那一位，利用这一位就可以将两个元素区分开来。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        eor = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            eor ^= num</span><br><span class="line">        rightOne = eor &amp; - eor <span class="comment"># 恰好有两个元素只出现一次</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num &amp; rightOne != <span class="number">0</span>:</span><br><span class="line">                res ^= num</span><br><span class="line">        <span class="keyword">return</span> [res, res ^ eor]</span><br></pre></td></tr></table></figure>

<h2 id="190-颠倒二进制位"><a href="#190-颠倒二进制位" class="headerlink" title="190. 颠倒二进制位"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-bits/">190. 颠倒二进制位</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBits</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">            result = (result &lt;&lt; <span class="number">1</span>) + (n &amp; <span class="number">1</span>)</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h2 id="231-2-的幂"><a href="#231-2-的幂" class="headerlink" title="231. 2 的幂"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/power-of-two/">231. 2 的幂</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPowerOfTwo</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="comment"># 二进制表示只有一个 1 存在。</span></span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> <span class="keyword">and</span> n &amp; (n - <span class="number">1</span>) == <span class="number">0</span></span><br><span class="line">    	<span class="keyword">return</span> <span class="built_in">bin</span>(n).count(<span class="string">&quot;1&quot;</span>) == <span class="number">1</span> <span class="keyword">and</span> n &gt;= <span class="number">0</span> <span class="comment"># 数二进制 1 的个数</span></span><br></pre></td></tr></table></figure>

<h2 id="342-4的幂"><a href="#342-4的幂" class="headerlink" title="342. 4的幂"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/power-of-four/">342. 4的幂</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPowerOfFour</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> <span class="keyword">and</span> (n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span> <span class="keyword">and</span> (n &amp; <span class="number">0xaaaaaaaa</span>) == <span class="number">0</span> <span class="comment"># 这种数在二进制表示中有且只有一个奇数位为 1</span></span><br></pre></td></tr></table></figure>

<h2 id="693-交替位二进制数"><a href="#693-交替位二进制数" class="headerlink" title="693. 交替位二进制数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-number-with-alternating-bits/">693. 交替位二进制数</a></h2><p>如果原始数字符合条件的话，比如101，那么运算后的temp应该是全1的，比如111，这样的话，+1后就变成了1000,&amp;运算后就为0，证明确实是111. 对于其他位数的二进制数也一样的，temp &amp; (temp + 1) == 0 目的就是判断temp 是不是全1二进制数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasAlternatingBits</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        temp = n ^ (n &gt;&gt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> temp &amp; (temp + <span class="number">1</span>) == <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="476-数字的补数"><a href="#476-数字的补数" class="headerlink" title="476. 数字的补数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-complement/">476. 数字的补数</a></h2><p>给你一个 正 整数 num ，输出它的补数。补数是对该数的二进制表示取反。</p>
<p>输入：num = 5<br>输出：2<br>解释：5 的二进制表示为 101（没有前导零位），其补数为 010。所以你需要输出 2 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findComplement</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> num^(<span class="number">2</span>**(<span class="built_in">len</span>(<span class="built_in">bin</span>(num))-<span class="number">2</span>)-<span class="number">1</span>) <span class="comment"># 2**(n-1)-1</span></span><br></pre></td></tr></table></figure>

<h2 id="371-两整数之和"><a href="#371-两整数之和" class="headerlink" title="371. 两整数之和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sum-of-two-integers/">371. 两整数之和</a></h2><p>a ^ b 表示没有考虑进位的情况下两数的和，(a &amp; b) &lt;&lt; 1 就是进位。</p>
<p>递归会终止的原因是 (a &amp; b) &lt;&lt; 1 最右边会多一个 0，那么继续递归，进位最右边的 0 会慢慢增多，最后进位会变为 0，递归终止。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="318-最大单词长度乘积"><a href="#318-最大单词长度乘积" class="headerlink" title="318. 最大单词长度乘积"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-product-of-word-lengths/">318. 最大单词长度乘积</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="338-比特位计数"><a href="#338-比特位计数" class="headerlink" title="338. 比特位计数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/counting-bits/">338. 比特位计数</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countBits</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>):</span><br><span class="line">            res.append(<span class="built_in">bin</span>(i).count(<span class="string">&quot;1&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Ashin Wang"
      src="https://tva1.sinaimg.cn/large/006y8mN6ly1g74lvmm1zhj3074074q4r.jpg">
  <p class="site-author-name" itemprop="name">Ashin Wang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">68</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">86</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/AshinWang" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;AshinWang" rel="noopener" target="_blank"><i class="fa fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ashin Wang</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="//cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script>
<script src="/js/algolia-search.js"></script>














  

  


</body>
</html>
