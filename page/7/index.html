<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.ashin.wang","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"algolia":{"appID":"S30ZCDT4BR","apiKey":"6988e9b27ba9570d9ed85020ebf48b01","indexName":"blog","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Ashin Wang&#39;s Blog">
<meta property="og:url" content="https://www.ashin.wang/page/7/index.html">
<meta property="og:site_name" content="Ashin Wang&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Ashin Wang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://www.ashin.wang/page/7/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Ashin Wang's Blog</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?1d0c251d59c914b8a773d2fd3302cc56";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Ashin Wang's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

      
    </div>
  </div>

</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.ashin.wang/hexo-github-coding-gitee/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://tva1.sinaimg.cn/large/006y8mN6ly1g74lvmm1zhj3074074q4r.jpg">
      <meta itemprop="name" content="Ashin Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ashin Wang's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/hexo-github-coding-gitee/" class="post-title-link" itemprop="url">Hexo同时部署在GitHub、Coding、Gitee</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-15 22:53:12" itemprop="dateCreated datePublished" datetime="2019-09-15T22:53:12+08:00">2019-09-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Blog/" itemprop="url" rel="index"><span itemprop="name">Blog</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>将Hexo同时部署在GitHub Pages、Coding Pages、Gitee Pages 上。</p>
<p>我太闲了:)</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/hexo-github-coding-gitee/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.ashin.wang/hexo-simplevaline/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://tva1.sinaimg.cn/large/006y8mN6ly1g74lvmm1zhj3074074q4r.jpg">
      <meta itemprop="name" content="Ashin Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ashin Wang's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/hexo-simplevaline/" class="post-title-link" itemprop="url">Hexo评论框架Valine简化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-12 17:37:36" itemprop="dateCreated datePublished" datetime="2019-09-12T17:37:36+08:00">2019-09-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Blog/" itemprop="url" rel="index"><span itemprop="name">Blog</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本站点评论框架采用 Valine，非常喜欢它来搭配 Hexo。</p>
<p>Valine的优点：</p>
<ul>
<li>不需要注册，支持匿名评论</li>
<li>基于 LeanCloud，无广告</li>
<li>支持邮件提醒</li>
<li>多个部署，调用同一个 LeanCloud</li>
</ul>
<p>针对 Valine，冒昧再次进行了简化，使其看起来更加简洁。<br><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gbf0edy5igj31a00jgwfi.jpg"></p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/hexo-simplevaline/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.ashin.wang/hexo-accelerate/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://tva1.sinaimg.cn/large/006y8mN6ly1g74lvmm1zhj3074074q4r.jpg">
      <meta itemprop="name" content="Ashin Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ashin Wang's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/hexo-accelerate/" class="post-title-link" itemprop="url">Hexo优化加速</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-07 09:27:19" itemprop="dateCreated datePublished" datetime="2019-09-07T09:27:19+08:00">2019-09-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Blog/" itemprop="url" rel="index"><span itemprop="name">Blog</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>把Hexo托管在GH Pages上，每次full load速度都非常的慢。于是，我deploy到Coding Pages进行对比测试，发现Coding的服务器也全部在境外，速度不如GH且不稳定。</p>
<p>在网上疯狂搜索有关于Hexo加速教程，经过几番折腾，总结几点实用的。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/hexo-accelerate/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.ashin.wang/windows-skill/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://tva1.sinaimg.cn/large/006y8mN6ly1g74lvmm1zhj3074074q4r.jpg">
      <meta itemprop="name" content="Ashin Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ashin Wang's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/windows-skill/" class="post-title-link" itemprop="url">Windows使用技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-29 21:42:17" itemprop="dateCreated datePublished" datetime="2019-06-29T21:42:17+08:00">2019-06-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Windows/" itemprop="url" rel="index"><span itemprop="name">Windows</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Windows 平台下的一些快捷方式，和一些实用工具。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/windows-skill/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.ashin.wang/macos-skill/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://tva1.sinaimg.cn/large/006y8mN6ly1g74lvmm1zhj3074074q4r.jpg">
      <meta itemprop="name" content="Ashin Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ashin Wang's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/macos-skill/" class="post-title-link" itemprop="url">macOS使用技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-05-31 15:08:38" itemprop="dateCreated datePublished" datetime="2019-05-31T15:08:38+08:00">2019-05-31</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/macOS/" itemprop="url" rel="index"><span itemprop="name">macOS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>记录一些 Mac 的快捷方式，以及好用的软件。</p>
<p>不得不说，在MacBook上，使用触控板和快捷方式，有时候比起鼠标还要方便舒适。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/macos-skill/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.ashin.wang/hexo-build/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://tva1.sinaimg.cn/large/006y8mN6ly1g74lvmm1zhj3074074q4r.jpg">
      <meta itemprop="name" content="Ashin Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ashin Wang's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/hexo-build/" class="post-title-link" itemprop="url">Hexo框架搭建+GitHub托管笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-05-24 08:51:54" itemprop="dateCreated datePublished" datetime="2019-05-24T08:51:54+08:00">2019-05-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Blog/" itemprop="url" rel="index"><span itemprop="name">Blog</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>WordPress已闲置一年了，也不想再去维护。最近开始折腾起Hexo框架，发现它不仅符合我的需求（轻量、易用），而且还非常的成熟。托管在GitHub Pages，希望能长久坚持下去。</p>
<p>本次基于macOS，Windows平台的搭建的步骤相同。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/hexo-build/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.ashin.wang/leetcode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://tva1.sinaimg.cn/large/006y8mN6ly1g74lvmm1zhj3074074q4r.jpg">
      <meta itemprop="name" content="Ashin Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ashin Wang's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/leetcode/" class="post-title-link" itemprop="url">leetcode</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：1978-01-01 00:00:00" itemprop="dateCreated datePublished" datetime="1978-01-01T00:00:00+08:00">1978-01-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">leetcode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li>刷题目录 ❤️：<a target="_blank" rel="noopener" href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/Leetcode%20%E9%A2%98%E8%A7%A3/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E7%9B%AE%E5%BD%95.html">CYC2018  Leetcode 题解</a></li>
<li>刷题模板：<a target="_blank" rel="noopener" href="https://ojeveryday.github.io/AlgoWiki/#/?id=algowiki">AlgoWiki</a></li>
<li>刷题套路：<a target="_blank" rel="noopener" href="https://labuladong.gitbook.io/algo/">📖labuladong 的算法小抄</a></li>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/">代码随想录</a></li>
</ul>
<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><ul>
<li>总结<ul>
<li>一个数组的 head end，两个数组指针</li>
<li>方向和边界</li>
<li>大小比较</li>
</ul>
</li>
</ul>
<h2 id="167-两数之和-II-输入有序数组"><a href="#167-两数之和-II-输入有序数组" class="headerlink" title="167. 两数之和 II - 输入有序数组"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/">167. 两数之和 II - 输入有序数组</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, numbers: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[int]:</span>																		left, right = <span class="number">0</span>, <span class="built_in">len</span>(numbers) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="keyword">if</span> numbers[left] + numbers[right] == target:</span><br><span class="line">                <span class="keyword">return</span> [left+<span class="number">1</span>, right+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">elif</span> numbers[left] + numbers[right] &gt; target:</span><br><span class="line">                right = right - <span class="number">1</span> <span class="comment"># 右指针左移</span></span><br><span class="line">            <span class="keyword">elif</span> numbers[left] + numbers[right] &lt; target:</span><br><span class="line">                left = left + <span class="number">1</span>   <span class="comment"># 左指针右移</span></span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gtv9zq4485j60rm0a8t8x02.jpg"></p>
<h2 id="633-平方数之和"><a href="#633-平方数之和" class="headerlink" title="633. 平方数之和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sum-of-square-numbers/">633. 平方数之和</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">judgeSquareSum</span>(<span class="params">self, c: <span class="built_in">int</span></span>) -&gt; bool:</span></span><br><span class="line">        </span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">int</span>(c**<span class="number">0.5</span>) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right):</span><br><span class="line">            <span class="keyword">if</span> left**<span class="number">2</span> + right**<span class="number">2</span> == c:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> left**<span class="number">2</span> + right**<span class="number">2</span> &gt; c:</span><br><span class="line">                right = right - <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> left**<span class="number">2</span> + right**<span class="number">2</span> &lt; c:</span><br><span class="line">                left = left + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>其他解法：</p>
<ul>
<li>费马平方和定理，检查所有模4余3的因子的个数是否为偶数个即可</li>
</ul>
<h2 id="345-反转字符串中的元音字母"><a href="#345-反转字符串中的元音字母" class="headerlink" title="345. 反转字符串中的元音字母"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string/">345. 反转字符串中的元音字母</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseVowels</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line"></span><br><span class="line">        vowels = <span class="string">&#x27;aeiouAEIOU&#x27;</span></span><br><span class="line">        s = <span class="built_in">list</span>(s)</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="keyword">if</span> s[left] <span class="keyword">in</span> vowels:</span><br><span class="line">                <span class="keyword">while</span> s[right] <span class="keyword">not</span> <span class="keyword">in</span> vowels:</span><br><span class="line">                    right = right - <span class="number">1</span></span><br><span class="line">                s[left], s[right] = s[right], s[left]</span><br><span class="line">                left = left + <span class="number">1</span></span><br><span class="line">                right = right - <span class="number">1</span> </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = left + <span class="number">1</span></span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(s) <span class="comment"># join jion</span></span><br></pre></td></tr></table></figure>



<h2 id="680-验证回文字符串-Ⅱ"><a href="#680-验证回文字符串-Ⅱ" class="headerlink" title="680. 验证回文字符串 Ⅱ"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-palindrome-ii/">680. 验证回文字符串 Ⅱ</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validPalindrome</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment">#lambda [arg1 [,arg2,.....argn]]:expression, x[start:end:span] 当 span&lt;0 时，列表翻转</span></span><br><span class="line">        isPalindrome = <span class="keyword">lambda</span> x : x == x[::-<span class="number">1</span>] <span class="comment"># isPalindrome 返回值就是 bool</span></span><br><span class="line"></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            <span class="keyword">if</span> s[left] == s[right]:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> isPalindrome(s[left + <span class="number">1</span> : right + <span class="number">1</span>]) <span class="keyword">or</span> isPalindrome(s[left: right])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> <span class="comment"># True</span></span><br></pre></td></tr></table></figure>



<h2 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88. 合并两个有序数组"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-sorted-array/">88. 合并两个有序数组</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self, nums1: List[<span class="built_in">int</span>], m: <span class="built_in">int</span>, nums2: List[<span class="built_in">int</span>], n: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">sorted</span> = []</span><br><span class="line">        p1, p2 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> p1 &lt; m <span class="keyword">or</span> p2 &lt; n:</span><br><span class="line">            <span class="keyword">if</span> p1 == m:</span><br><span class="line">                <span class="built_in">sorted</span>.append(nums2[p2])</span><br><span class="line">                p2 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> p2 == n:</span><br><span class="line">                <span class="built_in">sorted</span>.append(nums1[p1])</span><br><span class="line">                p1 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums1[p1] &lt; nums2[p2]:</span><br><span class="line">                <span class="built_in">sorted</span>.append(nums1[p1])</span><br><span class="line">                p1 = p1 + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">sorted</span>.append(nums2[p2])</span><br><span class="line">                p2 = p2 + <span class="number">1</span>     </span><br><span class="line">        nums1[:] = <span class="built_in">sorted</span></span><br></pre></td></tr></table></figure>



<h2 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-cycle/">141. 环形链表</a></h2><ul>
<li>使用双指针，一个指针每次移动一个节点，一个指针每次移动两个节点，如果存在环，那么这两个指针一定会相遇。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span>(<span class="params">self, head: ListNode</span>) -&gt; bool:</span></span><br><span class="line">        p1 = p2 = head</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> p2 <span class="keyword">and</span> p2.<span class="built_in">next</span>: <span class="comment"># 防止head为空和出现空指针的next的情况</span></span><br><span class="line">            p1 = p1.<span class="built_in">next</span></span><br><span class="line">            p2 = p2.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> p1 <span class="keyword">is</span> p2:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>



<h2 id="524-通过删除字母匹配到字典里最长单词"><a href="#524-通过删除字母匹配到字典里最长单词" class="headerlink" title="524. 通过删除字母匹配到字典里最长单词"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/">524. 通过删除字母匹配到字典里最长单词</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLongestWord</span>(<span class="params">self, s: <span class="built_in">str</span>, dictionary: List[<span class="built_in">str</span>]</span>) -&gt; str:</span></span><br><span class="line">        d = dictionary</span><br><span class="line">        <span class="comment"># - 用好python内置函数sort()、find(),比双指针效率更高</span></span><br><span class="line">        <span class="comment"># 可以用元组表示多关键字排序，第一关键字是长度降序，第二关键字是字符串本身字典序</span></span><br><span class="line">        d.sort(key = <span class="keyword">lambda</span> x: [-<span class="built_in">len</span>(x), x])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> d:</span><br><span class="line">            p1 = <span class="number">0</span></span><br><span class="line">            p2 = <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> p1 &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> p2 &lt; <span class="built_in">len</span>(word):</span><br><span class="line">                <span class="keyword">if</span> s[p1] == word[p2]:</span><br><span class="line">                    p1 += <span class="number">1</span></span><br><span class="line">                    p2 += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    p1 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(word) == p2:</span><br><span class="line">                <span class="keyword">return</span> word</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>



<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215. 数组中的第K个最大元素"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">return</span> nums[-k]</span><br></pre></td></tr></table></figure>



<h2 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347. 前 K 个高频元素"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counterclass Solution:    <span class="function"><span class="keyword">def</span> <span class="title">topKFrequent</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; List[int]:</span>        <span class="keyword">return</span> [i[<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> Counter(nums).most_common(k)]</span><br></pre></td></tr></table></figure>



<h2 id="451-根据字符出现频率排序"><a href="#451-根据字符出现频率排序" class="headerlink" title="451. 根据字符出现频率排序"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sort-characters-by-frequency/">451. 根据字符出现频率排序</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counterclass Solution:    <span class="function"><span class="keyword">def</span> <span class="title">frequencySort</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; str:</span>        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(i * j <span class="keyword">for</span> i,j <span class="keyword">in</span> Counter(s).most_common())</span><br></pre></td></tr></table></figure>



<h2 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="75. 颜色分类"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sort-colors/">75. 颜色分类</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">sortColors</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; <span class="keyword">None</span>:</span>        <span class="string">&#x27;&#x27;&#x27;三色旗问题，最初可将其看为四类：red，white，blue和unclassified           |——0——|--1---|--unclassified--|--2---|                 |      |                |                red   white             blue           当white与blue未重合时：               如果nums[w]为0，则交换放到red区间，red和white都加1。               如果nums[w]为1，则white指针加1。               如果nums[w]为2，则交换放到 blue 区间，blue减1。        &#x27;&#x27;&#x27;</span>        r, w, b = <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span>                <span class="keyword">while</span> w &lt;= b:            <span class="keyword">if</span> nums[w] == <span class="number">0</span>:                nums[w], nums[r] = nums[r], nums[w]                r += <span class="number">1</span>                w += <span class="number">1</span>            <span class="keyword">elif</span> nums[w] == <span class="number">1</span>:                w += <span class="number">1</span>            <span class="keyword">else</span>:                nums[w], nums[b] = nums[b], nums[w]                b -= <span class="number">1</span></span><br></pre></td></tr></table></figure>



<h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><p>保证每次操作都是局部最优的，并且最后得到的结果是全局最优的。</p>
<h2 id="455-分发饼干"><a href="#455-分发饼干" class="headerlink" title="455. 分发饼干"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/assign-cookies/">455. 分发饼干</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">findContentChildren</span>(<span class="params">self, g: List[<span class="built_in">int</span>], s: List[<span class="built_in">int</span>]</span>) -&gt; int:</span>        g.sort() <span class="comment"># 胃口值        s.sort() # 饼干尺寸        idx = len(s) - 1 # 饼干 Index                res = 0  # result                # 也就是用局部的最优（当前孩子获得大于等于其胃口的饼干中大小最小的饼干），来达到全局最优（满意度最高）        for i in range(len(g) - 1, -1, -1): # n, n-1, n-2, ... 3, 2, 1, 0 遍历胃口值，小 -&gt; 大 排序。             if idx &gt;= 0 and s[idx] &gt;= g[i]:                res += 1                idx -= 1        return res</span></span><br></pre></td></tr></table></figure>



<h2 id="435-无重叠区间"><a href="#435-无重叠区间" class="headerlink" title="435. 无重叠区间"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/non-overlapping-intervals/">435. 无重叠区间</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">eraseOverlapIntervals</span>(<span class="params">self, intervals: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span>        <span class="comment"># []        if not intervals:            return 0        # 右边界排序        intervals.sort(key = lambda x: x[1])				        res = 0        right = intervals[0][1]				# 第二个区间开始        for i in range(1, len(intervals)):            if intervals[i][0] &lt; right:                res += 1            else:                right = intervals[i][1]        return res</span></span><br></pre></td></tr></table></figure>





<h2 id="452-用最少数量的箭引爆气球"><a href="#452-用最少数量的箭引爆气球" class="headerlink" title="452. 用最少数量的箭引爆气球"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/">452. 用最少数量的箭引爆气球</a></h2><ul>
<li>重叠区间求解</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">findMinArrowShots</span>(<span class="params">self, points: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span>        <span class="keyword">if</span> <span class="keyword">not</span> points:            <span class="keyword">return</span> <span class="number">0</span>        points.sort(key = <span class="keyword">lambda</span> x: x[<span class="number">1</span>])        res = <span class="built_in">len</span>(points)        right = points[<span class="number">0</span>][<span class="number">1</span>]        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(points)):            <span class="keyword">if</span> points[i][<span class="number">0</span>] &lt;= right:                res -= <span class="number">1</span>            <span class="keyword">else</span>:                right = points[i][<span class="number">1</span>]        <span class="keyword">return</span> res </span><br></pre></td></tr></table></figure>



<h2 id="406-根据身高重建队列"><a href="#406-根据身高重建队列" class="headerlink" title="406. 根据身高重建队列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/">406. 根据身高重建队列</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">reconstructQueue</span>(<span class="params">self, people: List[List[<span class="built_in">int</span>]]</span>) -&gt; List[List[int]]:</span>        people.sort(key=<span class="keyword">lambda</span> x: (x[<span class="number">0</span>], -x[<span class="number">1</span>]), reverse=<span class="literal">True</span>)        res = []        <span class="keyword">for</span> i <span class="keyword">in</span> people:            res.insert(i[<span class="number">1</span>], i) <span class="comment"># insert(index, obj)        return res</span></span><br></pre></td></tr></table></figure>



<h2 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[<span class="built_in">int</span>]</span>) -&gt; int:</span>        <span class="comment"># 未获取合适结果默认返回0        ret = 0        start = 0                for i in range(1, len(prices)):            # 当最小价格小于start指针切换至当前            if prices[i] - prices[start] &lt; 0:                start = i            # 每次比较最优抛售价格            ret = max(prices[i] - prices[start], ret)        return ret</span></span><br></pre></td></tr></table></figure>



<h2 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122. 买卖股票的最佳时机 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[<span class="built_in">int</span>]</span>) -&gt; int:</span>        ret = <span class="number">0</span>        strat = <span class="number">0</span>        profits = []        <span class="keyword">for</span> p <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(prices)):            profits.append(prices[p]-prices[p-<span class="number">1</span>])        <span class="keyword">for</span> p <span class="keyword">in</span> profits:            <span class="keyword">if</span> p &gt;= <span class="number">0</span>:                ret = ret + p        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>



<h2 id="605-种花问题"><a href="#605-种花问题" class="headerlink" title="605. 种花问题"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/can-place-flowers/">605. 种花问题</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">canPlaceFlowers</span>(<span class="params">self, flowerbed: List[<span class="built_in">int</span>], n: <span class="built_in">int</span></span>) -&gt; bool:</span>      	<span class="comment"># 添加哨兵        flower = [0] + flowerbed + [0]        for f in range(1, len(flower)-1):            # 跳过三个相邻的花盆中已种花            if flower[f-1] == 1: continue            if flower[f] == 1: continue            if flower[f+1] == 1: continue                        flower[f] = 1            n = n - 1        if n &lt;= 0:            return True        else:            return False</span></span><br></pre></td></tr></table></figure>



<h2 id="392-判断子序列"><a href="#392-判断子序列" class="headerlink" title="392. 判断子序列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/is-subsequence/">392. 判断子序列</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">isSubsequence</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; bool:</span>        t = <span class="built_in">iter</span>(t)        <span class="keyword">return</span> <span class="built_in">all</span>(i <span class="keyword">in</span> t <span class="keyword">for</span> i <span class="keyword">in</span> s) </span><br></pre></td></tr></table></figure>



<h2 id="665-非递减数列"><a href="#665-非递减数列" class="headerlink" title="665. 非递减数列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/non-decreasing-array/">665. 非递减数列</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">checkPossibility</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; bool:</span>        cnt = <span class="number">0</span>                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span>):            <span class="keyword">if</span> nums[i] &gt; nums[i+<span class="number">1</span>]:                cnt += <span class="number">1</span>                <span class="keyword">if</span> cnt &gt; <span class="number">1</span>:                    <span class="keyword">return</span> <span class="literal">False</span>                            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i+<span class="number">1</span>] &lt; nums[i-<span class="number">1</span>]:                    nums[i+<span class="number">1</span>] = nums[i]        <span class="keyword">return</span> <span class="literal">True</span> </span><br></pre></td></tr></table></figure>



<h2 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53. 最大子序和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-subarray/">53. 最大子序和</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span>        max_value = nums[<span class="number">0</span>]        pre = <span class="number">0</span>        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):            pre = <span class="built_in">max</span>(pre + nums[i], nums[i])            max_value = <span class="built_in">max</span>(pre, max_value)        <span class="keyword">return</span> max_value</span><br></pre></td></tr></table></figure>



<h2 id="763-划分字母区间"><a href="#763-划分字母区间" class="headerlink" title="763. 划分字母区间"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/partition-labels/">763. 划分字母区间</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partitionLabels</span>(<span class="params">self, S: <span class="string">&quot;str&quot;</span></span>) -&gt; &quot;list[int]&quot;:</span></span><br><span class="line">        maxIndex = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="comment"># 记录每个字符最后的位置</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(S)):</span><br><span class="line">            maxIndex[S[i]] = i <span class="comment"># 通过更新字典</span></span><br><span class="line"></span><br><span class="line">        ans = <span class="built_in">list</span>()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 当前片段开始位置和结束位置</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        end = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历整个字符串S，寻找所有合适的解</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(S)):</span><br><span class="line">            end = <span class="built_in">max</span>(maxIndex[S[i]], end)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> i == end:</span><br><span class="line">                ans.append(end - start + <span class="number">1</span>)</span><br><span class="line">                start = end + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>



<h1 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h1><p>二分查找也称为折半查找，每次都能将查找区间减半，这种折半特性的算法时间复杂度为 O(logN)。</p>
<p><strong>m 计算</strong></p>
<p>有两种计算中值 m 的方式：</p>
<ul>
<li>m = (l + h) / 2</li>
<li>m = l + (h - l) / 2</li>
</ul>
<p>l + h 可能出现加法溢出，也就是说加法的结果大于整型能够表示的范围。但是 l 和 h 都为正数，因此 h - l 不会出现加法溢出问题。所以，最好使用第二种计算法方法。</p>
<h2 id="解题模版"><a href="#解题模版" class="headerlink" title="解题模版"></a>解题模版</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 模版一def search(nums: List[int], left: int, right: int, target: int) -&gt; int:    while left &lt; right:        # 选择中位数时下取整，防止加法溢出        mid = left + (right - left) // 2        if check(mid):            # 下一轮搜索区间是 [mid + 1, right]            left = mid + 1        else:            # 下一轮搜索区间是 [left, mid]            right = mid    # 退出循环的时候，程序只剩下一个元素没有看到。    # 视情况，是否需要单独判断 left（或者 right）这个下标的元素是否符合题意    # 模版二    def search(nums: List[int], left: int, right: int, target: int) -&gt; int:    while left + 1 &lt; right:        # 选择中位数时下取整        mid = left + (right - left) // 2        if nums[mid] == target:            return mid        elif nums[mid] &lt; target:            left = mid        else:            right = mid    if nums[left] == target:        return left    if nums[right] == target:        return right    return -1</span></span><br></pre></td></tr></table></figure>



<h2 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35. 搜索插入位置"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/search-insert-position/">35. 搜索插入位置</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; int:</span>        n = <span class="built_in">len</span>(nums)        <span class="keyword">if</span> n == <span class="number">0</span>:            <span class="keyword">return</span> <span class="number">0</span>        left = <span class="number">0</span>        right = n        <span class="keyword">while</span> left &lt; right:            mid = left + (right - left) // <span class="number">2</span>            <span class="keyword">if</span> nums[mid] &lt; target:                left = mid + <span class="number">1</span>  <span class="comment"># [mid + 1, right]            else:                right = mid     # [left, mid]            return left </span></span><br></pre></td></tr></table></figure>



<h2 id="69-x-的平方根"><a href="#69-x-的平方根" class="headerlink" title="69. x 的平方根"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sqrtx/">69. x 的平方根</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; int:</span>        <span class="keyword">if</span> x == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span>        <span class="keyword">if</span> x == <span class="number">1</span>: <span class="keyword">return</span> <span class="number">1</span>        left = <span class="number">1</span>        right = x        <span class="keyword">while</span> left &lt;= right:            mid = left + (right - left)//<span class="number">2</span> <span class="comment"># mid            if mid * mid == x:              return mid            elif mid * mid &gt; x:                right = mid - 1            else:                left = mid + 1        return right # 解法二class Solution(object):    def mySqrt(self, x: int) -&gt; int:        if x == 0:            return 0        if x == 1:            return 1        left, right = 1, x // 2        while left &lt; right:            mid = left + (right - left + 1) // 2            # 不使用 mid * mid &gt; x，防止 overflow            # Python 使用 BigInteger，所以不用担心溢出，但还是推荐使用如下形式            if mid &gt; x // mid:                # 下一轮搜索的区间是 [left, mid - 1]                right = mid - 1            else:                # 下一轮搜索的区间是 [mid, right]                left = mid        return left</span></span><br></pre></td></tr></table></figure>



<h2 id="875-爱吃香蕉的珂珂"><a href="#875-爱吃香蕉的珂珂" class="headerlink" title="875. 爱吃香蕉的珂珂"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/koko-eating-bananas/">875. 爱吃香蕉的珂珂</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">minEatingSpeed</span>(<span class="params">self, piles: List[<span class="built_in">int</span>], H: <span class="built_in">int</span></span>) -&gt; int:</span>        maxVal = <span class="number">1</span>        <span class="keyword">for</span> pile <span class="keyword">in</span> piles:            maxVal = <span class="built_in">max</span>(maxVal, pile)        <span class="comment"># 速度最小的时候，耗时最长        left = 1        # 速度最大的时候，耗时最短        right = maxVal        while left &lt; right:            mid = left + (right - left) // 2            if self.calculateSum(piles, mid) &gt; H:                # 耗时太多，说明速度太慢了，下一轮搜索区间在                # [mid + 1, right]                left = mid + 1            else:                right = mid        return left    def calculateSum(self, piles: List[int], speed: int) -&gt; int:        &quot;&quot;&quot;如果返回的小时数严格大于 H，就不符合题意        Args:            piles:            speed:        Returns:            需要的小时数        &quot;&quot;&quot;        sum = 0        for pile in piles:            # 上取整可以这样写            sum += (pile + speed - 1) // speed        return sum</span></span><br></pre></td></tr></table></figure>





<h2 id="744-寻找比目标字母大的最小字母"><a href="#744-寻找比目标字母大的最小字母" class="headerlink" title="744. 寻找比目标字母大的最小字母"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/">744. 寻找比目标字母大的最小字母</a></h2><ul>
<li>若target大于letters里面的所有元素，那么退出循环时候left就会指向索引为len(letters)的位置，所以我们通过取余操作达到循环的效果。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">nextGreatestLetter</span>(<span class="params">self, letters: List[<span class="built_in">str</span>], target: <span class="built_in">str</span></span>) -&gt; str:</span>        left = <span class="number">0</span>        right = <span class="built_in">len</span>(letters) - <span class="number">1</span>        <span class="keyword">while</span> left &lt;= right:            mid = left + (right - left) // <span class="number">2</span>            <span class="keyword">if</span> letters[mid] &lt;= target:                left = mid + <span class="number">1</span>            <span class="keyword">elif</span> letters[mid] &gt; target:                right = mid - <span class="number">1</span>        <span class="keyword">return</span> letters[left % <span class="built_in">len</span>(letters)]</span><br></pre></td></tr></table></figure>



<h2 id="540-有序数组中的单一元素"><a href="#540-有序数组中的单一元素" class="headerlink" title="540. 有序数组中的单一元素"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/single-element-in-a-sorted-array/">540. 有序数组中的单一元素</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">singleNonDuplicate</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span>                left = <span class="number">0</span>        right = <span class="built_in">len</span>(nums) - <span class="number">1</span>        <span class="keyword">while</span> left &lt; right:            mid = left + (right - left )//<span class="number">2</span>            <span class="keyword">if</span> mid % <span class="number">2</span> == <span class="number">1</span>: <span class="comment"># mid 奇数，左移一位                mid -= 1            if nums[mid] == nums[mid+1]:                left = mid + 2            else:                right = mid        return nums[left]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>异或</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">singleNonDuplicate</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span>        res = <span class="number">0</span>        <span class="keyword">for</span> x <span class="keyword">in</span> nums:            res ^= x        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>



<h2 id="278-第一个错误的版本"><a href="#278-第一个错误的版本" class="headerlink" title="278. 第一个错误的版本"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/first-bad-version/">278. 第一个错误的版本</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The isBadVersion API is already defined for you.# @param version, an integer# @return an integer# def isBadVersion(version):class Solution:    def firstBadVersion(self, n):        &quot;&quot;&quot;        :type n: int        :rtype: int        &quot;&quot;&quot;        left = 1        right = n        if n ==1:            return 1        while left &lt; right:            mid =left + (right - left)//2            if isBadVersion(mid):                right = mid             else:                left = mid + 1        return left</span></span><br></pre></td></tr></table></figure>



<h2 id="153-寻找旋转排序数组中的最小值"><a href="#153-寻找旋转排序数组中的最小值" class="headerlink" title="153. 寻找旋转排序数组中的最小值"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">153. 寻找旋转排序数组中的最小值</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># [3,4,5,1,2]# 1class Solution:    def findMin(self, nums: List[int]) -&gt; int:        left = 0        right = len(nums) - 1           while left &lt; right:            mid = left + (right - left) // 2                        if nums[mid] &lt; nums[right]:                right = mid            else:                left = mid + 1        return nums[left]</span></span><br></pre></td></tr></table></figure>



<h2 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">searchRange</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[int]:</span>              <span class="function"><span class="keyword">def</span> <span class="title">binarysearchleft</span>(<span class="params">nums, target</span>):</span>            left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span>            <span class="keyword">while</span> left &lt;= right:                mid = left + (right - left) // <span class="number">2</span>                <span class="keyword">if</span> nums[mid] &gt;= target:                    right = mid -<span class="number">1</span>                <span class="keyword">else</span>:                    left = mid + <span class="number">1</span>            <span class="keyword">return</span> left                  start = binarysearchleft(nums, target)        end = binarysearchleft(nums, target + <span class="number">1</span>) - <span class="number">1</span>                <span class="keyword">if</span> start == <span class="built_in">len</span>(nums) <span class="keyword">or</span> nums[start] != target:            <span class="keyword">return</span> [-<span class="number">1</span>, -<span class="number">1</span>]        <span class="keyword">else</span>:            <span class="keyword">return</span> [start, end]</span><br></pre></td></tr></table></figure>



<h2 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, nums, target</span>):</span>        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span>        <span class="keyword">while</span> left &lt;= right:            mid = (left + right) // <span class="number">2</span>            <span class="keyword">if</span> nums[mid] == target:                <span class="keyword">return</span> mid            <span class="keyword">elif</span> nums[left] &lt;= nums[mid]:                <span class="keyword">if</span> nums[left] &lt;= target &lt; nums[mid]:                    right = mid - <span class="number">1</span>                <span class="keyword">else</span>:                    left = mid + <span class="number">1</span>            <span class="keyword">else</span>:                <span class="keyword">if</span> nums[mid] &lt; target &lt;= nums[right]:                    left = mid + <span class="number">1</span>                <span class="keyword">else</span>:                    right = mid - <span class="number">1</span>        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>



<h2 id="287-寻找重复数"><a href="#287-寻找重复数" class="headerlink" title="287. 寻找重复数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-the-duplicate-number/">287. 寻找重复数</a></h2><ul>
<li><strong>抽屉原理</strong>：“如果每个<strong>抽屉</strong>代表一个集合，每一个苹果就可以代表一个元素，假如有n+1个元素放到n个集合中去，其中必定有一个集合里至少有两个元素。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">findDuplicate</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span>        <span class="comment">#二分法        left = 1        right = len(nums)-1        while left &lt; right:            mid = left + (right - left) // 2            count = 0            for num in nums:                if num &lt;= mid:                    count += 1            if count &gt; mid:                right = mid            else:                left = mid + 1        return left</span></span><br></pre></td></tr></table></figure>



<h2 id="410-分割数组的最大值"><a href="#410-分割数组的最大值" class="headerlink" title="410. 分割数组的最大值"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/split-array-largest-sum/">410. 分割数组的最大值</a></h2><ul>
<li>查找范围：二分查找的范围是<code>[max(数组), sum(数组)]</code></li>
<li>查找思路：<ul>
<li>假设这个中点 mid 就是 “每一个数组和中的最大值” 的最小值<br>  那么每一个数组和必定 &lt;=mid，你用这个值来对数组进行从头分割，一旦当前数组和&gt;mid,就结束该数组，开启一个新数组<br>  如果你用这个mid创建的数组数量，比m还多，说明你这个值定小了，所以二分查找取哪一半？右半！<br>  如果你用这个mid创建的数组数量，比m少了，说明你这个值定大了，所以二分查找取哪一半？左半！</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">splitArray</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], m: <span class="built_in">int</span></span>) -&gt; int:</span>        <span class="comment">#二分查找        #指定二分查找范围        left, right = max(nums), sum(nums)        #定义 测试中点是大还是小的 测试函数        def test_mid(mid):            #初始化            num = 1 #num表示使用该mid我们会得到几个数组            s = 0 #s表示当前数组的和            for i in nums:                if s+i &gt; mid: #如果当前数组已经超过mid，要停止这个数组                    s = i #这个数变为下一个数组的开头                    num += 1 #会得到的数组数量+1                else:                    s += i            return num &gt; m #数组总数是否&gt;m, 大于的话说明mid太小，二分查找取右边            #这里有一个注意点，如果num已经等于m了, 但此时如果left不等于right，范围还是会继续收敛的，            #且取的是左半边，目的是让我们能最终找到一个确切的值，这个值恰好就是取得了最大值的那个数组的和            #(因为小于这个和的话，就不能通过num=m的测试；而大于这个m的话，即使通过了num=m的测试，            #范围也会继续向左边收敛，直到我们找到的就是这个和)。                #进行二分查找        while left &lt; right: #当left == right的时候就终止查找，返回任意一个            mid = (left + right) // 2            if_right = test_mid(mid)            if if_right:                left = mid+1            else:                right = mid #num &lt;= m的情况        return left</span></span><br></pre></td></tr></table></figure>





<h1 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h1><h2 id="241-为运算表达式设计优先级"><a href="#241-为运算表达式设计优先级" class="headerlink" title="241. 为运算表达式设计优先级"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/different-ways-to-add-parentheses/">241. 为运算表达式设计优先级</a></h2><p><strong>分治算法三步走</strong>：</p>
<ol>
<li>分解：按运算符分成左右两部分，分别求解</li>
<li>解决：实现一个递归函数，输入算式，返回算式解</li>
<li>合并：根据运算符合并左右两部分的解，得出最终解</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">diffWaysToCompute</span>(<span class="params">self, <span class="built_in">input</span>: <span class="built_in">str</span></span>) -&gt; List[int]:</span>        <span class="comment"># 如果只有数字，直接返回        if input.isdigit():            return [int(input)]        res = []        for i, char in enumerate(input):            if char in [&#x27;+&#x27;, &#x27;-&#x27;, &#x27;*&#x27;]:                # 1.分解：遇到运算符，计算左右两侧的结果集                # 2.解决：diffWaysToCompute 递归函数求出子问题的解                left = self.diffWaysToCompute(input[:i])                right = self.diffWaysToCompute(input[i+1:])                # 3.合并：根据运算符合并子问题的解                for l in left:                    for r in right:                        if char == &#x27;+&#x27;:                            res.append(l + r)                        elif char == &#x27;-&#x27;:                            res.append(l - r)                        else:                            res.append(l * r)        return res </span></span><br></pre></td></tr></table></figure>

<h2 id="95-不同的二叉搜索树-II"><a href="#95-不同的二叉搜索树-II" class="headerlink" title="95. 不同的二叉搜索树 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/">95. 不同的二叉搜索树 II</a></h2><ul>
<li>二叉搜索树（BST）又称<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/7077965">二叉查找树</a>或<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/10905079">二叉排序树</a>。其特点如下：设x为二叉查找树中的一个结点，x节点包含关键字key，一句话就是左孩子比父节点小，右孩子比父节点大，还有一个特性就是”中序遍历“可以让结点有序。</li>
<li></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = right&#x27;&#x27;&#x27;思路：分治以整数区间a..b中每一个元组作为子树的根节点，另外的元素作为左右子树，递归生成左右子树的后，根节点与左右子树进行组合时间复杂度：x， O(2^n)&lt; x &lt;O(n!)空间复杂度：O(n)，最大递归深度n&#x27;&#x27;&#x27;class Solution:    def generateTrees(self, n: int) -&gt; List[TreeNode]:        def makeTree(start, end):            ans = []            for i in range(start, end):                leftTrees, rightTrees = [None], [None]                if i &gt; start:                    leftTrees = makeTree(start, i)                if i &lt; end - 1:                    rightTrees = makeTree(i + 1, end)                for leftTree in leftTrees:                    for rightTree in rightTrees:                        node = TreeNode(i, leftTree, rightTree)                        ans.append(node)            return ans        return makeTree(1, n + 1)</span></span><br></pre></td></tr></table></figure>

<h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h1><p>深度优先搜索和广度优先搜索广泛运用于树和图中</p>
<h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><ul>
<li> BFS：广度优先 (Breadth first search, BFS)</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gu01l8sllfj606m076t8p02.jpg"></p>
<p>广度优先搜索一层一层地进行遍历，每层遍历都是以上一层遍历的结果作为起点，遍历一个距离能访问到的所有节点。需要注意的是，遍历过的节点不能再次被遍历。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gu0e7vr8qaj60ej0603yj02.jpg"></p>
<p>第一层：</p>
<ul>
<li>0 -&gt; {6,2,1,5}</li>
</ul>
<p>第二层：</p>
<ul>
<li>6 -&gt; {4}</li>
<li>2 -&gt; {}</li>
<li>1 -&gt; {}</li>
<li>5 -&gt; {3}</li>
</ul>
<p>第三层：</p>
<ul>
<li>4 -&gt; {}</li>
<li>3 -&gt; {}</li>
</ul>
<h3 id="Baseline"><a href="#Baseline" class="headerlink" title="Baseline"></a>Baseline</h3><p><strong>BFS 算法组成的 3 元素：</strong>队列，入队出队的节点，已访问的集合。</p>
<ul>
<li><p>队列：先入先出的容器；</p>
</li>
<li><p>节点：最好写成单独的类，比如本例写成 <code>(value, step)</code> 元组。也可写成<code> (value, visited)</code>，看自己喜好和题目；</p>
</li>
<li><p>已访问集合：为了避免队列中插入重复的值</p>
</li>
</ul>
<p><strong>BFS算法组成的套路：</strong></p>
<ol>
<li><p>初始化三元素：</p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">队列      Node = node(n) 节点      queue = [Node] 已访问集合 visited = <span class="built_in">set</span>([Node.value])</span><br></pre></td></tr></table></figure></li>
<li><p>操作队列 — 弹出队首节点：<br> <code>vertex = queue.pop(0)</code></p>
</li>
<li><p>操作弹出的节点 — 根据业务生成子节点（一个或多个）：<br> <code>[node(vertex.value - n*n, Node.step+1) for n in range(1,int(vertex.value**.5)+1)]</code></p>
</li>
<li><p>判断这些节点 —符合业务条件，则return，不符合业务条件，且不在已访问集合，则追加到队尾，并加入已访问集合：</p>
</li>
</ol>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> i==<span class="number">0</span>:                   	  <span class="keyword">return</span> new_vertex.stepelif i <span class="keyword">not</span> <span class="keyword">in</span> visited:	  queue.append(new_vertex)	  visited.add(i)</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>若以上遍历完成仍未<code>return</code>，下面操作返回未找到代码：<br> <code>return -1</code></li>
</ol>
<h3 id="1091-二进制矩阵中的最短路径"><a href="#1091-二进制矩阵中的最短路径" class="headerlink" title="1091. 二进制矩阵中的最短路径"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shortest-path-in-binary-matrix/">1091. 二进制矩阵中的最短路径</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">shortestPathBinaryMatrix</span>(<span class="params">self, grid: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span>        <span class="keyword">from</span> collections <span class="keyword">import</span> deque <span class="comment"># 队列        n = len(grid)        if grid[0][0] == 1 or grid[n - 1][n - 1] == 1:  # 若起始点或终点堵塞，则不可能有这样的路径            return -1        if n == 1:            return 1        res = 1  # 注意题目的描述，是返回从 1 到 k 的路径，第一个节点被定为下标 1，        path = deque()        path.append([0, 0])  # 先压入起点        # BFS模板        while path:              for _ in range(len(path)):  # 对BFS的某一层的中所有点向8个方向进行扩展                x, y = path.popleft() # 弹出第一个元素                for new_x, new_y in [[x - 1, y - 1], [x - 1, y], [x - 1, y + 1], [x, y - 1],                                     [x, y + 1], [x + 1, y - 1], [x + 1, y], [x + 1, y + 1]]:                    # 下面几种continue可以合并一行，这里为看的清楚就分开写了                    if new_x == n - 1 and new_y == n - 1:  # 如果扩展的点到达了终点                        return res + 1                    if not 0 &lt;= new_x &lt; n or not 0 &lt;= new_y &lt; n:  # 扩展的点超出边界，则跳过                        continue                    if grid[new_x][new_y] == 1:  # 若扩展的点为阻塞，则跳过                        continue                    if grid[new_x][new_y] == -1:  # 若扩展的点已经访问过，则跳过                        continue                    if grid[new_x][new_y] == 0:  # 若为通畅点                        grid[new_x][new_y] = -1  # 当前层次下已经访问该点                        path.append([new_x, new_y])  # 将扩展的点加入path，到下一层的时候继续扩展            res += 1  # 对某一层的元素都求判定过后，距离加1(同一个层次中的所有点的距离距离起点都是相等的）        return -1</span></span><br></pre></td></tr></table></figure>

<h3 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279. 完全平方数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/perfect-squares/">279. 完全平方数</a></h3><p><img src="https://pic.leetcode-cn.com/1618493683-GOwVrO-image.png" alt="image.png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">numSquares</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span>        ps = [i * i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">int</span>(n**<span class="number">0.5</span>)+<span class="number">1</span>)][::-<span class="number">1</span>] <span class="comment"># 从大到小减去，帮助加速        pset = set(ps) # set        queue, cache = [n], &#123;n:1&#125;        while queue:            val = queue.pop(0)            if val in pset: return cache[val]            for p in ps:                if val-p &gt; 0 and val-p not in cache:                    queue.append(val-p)                    cache[val-p] = cache[val] + 1        return -1</span></span><br></pre></td></tr></table></figure>

<h3 id="127-单词接龙"><a href="#127-单词接龙" class="headerlink" title="127. 单词接龙"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/word-ladder/">127. 单词接龙</a></h3><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/word-ladder/solution/python-shen-du-jiang-jie-bfsde-jie-gou-by-allen-23/">https://leetcode-cn.com/problems/word-ladder/solution/python-shen-du-jiang-jie-bfsde-jie-gou-by-allen-23/</a></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict<span class="comment"># defaultdict与普通dict的最大作用在于：## 可以直接call一个不存在的key， 如果不存在这个key，那就先直接创建这个key，并根据默认值的设置，赋值value，而后在继续操作。class Solution(object):    def ladderLength(self, beginWord, endWord, wordList):        # 建立通用list,         size, general_dic = len(beginWord), defaultdict(list)        for w in wordList:            for _ in range(size):                general_dic[w[:_]+&quot;*&quot;+w[_+1:]].append(w)        # BFS        queue = deque()        queue.append((beginWord, 1))  # 因为在BFS中，queue中通常会同时混合多层的node，这就无法区分层了，要区分层就要queue中直接加入当前node所属层数。        mark_dic = defaultdict(bool)  # bool 的默认值是false，因此所有不在list里的是false        mark_dic[beginWord] = True        while queue:            cur_word, level = queue.popleft()   # queue头出来一个            for i in range(size):               # 找邻居，这里的所有邻居都在level+1层                for neighbour in general_dic[cur_word[:i]+&quot;*&quot;+cur_word[i+1:]]:                    if neighbour == endWord: return level + 1                    if not mark_dic[neighbour]:                        mark_dic[neighbour] = True                        queue.append((neighbour, level+1))  #符合条件（neighbour + unmarked)的进去        return 0</span></span><br></pre></td></tr></table></figure>

<h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><h3 id="695-岛屿的最大面积"><a href="#695-岛屿的最大面积" class="headerlink" title="695. 岛屿的最大面积"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/max-area-of-island/">695. 岛屿的最大面积</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">maxAreaOfIsland</span>(<span class="params">self, grid: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span>        m = <span class="built_in">len</span>(grid)        n = <span class="built_in">len</span>(grid[<span class="number">0</span>])        ans = <span class="number">0</span>        <span class="keyword">if</span> m == <span class="number">0</span>:             <span class="keyword">return</span> <span class="number">0</span>        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">i, j</span>):</span>            <span class="keyword">if</span> (i &lt; <span class="number">0</span> <span class="keyword">or</span> i &gt;= m) <span class="keyword">or</span> (j &lt; <span class="number">0</span> <span class="keyword">or</span> j &gt;= n):                <span class="keyword">return</span> <span class="number">0</span>            <span class="keyword">if</span> grid[i][j] == <span class="number">0</span>:                <span class="keyword">return</span> <span class="number">0</span>            grid[i][j] = <span class="number">0</span>            top = dfs(i+<span class="number">1</span>, j)            bottom = dfs(i-<span class="number">1</span>, j)            left = dfs(i, j-<span class="number">1</span>)            right = dfs(i, j+<span class="number">1</span>)            <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">sum</span>([top, bottom, left, right])        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):                ans = <span class="built_in">max</span>(ans, dfs(i, j))        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-islands/">200. 岛屿数量</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;输入：grid = [  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]]输出：3&#x27;&#x27;&#x27;</span><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">numIslands</span>(<span class="params">self, grid: List[List[<span class="built_in">str</span>]]</span>) -&gt; int:</span>        m, n = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])        ans = <span class="number">0</span>         <span class="keyword">if</span> m == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span>        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">i, j</span>):</span>            <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> i &gt;= m <span class="keyword">or</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> j &gt;= n:                <span class="keyword">return</span>            <span class="keyword">if</span> grid[i][j] == <span class="string">&#x27;0&#x27;</span>:                <span class="keyword">return</span>            grid[i][j] = <span class="string">&#x27;0&#x27;</span> <span class="comment"># 遍历后置为 0            top = dfs(i+1, j)            bottom = dfs(i-1, j)            left = dfs(i, j-1)            right = dfs(i, j+1)                for i in range(m):            for j in range(n):                if grid[i][j] == &#x27;1&#x27;:                    dfs(i, j)                    ans += 1        return ans</span></span><br></pre></td></tr></table></figure>

<h3 id="130-被围绕的区域"><a href="#130-被围绕的区域" class="headerlink" title="130. 被围绕的区域"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/surrounded-regions/">130. 被围绕的区域</a></h3><p>我们只要找到四周边界上存在O且与这些O连接着的O，在搜索时先修改成其他字母，比如“#”。<br>然后遍历二维矩阵，将为O修改为X，将#修改为O即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">solve</span>(<span class="params">self, board: List[List[<span class="built_in">str</span>]]</span>) -&gt; <span class="keyword">None</span>:</span>        <span class="keyword">if</span> <span class="keyword">not</span> board:            <span class="keyword">return</span>                n, m = <span class="built_in">len</span>(board), <span class="built_in">len</span>(board[<span class="number">0</span>])        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">x, y</span>):</span>            <span class="keyword">if</span> <span class="keyword">not</span> <span class="number">0</span> &lt;= x &lt; n <span class="keyword">or</span> <span class="keyword">not</span> <span class="number">0</span> &lt;= y &lt; m <span class="keyword">or</span> board[x][y] != <span class="string">&#x27;O&#x27;</span>:                <span class="keyword">return</span>                        board[x][y] = <span class="string">&quot;A&quot;</span>            dfs(x + <span class="number">1</span>, y)            dfs(x - <span class="number">1</span>, y)            dfs(x, y + <span class="number">1</span>)            dfs(x, y - <span class="number">1</span>)                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):            dfs(i, <span class="number">0</span>)            dfs(i, m - <span class="number">1</span>)                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m - <span class="number">1</span>):            dfs(<span class="number">0</span>, i)            dfs(n - <span class="number">1</span>, i)                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):                <span class="keyword">if</span> board[i][j] == <span class="string">&quot;A&quot;</span>:                    board[i][j] = <span class="string">&quot;O&quot;</span>                <span class="keyword">elif</span> board[i][j] == <span class="string">&quot;O&quot;</span>:                    board[i][j] = <span class="string">&quot;X&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="417-太平洋大西洋水流问题"><a href="#417-太平洋大西洋水流问题" class="headerlink" title="417. 太平洋大西洋水流问题"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/pacific-atlantic-water-flow/">417. 太平洋大西洋水流问题</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span>    <span class="function"><span class="keyword">def</span> <span class="title">pacificAtlantic</span>(<span class="params">self, heights</span>):</span>        <span class="string">&quot;&quot;&quot;        :type heights: List[List[int]]        :rtype: List[List[int]]        &quot;&quot;&quot;</span>        <span class="comment"># 双BFS        def bfs(r, c, visited):            queue = [(r, c)]            visited.add((r, c))            while queue:                r, c = queue.pop(0)                for x, y in [(-1, 0), (0, -1), (1, 0), (0, 1)]:                    br, bc = r + x, c + y                    if 0 &lt;= br &lt; row and 0 &lt;= bc &lt; col and heights[br][bc] &gt;= heights[r][c] and (br, bc) not in visited:                        queue.append((br, bc))                        visited.add((br, bc))        res = []        row = len(heights)                if not row: return res        col = len(heights[0])                visited_taiping = set()     # 存放能流入太平洋的坐标        visited_daxi = set()        # 存放能流入大西洋的坐标                for r in range(row):            bfs(r, 0, visited_taiping)            bfs(r, col - 1, visited_daxi)                    for c in range(col):            bfs(0, c, visited_taiping)            bfs(row - 1, c, visited_daxi)                    res = list(visited_taiping &amp; visited_daxi) # 与        return res</span></span><br></pre></td></tr></table></figure>



<h2 id="Backtracking（回溯）"><a href="#Backtracking（回溯）" class="headerlink" title="Backtracking（回溯）"></a>Backtracking（回溯）</h2><ul>
<li>普通 DFS 主要用在 <strong>可达性问题</strong> ，这种问题只需要执行到特点的位置然后返回即可。</li>
<li>而 Backtracking 主要用于求解 <strong>排列组合</strong> 问题，例如有 { ‘a’,’b’,’c’ } 三个字符，求解所有由这三个字符排列得到的字符串，这种问题在执行到特定的位置返回之后还会继续执行求解过程。</li>
</ul>
<p>因为 Backtracking 不是立即返回，而要继续求解，因此在程序实现时，需要注意对元素的标记问题：</p>
<ul>
<li>在访问一个新元素进入新的递归调用时，需要将新元素标记为已经访问，这样才能在继续递归调用时不用重复访问该元素；</li>
<li>但是在递归返回时，需要将元素标记为未访问，因为只需要保证在一个递归链中不同时访问一个元素，可以访问已经访问过但是不在当前递归链中的元素。</li>
</ul>
<h3 id="模板1"><a href="#模板1" class="headerlink" title="模板1"></a>模板1</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res = []<span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">路径, 选择列表</span>):</span>    <span class="keyword">if</span> 满足结束条件:        res.append(路径)        <span class="keyword">return</span>              <span class="keyword">if</span> 满足剪枝条件：    	<span class="keyword">return</span>    	    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:        做选择        backtrack(路径, 选择列表)        撤销选择</span><br></pre></td></tr></table></figure>

<h3 id="t模板2"><a href="#t模板2" class="headerlink" title="t模板2"></a>t模板2</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res = []path = []<span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">未探索区域, res, path</span>):</span>    <span class="keyword">if</span> path 满足条件:        res.add(path) <span class="comment"># 深度拷贝        # return  # 如果不用继续搜索需要 return    for 选择 in 未探索区域当前可能的选择:        if 当前选择符合要求:            path.add(当前选择)            backtrack(新的未探索区域, res, path)            path.pop()</span></span><br></pre></td></tr></table></figure>



<h3 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gudrmzy0fyj615q0e6wge02.jpg"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span>(<span class="params">self, digits: <span class="built_in">str</span></span>) -&gt; List[str]:</span>        <span class="comment">#数字对应的英 [0     1     2      3      4      5      6      7       8      9]        word_list = [&quot;0&quot;, &quot;0&quot;, &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;]                #如果是空字符串直接返回空列表        if digits == &quot;&quot;:            return []                #保存结果列表        result = []                #输入的digits的长度，作为回溯函数返回的判断条件        lenth = len(digits)                #回溯函数（path当前路径，默认为&quot;&quot;）        def back_trac k(digits, index, path):            #如果目前path的长度和digits的长度相等，说明已经遍历完一趟，返回结果列表            if len(path) == lenth:                #加入result列表                result.append(path)                #返回                return                        #遍历当前索引的数字对应的英文列表            for word in word_list[int(digits[index])]: # [0 1 2 3 4 5 6 7 8 9]                #路径加上当前字母                  path = path + word                #递归下一个数字对应的英文列表 ad ae af                back_track(digits, index + 1, path)                                #撤销当前字母, ad ae af --&gt; a                path = path[:-1]        back_track(digits, 0, &quot;&quot;)        return result</span></span><br></pre></td></tr></table></figure>

<h3 id="93-复原-IP-地址"><a href="#93-复原-IP-地址" class="headerlink" title="93. 复原 IP 地址"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/restore-ip-addresses/">93. 复原 IP 地址</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">restoreIpAddresses</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; List[str]:</span>        <span class="comment">#结果存储函数        result = []        #当前路径        path = []        #回溯函数        def back_track(s, index):            #减枝，如果搜索路径大于4，直接返回            if len(path) &gt; 4:                return             #全部搜素完成，搜索路径等于4，则加入结果列表            if index == len(s) and len(path) == 4:                result.append(&quot;.&quot;.join(path))                return            #遍历整个字符串，对每一个满足的子串递归回溯            for i in range(index, len(s)):                #减枝，如果当前值在0-255之前，则开始回溯                if 0 &lt;= int(s[index : i+ 1]) &lt;= 255:                    #如果当前值是0，但是不是一个单&quot;0&quot;则剪掉                    if int(s[index : i+ 1]) == 0 and i != index:                        continue                    #如果当前值不是0，但是缺以&quot;0XXX&quot;开头，也应该剪掉                    if int(s[index : i+ 1]) &gt; 0 and s[index] == &quot;0&quot;:                        continue                    #加入当前path                    path.append(s[index: i+ 1])                    #从当前节点开始递归                    back_track(s, i + 1)                    #回溯                    path.pop() # pop list[-1]        back_track(s, 0)        return result</span></span><br></pre></td></tr></table></figure>

<h3 id="79-单词搜索"><a href="#79-单词搜索" class="headerlink" title="79. 单词搜索"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/word-search/">79. 单词搜索</a></h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gue755aje8j608y06qjrf02.jpg"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gue75ugpuaj308y06qjre.jpg"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gue7644gpbj608y06qdft02.jpg"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">exist</span>(<span class="params">self, board, word</span>):</span>                row, col = <span class="built_in">len</span>(board), <span class="built_in">len</span>(board[<span class="number">0</span>])        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">x, y, index</span>):</span>            <span class="keyword">if</span> board[x][y] != word[index]:                <span class="keyword">return</span> <span class="literal">False</span>            <span class="keyword">if</span> index == <span class="built_in">len</span>(word) - <span class="number">1</span>:                <span class="keyword">return</span> <span class="literal">True</span>                        board[x][y] = <span class="string">&#x27;1&#x27;</span>         <span class="comment"># 访问标记                        for choice in [[0, 1], [0, -1], [1, 0], [-1, 0]]:                new_x, new_y = x + choice[0], y + choice[1]                if 0 &lt;= new_x &lt; row and 0 &lt;= new_y &lt; col and dfs(new_x, new_y, index + 1):                    return True            board[x][y] = word[index] # 取消访问标记                # 遍历        for i in range(row):            for j in range(col):                if dfs(i, j, 0):                    return True        return False</span></span><br></pre></td></tr></table></figure>

<h3 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257. 二叉树的所有路径"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-paths/">257. 二叉树的所有路径</a></h3><p><strong>BFS</strong>：维护一个队列，存储节点以及根到该节点的路径。一开始这个队列里只有根节点。在每一步迭代中，我们取出队列中的首节点，如果它是叶子节点，则将它对应的路径加入到答案中。如果它不是叶子节点，则将它的所有孩子节点加入到队列的末尾。当队列为空时广度优先搜索结束，我们即能得到答案。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:    def binaryTreePaths(self, root: TreeNode) -&gt; List[str]:        paths = list()        if not root:            return paths        node_queue = collections.deque([root])        path_queue = collections.deque([str(root.val)])        while node_queue:            node = node_queue.popleft()            path = path_queue.popleft()            if not node.left and not node.right: # 首节点                paths.append(path)            else:                if node.left:                    node_queue.append(node.left)                    path_queue.append(path + &#x27;-&gt;&#x27; + str(node.left.val))                                if node.right:                    node_queue.append(node.right)                    path_queue.append(path + &#x27;-&gt;&#x27; + str(node.right.val))        return paths</span></span><br></pre></td></tr></table></figure>



<h3 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutations/">46. 全排列</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">permute</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[List[int]]:</span>        path, res = [], []        <span class="function"><span class="keyword">def</span> <span class="title">back_track</span>(<span class="params">nums</span>):</span>            <span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="built_in">len</span>(nums):                res.append(path[:])                <span class="keyword">return</span> <span class="comment"># return None            for i in range(len(nums)):                if nums[i] in path:                    continue                                path.append(nums[i])                back_track(nums)                path.pop()                    back_track(nums)            return res</span></span><br></pre></td></tr></table></figure>

<h3 id="77-组合"><a href="#77-组合" class="headerlink" title="77. 组合"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combinations/">77. 组合</a></h3><ul>
<li>当depth = 0，i 需要 &lt;= 2。如果&gt; 2，则需剪枝</li>
<li>当depth = 1，i 需要 &lt;= 3。如果&gt; 3，则需剪枝</li>
<li>当depth = 2，i 需要 &lt;= 4。如果&gt; 4，则需剪枝</li>
</ul>
<p>归纳后发现，i 需要始终 &lt;= n - k + 1 + depth = 4 - 3 + 1 + depth = 2 + depth。</p>
<ul>
<li>时间复杂度：O(C(n, k) * k)，枚举结果总数为C(n, k)，每次得到一个结果需要O(k)时间。</li>
<li>空间复杂度：O(n)，最大是n层递归栈。这里不计返回值所占空间。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">combine</span>(<span class="params">self, n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; List[List[int]]:</span>                self.res = []                <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">startIdx, depth, path</span>):</span>            <span class="keyword">if</span> depth == k:                self.res.append(path[:])                <span class="keyword">return</span>            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startIdx, n + <span class="number">1</span>): <span class="comment"># 注意这里i循环到n [1, n]                if i &lt;= n - k + 1 + depth: # 剪枝: depth为当前path的长度。                    dfs(i + 1, depth + 1, path + [i])           dfs(1, 0, []) # startIdx初始为1，深度初始为0，path初始为[]。        return self.res</span></span><br></pre></td></tr></table></figure>

<h3 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum/">39. 组合总和</a></h3><ul>
<li>可以无限制重复被选取</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span>(<span class="params">self, candidates, target</span>):</span>        res = []        <span class="function"><span class="keyword">def</span> <span class="title">combination</span>(<span class="params">candidates, target, res_list</span>):</span>            <span class="keyword">if</span> target &lt; <span class="number">0</span>:                <span class="keyword">return</span>            <span class="keyword">if</span> target == <span class="number">0</span>:                res.append(res_list)            <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(candidates): <span class="comment"># 列出数据下标和数据 index, candidates[i]                # 为了避免重复 (例如candiactes=[2,3,6,7],target=7，输出[[2,2,3],[3,2,2][7]])                # 传到的下一个candicate为candicates[i:]                combination(candidates[i:], target - c, res_list + [c])                combination(candidates, target, [])        return res      #######################################################################################class Solution:    def combinationSum(self, candidates: List[int], target: int) -&gt; List[List[int]]:        if not candidates: #先解决空输入的情况            return []                candidates.sort()  #排序        res=[]        def backtrack(i, temp_sum, temp_list):             &quot;&quot;&quot;            i：遍历到candidates数组中第几个元素            temp_sum：目前遍历数组的和            temp_list：目前遍历的数组            &quot;&quot;&quot;            if temp_sum == target:                res.append(temp_list)                return            if temp_sum &gt; target:                return            for j in range(i,len(candidates)):                backtrack(j, temp_sum+candidates[j], temp_list+[candidates[j]])        backtrack(0, 0, [])        return res</span></span><br></pre></td></tr></table></figure>



<h3 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40. 组合总和 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum-ii/">40. 组合总和 II</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum2</span>(<span class="params">self, candidates: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[List[int]]:</span>                <span class="keyword">if</span> <span class="keyword">not</span> candidates:            <span class="keyword">return</span> []                candidates.sort()		        res = []        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">index, temp_sum, temp_list</span>):</span>            <span class="keyword">if</span> temp_sum &gt; target:                <span class="keyword">return</span>            <span class="keyword">if</span> temp_sum == target:                res.append(temp_list)                <span class="keyword">return</span>            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(index, <span class="built_in">len</span>(candidates)):                <span class="keyword">if</span> j &gt; index <span class="keyword">and</span> candidates[j] == candidates[j - <span class="number">1</span>]:                    <span class="keyword">continue</span>                backtrack(j + <span class="number">1</span>, temp_sum + candidates[j], temp_list + [candidates[j]])        backtrack(<span class="number">0</span>, <span class="number">0</span>, [])        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h3 id="216-组合总和-III"><a href="#216-组合总和-III" class="headerlink" title="216. 组合总和 III"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum-iii/">216. 组合总和 III</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum3</span>(<span class="params">self, k: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; List[List[int]]:</span>        candidates = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>))        res = []        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">i, temp_sum, temp_list</span>):</span>            <span class="keyword">if</span> temp_sum==n <span class="keyword">and</span> <span class="built_in">len</span>(temp_list)==k:                res.append(temp_list)                <span class="keyword">return</span>            <span class="keyword">if</span> <span class="built_in">len</span>(temp_list)==k:                <span class="keyword">return</span>            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, <span class="built_in">len</span>(candidates)):                backtrack(j+<span class="number">1</span>, temp_sum+candidates[j], temp_list+[candidates[j]])        backtrack(<span class="number">0</span>,<span class="number">0</span>,[])        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h3 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subsets/">78. 子集</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">subsets</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[List[int]]:</span>        res = []        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">index, temp_res</span>):</span>            res.append(temp_res)            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index, <span class="built_in">len</span>(nums)):                backtrack(i + <span class="number">1</span>, temp_res + [nums[i]])                backtrack(<span class="number">0</span>, [])        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h3 id="90-子集-II"><a href="#90-子集-II" class="headerlink" title="90. 子集 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subsets-ii/">90. 子集 II</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">subsetsWithDup</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[List[int]]:</span>        res = []        nums.sort() <span class="comment"># 排序                def backtrack(index, tmp_res):            res.append(tmp_res)            for j in range(index, len(nums)):                if j &gt; index and nums[j] == nums[j-1]: # 去重                    continue # pass the same number                backtrack(j + 1, tmp_res + [nums[j]])                backtrack(0, [])                return res</span></span><br></pre></td></tr></table></figure>

<h3 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131. 分割回文串"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/palindrome-partitioning/">131. 分割回文串</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span>    <span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">self, s</span>):</span>        self.isPalindrome = <span class="keyword">lambda</span> s : s == s[::-<span class="number">1</span>]        res = []        self.backtrack(s, res, [])        <span class="keyword">return</span> res            <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">self, s, res, path</span>):</span>        <span class="keyword">if</span> <span class="keyword">not</span> s:            res.append(path)            <span class="keyword">return</span>        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(s) + <span class="number">1</span>): <span class="comment">#注意起始和结束位置            if self.isPalindrome(s[:i]):                self.backtrack(s[i:], res, path + [s[:i]])</span></span><br></pre></td></tr></table></figure>

<h3 id="37-解数独"><a href="#37-解数独" class="headerlink" title="37. 解数独"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sudoku-solver/">37. 解数独</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">solveSudoku</span>(<span class="params">self, board: List[List[<span class="built_in">str</span>]]</span>) -&gt; <span class="keyword">None</span>:</span>        <span class="string">&quot;&quot;&quot;        Do not return anything, modify board in-place instead.        &quot;&quot;&quot;</span>        rem_num = [[[<span class="built_in">str</span>(k) <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)] <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)]        <span class="comment"># rem_num 存储九宫格中每个格子还未填入的数字为 “.“，初始化为1-9所有数字，下面的循环将已经填过的数字剔除        for i in range(9):            for j in range(9):                row, col = i//3, j//3                if board[i][j] != &#x27;.&#x27;: rem_num[row][col].remove(board[i][j])        def dfs(i, j):            if j &gt; 8: # 从左往右，从上往下遍历每个格子，若列数超过最大值，则行数+1列数归0                i, j = i + 1, 0            if i &gt; 8: return True # 行数超过最大值，说明遍历完成，返回True            if board[i][j] != &#x27;.&#x27;: return dfs(i, j+1) # 若当前格子已填充，递归下一个格子                        # 若当前格子未填充，则对当前格子所在九宫格中未填过数字（即rem_num[row][col]中的数字）逐一尝试填入            row, col = i//3, j//3            for k in range(len(rem_num[row][col])):                num_cur = rem_num[row][col].pop(k)# 弹出一个数字，若该数字所在行和列无重复，则赋给当前格子                if num_cur not in [board[ii][j] for ii in range(9)] and num_cur not in board[i][:]:                    board[i][j] = num_cur                    if dfs(i, j+1): return True # 递归下一个格子，若为真，返回True                    # 递归下一个格子返回False，说明当前填法不正确，回溯（下面两语句为状态恢复）                              board[i][j] = &#x27;.&#x27;  # 恢复当前格子为未填充状态                rem_num[row][col].insert(k, num_cur) # 将之前从九宫格未填数字列表中取出的数字放回            else: return False # 所有尝试都不成功，说明当前路径行不通，返回False        dfs(0, 0)</span></span><br></pre></td></tr></table></figure>

<h3 id="51-N-皇后"><a href="#51-N-皇后" class="headerlink" title="51. N 皇后"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/n-queens/">51. N 皇后</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">solveNQueens</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; List[List[str]]:</span>        res = [] <span class="comment"># 记录结果        col, diagr, diagl, board = [True]*n, [True]*(2*n-1), [True]*(2*n-1), [[&#x27;.&#x27; for _ in range(n)] for _ in range(n)]        # col, diagr, diagl 的元素分别表示当前列、右对角线、左对角线是否还可以放置；board为记录摆放位置的n*n矩阵        def traceback(i, j):            if i &gt;= n: return # 当前行超过最大行号，返回            if not col[j] or not diagr[j-i+n-1] or not diagl[j+i]: return # 当前列或右对角线或左对角线不能放置皇后，返回            board[i][j] = &#x27;Q&#x27; # 当前位置可以放置，将board对应位置的元素赋为&#x27;Q&#x27;            if i == n - 1 and col[j] and diagr[j-i+n-1] and diagl[j+i]: # 当前已到最后一行，且当前位置可以放置，将摆放结果按正确的形式加入res中                res.append([&#x27;&#x27;.join(line) for line in board])            # 此后说明，当前位置可放置且未到最后一行            col[j], diagr[j-i+n-1], diagl[j+i] = False, False, False # 将当前位置对应的列、左右对角线的记为不能放置，并继续下一行的遍历            for k in range(n):                traceback(i+1, k)            col[j], diagr[j-i+n-1], diagl[j+i], board[i][j] = True, True, True, &#x27;.&#x27; # 恢复当前位置的各参数，回溯（关键！）        for j in range(n): # 从首行开始，遍历每一列            traceback(0, j)        return res # 返回结果</span></span><br></pre></td></tr></table></figure>



<h1 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h1><p>动态规划：保存历史记录（<code>dp[]、dp[][]</code>），避免重复计算</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化 base casedp[0][0][...] = base# 进行状态转移for 状态1 in 状态1的所有取值：    for 状态2 in 状态2的所有取值：        for ...            dp[状态1][状态2][...] = 求最值(选择1，选择2...)</span></span><br></pre></td></tr></table></figure>



<p><strong>一般步骤：</strong></p>
<ol>
<li>定义数组元素的含义<ul>
<li><code>dp = [[0] * n for _ in range(m)] 区别 dp = [[0] * n] * m</code></li>
</ul>
</li>
<li>找出数组元素之间的关系<ul>
<li>推 <code>dp[i] 与 dp[i - 1]</code>，<code>dp[i][j] 与 dp[i][j - 1] dp[i - 1][j] </code></li>
<li>小 <code>dp[i][j] = min(dp[i - 1][j], dp[i][j - 1] + arr[i][j])</code></li>
<li>大 <code>dp[i][j] = max(dp[i - 1][j], dp[i][j - 1] + arr[i][j])</code></li>
</ul>
</li>
<li>找出初始值<ul>
<li>一维边界 <code>dp[0] dp[1]</code></li>
<li>二维边界 <code>dp[0][j] dp[i][0]</code></li>
</ul>
</li>
</ol>
<p><code>递归</code>和<code>动态规划</code>都是将原问题拆成多个子问题然后求解，他们之间最本质的区别是，动态规划保存了子问题的解，避免重复计算。递归的解法，是「<strong>自顶向下</strong>」的思路。如果转成「<strong>自底向上</strong>」的思路，就变成了动态规划。</p>
<p>步骤：</p>
<ol>
<li><p>确定子问题</p>
</li>
<li><p>写出子问题的递推关系和边界</p>
</li>
<li><p>确定 DP 的计算顺序</p>
<ul>
<li>在确定了子问题的递推关系之后，下一步就是依次计算出这些子问题了。在很多教程中都会写，动态规划有两种计算顺序，一种是自顶向下的、使用备忘录的递归方法，一种是自底向上的、使用 dp 数组的循环方法。不过在普通的动态规划题目中，99% 的情况我们都不需要用到备忘录方法，所以我们最好坚持用自底向上的 dp 数组。</li>
</ul>
</li>
<li><p>空间优化</p>
</li>
</ol>
<h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><h3 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/climbing-stairs/">70. 爬楼梯</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 递归class Solution:    def climbStairs(self, n: int) -&gt; int:        if n == 0 or n == 1:            return 1        return self.climbStairs(n - 1) + self.climbStairs(n - 2)# 一维dp，自底向上, f(n) = f(n-1) + f(n-2)&#x27;&#x27;&#x27;设 dp[n] 为第 n 阶楼梯的方案数，那么有 dp[n] = dp[n - 1] + dp[n - 2]。注意，边界值 dp[0] = dp[1] = 1&#x27;&#x27;&#x27;class Solution:    def climbStairs(self, n: int) -&gt; int:        dp = [0] * (n + 1) # dp_list length = n+1, [0, n]        dp[0] = dp[1] = 1 # 边界 注意 dp[0]        for i in range(2, n + 1): # [2, n]            dp[i] = dp[i - 1] + dp[i - 2]        return dp[-1]    # f(n) 只依赖于 f(n-1) 和 f(n-2)，只需要两项就足够了class Solution:    def climbStairs(self, n: int) -&gt; int:        a = b = 1        for i in range(2, n + 1): #[2, n]            a, b = b, a + b        return b</span></span><br></pre></td></tr></table></figure>

<h3 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746. 使用最小花费爬楼梯"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/">746. 使用最小花费爬楼梯</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">minCostClimbingStairs</span>(<span class="params">self, cost: List[<span class="built_in">int</span>]</span>) -&gt; int:</span>        dp = [<span class="number">0</span>] * (<span class="built_in">len</span>(cost))                <span class="comment"># 第一步 1 个台阶         dp[0] = cost[0]         # 第一步 2 个台阶        dp[1] = cost[1]        for i in range(2, len(cost)):            dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i]                    return min(dp[len(cost) - 1], dp[len(cost) - 2]) # min(倒数第二步，倒数第一步)</span></span><br></pre></td></tr></table></figure>



<h3 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/house-robber/">198. 打家劫舍</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">rob</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span>        n = <span class="built_in">len</span>(nums) + <span class="number">1</span>                dp = [<span class="number">0</span>] * n        dp[<span class="number">0</span>] = <span class="number">0</span>        dp[<span class="number">1</span>] = nums[<span class="number">0</span>]        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n):            dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + nums[i - <span class="number">1</span>])        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h3 id="213-打家劫舍-II"><a href="#213-打家劫舍-II" class="headerlink" title="213. 打家劫舍 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/house-robber-ii/">213. 打家劫舍 II</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;# 如果不偷窃最后一间房屋，则偷窃房屋的下标范围是 [0, n-2][0, n−2]# 如果不偷窃第一间房屋，则偷窃房屋的下标范围是 [1, n-1][1, n−1]&#x27;&#x27;&#x27;</span><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">rob</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span>        <span class="function"><span class="keyword">def</span> <span class="title">robRange</span>(<span class="params">start: <span class="built_in">int</span>, end: <span class="built_in">int</span></span>):</span>            first = nums[start]             second = <span class="built_in">max</span>(nums[start], nums[start + <span class="number">1</span>]) <span class="comment"># nums[0] + nums[2] ? &gt; nums[1]            for i in range(start + 2, end + 1): # 边界                first, second = second, max(first + nums[i], second)             return second                length = len(nums)        if length == 1:            return nums[0]        elif length == 2:            return max(nums[0], nums[1])        else:            return max(robRange(0, length - 2), robRange(1, length - 1) )</span></span><br></pre></td></tr></table></figure>

<h2 id="矩阵路径"><a href="#矩阵路径" class="headerlink" title="矩阵路径"></a>矩阵路径</h2><h3 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64. 最小路径和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-path-sum/">64. 最小路径和</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">minPathSum</span>(<span class="params">self, grid: [[<span class="built_in">int</span>]]</span>) -&gt; int:</span>        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(grid)):            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(grid[<span class="number">0</span>])):                <span class="keyword">if</span> i == j == <span class="number">0</span>:                    <span class="keyword">continue</span>                <span class="keyword">elif</span> i == <span class="number">0</span>:                    grid[i][j] = grid[i][j] + grid[i][j - <span class="number">1</span>]                <span class="keyword">elif</span> j == <span class="number">0</span>:                    grid[i][j] = grid[i][j] + grid[i - <span class="number">1</span>][j]                <span class="keyword">else</span>:                    grid[i][j] = grid[i][j] + <span class="built_in">min</span>(grid[i - <span class="number">1</span>][j], grid[i][j - <span class="number">1</span>])          <span class="keyword">return</span> grid[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h3 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-paths/">62. 不同路径</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span> <span class="comment"># 动态规划    def uniquePaths(self, m: int, n: int) -&gt; int:        # dp = [[1 for i in range(n)] for j in range(m)]        # [[1] * n]: [1, 1, 1...], [[1] + [0] * (n - 1) for _ in range(m - 1)]: [1, 0 , 0...] * (m -1)        dp = dp = [[1] * n] + [[1] + [0] * (n - 1) for _ in range(m - 1)]        for i in range(1, m):            for j in range(1, n):                dp[i][j] = dp[i][j - 1] + dp[i - 1][j]        return dp[m - 1][n - 1]</span></span><br></pre></td></tr></table></figure>

<h3 id="63-不同路径-II"><a href="#63-不同路径-II" class="headerlink" title="63. 不同路径 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-paths-ii/">63. 不同路径 II</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">uniquePathsWithObstacles</span>(<span class="params">self, obstacleGrid: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span>        <span class="comment"># 构造一个DP table        row = len(obstacleGrid)        col = len(obstacleGrid[0])        dp = [[0 for _ in range(col)] for _ in range(row)]        dp[0][0] = 1 if obstacleGrid[0][0] != 1 else 0                # 如果第一个格子就是障碍，return 0        if dp[0][0] == 0: return 0                  # 初始化        ## 第一列        for i in range(1, col):            if obstacleGrid[0][i] != 1:                dp[0][i] = dp[0][i-1]        ## 第一行        for i in range(1, row):            if obstacleGrid[i][0] != 1:                dp[i][0] = dp[i-1][0]                for i in range(1, row):            for j in range(1, col):                if obstacleGrid[i][j] != 1:                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1]                            return dp[-1][-1]</span></span><br></pre></td></tr></table></figure>



<h2 id="数组区间"><a href="#数组区间" class="headerlink" title="数组区间"></a>数组区间</h2><h3 id="303-区域和检索-数组不可变"><a href="#303-区域和检索-数组不可变" class="headerlink" title="303. 区域和检索 - 数组不可变"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/range-sum-query-immutable/">303. 区域和检索 - 数组不可变</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>):</span>        self.sums = [<span class="number">0</span>]        <span class="keyword">for</span> num <span class="keyword">in</span> nums:            self.sums.append(self.sums[-<span class="number">1</span>] + num)    <span class="function"><span class="keyword">def</span> <span class="title">sumRange</span>(<span class="params">self, left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>) -&gt; int:</span>        _sums = self.sums        <span class="keyword">return</span> _sums[right + <span class="number">1</span>] - _sums[left]<span class="comment"># Your NumArray object will be instantiated and called as such:# obj = NumArray(nums)# param_1 = obj.sumRange(left,right)</span></span><br></pre></td></tr></table></figure>

<h3 id="413-等差数列划分"><a href="#413-等差数列划分" class="headerlink" title="413. 等差数列划分"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/arithmetic-slices/">413. 等差数列划分</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">numberOfArithmeticSlices</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span>        <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt; <span class="number">3</span>:            <span class="keyword">return</span> <span class="number">0</span>                dp = [<span class="number">0</span>] * (<span class="built_in">len</span>(nums) + <span class="number">1</span>)        dp[<span class="number">0</span>] = <span class="number">0</span>        dp[<span class="number">1</span>] = <span class="number">0</span>        res = <span class="number">0</span>        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">len</span>(nums)):            <span class="keyword">if</span> nums[i] - nums[i - <span class="number">1</span>] == nums[i - <span class="number">1</span>] - nums[i - <span class="number">2</span>]:                dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>                res += dp[i]        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="分割整数"><a href="#分割整数" class="headerlink" title="分割整数"></a>分割整数</h2><h3 id="343-整数拆分"><a href="#343-整数拆分" class="headerlink" title="343. 整数拆分"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/integer-break/">343. 整数拆分</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">integerBreak</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span>        dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)        dp[<span class="number">2</span>] = <span class="number">1</span>        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, n + <span class="number">1</span>):            <span class="comment"># 假设对正整数 i 拆分出的第一个正整数是 j（1 &lt;= j &lt; i），则有以下两种方案：            # 1) 将 i 拆分成 j 和 i−j 的和，且 i−j 不再拆分成多个正整数，此时的乘积是 j * (i-j)            # 2) 将 i 拆分成 j 和 i−j 的和，且 i−j 继续拆分成多个正整数，此时的乘积是 j * dp[i-j]            # 3）dp[i] 下一次            for j in range(1, i - 1):                dp[i] = max(dp[i], j * (i - j), j * dp[i - j])          return dp[n]</span></span><br></pre></td></tr></table></figure>

<h3 id="279-完全平方数-1"><a href="#279-完全平方数-1" class="headerlink" title="279. 完全平方数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/perfect-squares/">279. 完全平方数</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">numSquares</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span>        dp=[i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)] <span class="comment"># 全1组成                for i in range(2, n + 1):            for j in range(1,int(i**(0.5)) + 1):                dp[i] = min(dp[i], dp[i - j*j] + 1)        return dp[-1]</span></span><br></pre></td></tr></table></figure>

<h3 id="91-解码方法"><a href="#91-解码方法" class="headerlink" title="91. 解码方法"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/decode-ways/">91. 解码方法</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">numDecodings</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; int:</span>        <span class="keyword">if</span> s.startswith(<span class="string">&#x27;0&#x27;</span>):  <span class="comment"># 开头有 ‘0’ 直接返回            return 0        n = len(s)        dp = [1] * (n + 1)  # 重点是 dp[0], dp[1] = 1, 1        for i in range(2, n + 1):            if s[i - 1] == &#x27;0&#x27; and s[i - 2] not in &#x27;12&#x27;:  # 出现前导 ‘0’ 的情况，不能解码，直接返回                return 0            if s[i - 2: i] in [&#x27;10&#x27;, &#x27;20&#x27;]:  # 只有组合在一起才能解码                dp[i] = dp[i - 2]            elif &#x27;10&#x27; &lt; s[i - 2: i] &lt;= &#x27;26&#x27;: # 两种解码方式                dp[i] = dp[i - 1] + dp[i - 2]            else:                         # &#x27;01&#x27;到 ‘09’ 或 &gt; &#x27;26&#x27;，只有单独才能解码                dp[i] = dp[i - 1]        return dp[n]</span></span><br></pre></td></tr></table></figure>



<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96. 不同的二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">numTrees</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span>        dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)        dp[<span class="number">0</span>], dp[<span class="number">1</span>] = <span class="number">1</span>, <span class="number">1</span>        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, i + <span class="number">1</span>):                dp[i] += dp[j - <span class="number">1</span>] * dp[i - j] <span class="comment"># j-1 为j为头结点左子树节点数量，i-j 为以j为头结点右子树节点数量        return dp[-1]</span></span><br></pre></td></tr></table></figure>



<h2 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h2><h3 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300. 最长递增子序列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">300. 最长递增子序列</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span>        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> <span class="number">0</span>        dp = [<span class="number">1</span>] * <span class="built_in">len</span>(nums)        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):                <span class="keyword">if</span> nums[j] &lt; nums[i]:                     dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>)        <span class="keyword">return</span> <span class="built_in">max</span>(dp)</span><br></pre></td></tr></table></figure>

<h3 id="646-最长数对链"><a href="#646-最长数对链" class="headerlink" title="646. 最长数对链"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-length-of-pair-chain/">646. 最长数对链</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span> <span class="comment">#Time Limit Exceeded    def findLongestChain(self, pairs):        pairs.sort()        dp = [1] * len(pairs)        for j in range(len(pairs)):            for i in range(j):                if pairs[i][1] &lt; pairs[j][0]:                    dp[j] = max(dp[j], dp[i] + 1)        return max(dp)</span></span><br></pre></td></tr></table></figure>

<h3 id="376-摆动序列"><a href="#376-摆动序列" class="headerlink" title="376. 摆动序列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/wiggle-subsequence/">376. 摆动序列</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">wiggleMaxLength</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span>        up, down = <span class="number">1</span>, <span class="number">1</span>        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):            <span class="keyword">if</span> nums[i] &gt; nums[i-<span class="number">1</span>]:                up = down + <span class="number">1</span>            <span class="keyword">elif</span> nums[i] &lt; nums[i-<span class="number">1</span>]:                down = up + <span class="number">1</span>        <span class="keyword">return</span> <span class="built_in">max</span>(up, down)</span><br></pre></td></tr></table></figure>

<h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><h3 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143. 最长公共子序列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-common-subsequence/">1143. 最长公共子序列</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span>    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonSubsequence</span>(<span class="params">self, text1, text2</span>):</span>        M, N = <span class="built_in">len</span>(text1), <span class="built_in">len</span>(text2)        dp = [[<span class="number">0</span>] * (N + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(M + <span class="number">1</span>)]        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, M + <span class="number">1</span>):            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, N + <span class="number">1</span>):                <span class="keyword">if</span> text1[i - <span class="number">1</span>] == text2[j - <span class="number">1</span>]:                    <span class="comment"># dp[i][j] 的含义是 text1[0:i-1] 和 text2[0:j-1]                     dp[i][j] = dp[i - 1][j - 1] + 1                else:                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])        return dp[M][N]</span></span><br></pre></td></tr></table></figure>

<h2 id="0-1-背包"><a href="#0-1-背包" class="headerlink" title="0-1 背包"></a>0-1 背包</h2><p>有一个容量为 N 的背包，要用这个背包装下物品的价值最大，这些物品有两个属性：体积 w 和价值 v。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gukptbo52hj60pc0dqwf902.jpg" alt="动态规划-背包问题1"></p>
<p>从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。</p>
<p><code>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])</code></p>
<ul>
<li><p>不选： <code>dp[i - 1][j]</code> </p>
</li>
<li><p>选：<code>dp[i - 1][j - weight[i]] + value[i]</code>  </p>
</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1guk09hcbzzj60d601874502.jpg" alt="img"></p>
<h3 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416. 分割等和子集"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">416. 分割等和子集</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">canPartition</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; bool:</span>        sumAll = <span class="built_in">sum</span>(nums)        <span class="keyword">if</span> sumAll % <span class="number">2</span>:            <span class="keyword">return</span> <span class="literal">False</span>        target = sumAll // <span class="number">2</span>        dp = [<span class="literal">False</span>] * (target + <span class="number">1</span>)        dp[<span class="number">0</span>] = <span class="literal">True</span>        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(target, nums[i] - <span class="number">1</span>, -<span class="number">1</span>): <span class="comment"># 从后往前，先计算 dp[i] 再计算 dp[i - num]                dp[j] = dp[j] or dp[j - nums[i]]        return dp[-1]# 二维数组class Solution:    def findTargetSumWays(self, nums: List[int], target: int) -&gt; int:        sums = sum(nums)        if sums &lt; abs(target) or (sums + target) % 2:            return 0        target = (sums + target) // 2        n = len(nums)        dp = [[0] * (target + 1) for _ in range(n + 1)]        for i in range(n + 1):            dp[i][0] = 1        # 注意遍历范围        for i in range(1, n + 1):            for j in range(target + 1):                num = nums[i - 1]                if j &lt; num:                    dp[i][j] = dp[i - 1][j]                else:                    dp[i][j] = dp[i - 1][j] + dp[i - 1][j - num]                return dp[-1][-1]</span></span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="-2"><a href="#-2" class="headerlink" title=""></a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="-3"><a href="#-3" class="headerlink" title=""></a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="-4"><a href="#-4" class="headerlink" title=""></a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="-5"><a href="#-5" class="headerlink" title=""></a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="-6"><a href="#-6" class="headerlink" title=""></a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="-7"><a href="#-7" class="headerlink" title=""></a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="-8"><a href="#-8" class="headerlink" title=""></a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="-9"><a href="#-9" class="headerlink" title=""></a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="-10"><a href="#-10" class="headerlink" title=""></a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="-11"><a href="#-11" class="headerlink" title=""></a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="-12"><a href="#-12" class="headerlink" title=""></a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="-13"><a href="#-13" class="headerlink" title=""></a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="-14"><a href="#-14" class="headerlink" title=""></a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="-15"><a href="#-15" class="headerlink" title=""></a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="-16"><a href="#-16" class="headerlink" title=""></a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="-17"><a href="#-17" class="headerlink" title=""></a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="-18"><a href="#-18" class="headerlink" title=""></a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="-19"><a href="#-19" class="headerlink" title=""></a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="-20"><a href="#-20" class="headerlink" title=""></a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="-21"><a href="#-21" class="headerlink" title=""></a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="-22"><a href="#-22" class="headerlink" title=""></a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="-23"><a href="#-23" class="headerlink" title=""></a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="-24"><a href="#-24" class="headerlink" title=""></a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="-25"><a href="#-25" class="headerlink" title=""></a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="-26"><a href="#-26" class="headerlink" title=""></a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="-27"><a href="#-27" class="headerlink" title=""></a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="-28"><a href="#-28" class="headerlink" title=""></a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="-29"><a href="#-29" class="headerlink" title=""></a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="-30"><a href="#-30" class="headerlink" title=""></a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="-31"><a href="#-31" class="headerlink" title=""></a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="-32"><a href="#-32" class="headerlink" title=""></a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="-33"><a href="#-33" class="headerlink" title=""></a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="-34"><a href="#-34" class="headerlink" title=""></a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="-35"><a href="#-35" class="headerlink" title=""></a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="-36"><a href="#-36" class="headerlink" title=""></a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="-37"><a href="#-37" class="headerlink" title=""></a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="-38"><a href="#-38" class="headerlink" title=""></a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="-39"><a href="#-39" class="headerlink" title=""></a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h1><h2 id="素数、公约数、公倍数"><a href="#素数、公约数、公倍数" class="headerlink" title="素数、公约数、公倍数"></a>素数、公约数、公倍数</h2><h3 id="素数分解"><a href="#素数分解" class="headerlink" title="素数分解"></a>素数分解</h3><p>每一个数都可以分解成素数的乘积，例如 84 = 22 * 31 * 50 * 71 * 110 * 130 * 170 * …</p>
<h3 id="204-计数质数"><a href="#204-计数质数" class="headerlink" title="204. 计数质数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-primes/">204. 计数质数</a></h3><p>统计所有小于非负整数 <em><code>n</code></em> 的质数的数量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 10输出：4解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;埃氏筛的原理&#x27;&#x27;&#x27;</span><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">countPrimes</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span>        <span class="comment"># 定义数组标记是否是质数        is_prime = [1] * n                count = 0        for i in range(2, n): # 2-n 倍            # 将质数的倍数标记为合数            if is_prime[i]:                count += 1                # 从 i*i 开始标记                for j in range(i*i, n, i):                    is_prime[j] = 0        return count</span></span><br></pre></td></tr></table></figure>

<h3 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hcf</span>(<span class="params">x, y</span>):</span>   <span class="string">&quot;&quot;&quot;该函数返回两个数的最大公约数&quot;&quot;&quot;</span>    <span class="comment"># 获取最小值   if x &gt; y:       smaller = y   else:       smaller = x    for i in range(1, smaller + 1):       if((x % i == 0) and (y % i == 0)):           hcf = i   return hcf# 位操作</span></span><br></pre></td></tr></table></figure>

<h3 id="最小公倍数"><a href="#最小公倍数" class="headerlink" title="最小公倍数"></a>最小公倍数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 最小公倍数为两数的乘积除以最大公约数。对于 a 和 b 的最大公约数 f(a, b)，有：- 如果 a 和 b 均为偶数，f(a, b) = 2*f(a/2, b/2);- 如果 a 是偶数 b 是奇数，f(a, b) = f(a/2, b);- 如果 b 是偶数 a 是奇数，f(a, b) = f(a, b/2);- 如果 a 和 b 均为奇数，f(a, b) = f(b, a-b);</span></span><br></pre></td></tr></table></figure>

<h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><h3 id="504-七进制数"><a href="#504-七进制数" class="headerlink" title="504. 七进制数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/base-7/">504. 七进制数</a></h3><p>给定一个整数 <code>num</code>，将其转化为 <strong>7 进制</strong>，并以字符串形式输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入: num &#x3D; 100输出: &quot;202&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 递归class Solution:    def convertToBase7(self, num: int) -&gt; str:        if num &lt; 0:            return &quot;-&quot; + self.convertToBase7(-num)        if num &lt; 7:            return str(num)        return self.convertToBase7(num // 7) + str(num % 7)# 迭代class Solution:    def convertToBase7(self, num: int) -&gt; str:        if num == 0:            return 0        ans = []        is_negative = num &lt; 0        num = abs(num)        while num &gt; 0:            num, remain = num // 7, num % 7            ans.append(str(remain))        return &quot;-&quot; + &quot;&quot;.join(ans[::-1]) if is_negative else &quot;&quot;.join(ans[::-1])</span></span><br></pre></td></tr></table></figure>

<h3 id="405-数字转换为十六进制数"><a href="#405-数字转换为十六进制数" class="headerlink" title="405. 数字转换为十六进制数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/convert-a-number-to-hexadecimal/">405. 数字转换为十六进制数</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 判断转换class Solution:    def toHex(self, num: int) -&gt; str:        res = &#x27;&#x27;        if num &lt; 0:            num =( abs(num) ^ (2**32-1)) + 1        elif num == 0:            return &#x27;0&#x27;        while num:            a = num % 16            if a &gt; 9:                a = chr(a+87)            else:                a = str(a)            res += a             num &gt;&gt;= 4        return res[::-1]# 库函数class Solution:    def toHex(self, num: int) -&gt; str:       return hex(num&amp;0xFFFFFFFF)[2:]# 位运算class Solution:    def toHex(self, num: int) -&gt; str:        num &amp;= 0xFFFFFFFF        s = &quot;0123456789abcdef&quot;        res = &quot;&quot;        mask = 0b1111        while num &gt; 0:            res += s[num &amp; mask]            num &gt;&gt;= 4        return res[::-1] if res else &quot;0&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="168-Excel表列名称"><a href="#168-Excel表列名称" class="headerlink" title="168. Excel表列名称"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/excel-sheet-column-title/">168. Excel表列名称</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">convertToTitle</span>(<span class="params">self, columnNumber: <span class="built_in">int</span></span>) -&gt; str:</span>        ans = <span class="built_in">list</span>()        <span class="keyword">while</span> columnNumber &gt; <span class="number">0</span>:            columnNumber -= <span class="number">1</span>            ans.append(<span class="built_in">chr</span>(columnNumber % <span class="number">26</span> + <span class="built_in">ord</span>(<span class="string">&quot;A&quot;</span>)))            columnNumber //= <span class="number">26</span>        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(ans[::-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<h2 id="阶乘"><a href="#阶乘" class="headerlink" title="阶乘"></a>阶乘</h2><h3 id="172-阶乘后的零"><a href="#172-阶乘后的零" class="headerlink" title="172. 阶乘后的零"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/factorial-trailing-zeroes/">172. 阶乘后的零</a></h3><p>尾部的 0 由 2 * 5 得来，2 的数量明显多于 5 的数量，因此只要统计有多少个 5 即可。</p>
<p>对于一个数 N，它所包含 5 的个数为：N/5 + N/52 + N/53 + …，其中 N/5 表示不大于 N 的数中 5 的倍数贡献一个 5，N/52 表示不大于 N 的数中 52 的倍数再贡献一个 5 …。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">trailingZeroes</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span>        i=<span class="number">5</span>        count=<span class="number">0</span>        <span class="keyword">while</span> n//i:             count+=n//i            i*=<span class="number">5</span>        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>

<h2 id="字符串加减法"><a href="#字符串加减法" class="headerlink" title="字符串加减法"></a>字符串加减法</h2><h3 id="67-二进制求和"><a href="#67-二进制求和" class="headerlink" title="67. 二进制求和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/add-binary/">67. 二进制求和</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">addBinary</span>(<span class="params">self, a: <span class="built_in">str</span>, b: <span class="built_in">str</span></span>) -&gt; str:</span>        <span class="keyword">return</span> <span class="built_in">bin</span>(<span class="built_in">int</span>(a, <span class="number">2</span>)+<span class="built_in">int</span>(b, <span class="number">2</span>))[<span class="number">2</span>:]<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">addBinary</span>(<span class="params">self, a, b</span>) -&gt; str:</span>        <span class="keyword">return</span> <span class="string">&#x27;&#123;0:b&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">int</span>(a, <span class="number">2</span>) + <span class="built_in">int</span>(b, <span class="number">2</span>))      <span class="comment"># 位运算class Solution:    def addBinary(self, a, b) -&gt; str:        x, y = int(a, 2), int(b, 2)        while y:            answer = x ^ y            carry = (x &amp; y) &lt;&lt; 1            x, y = answer, carry        return bin(x)[2:]</span></span><br></pre></td></tr></table></figure>

<h3 id="415-字符串相加"><a href="#415-字符串相加" class="headerlink" title="415. 字符串相加"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/add-strings/">415. 字符串相加</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入：num1 &#x3D; &quot;11&quot;, num2 &#x3D; &quot;123&quot;输出：&quot;134&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">addStrings</span>(<span class="params">self, num1: <span class="built_in">str</span>, num2: <span class="built_in">str</span></span>) -&gt; str:</span>        <span class="keyword">return</span> <span class="built_in">str</span>(<span class="built_in">int</span>(num1)+<span class="built_in">int</span>(num2))      <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">addStrings</span>(<span class="params">self, num1: <span class="built_in">str</span>, num2: <span class="built_in">str</span></span>) -&gt; str:</span>        i = <span class="built_in">len</span>(num1)-<span class="number">1</span>        j = <span class="built_in">len</span>(num2)-<span class="number">1</span>        res = <span class="string">&quot;&quot;</span>        carry = <span class="number">0</span>        <span class="keyword">while</span> i &gt;=<span class="number">0</span> <span class="keyword">or</span> j &gt;= <span class="number">0</span>:            n1 = num1[i] <span class="keyword">if</span> i &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="string">&#x27;0&#x27;</span>            n2 = num2[j] <span class="keyword">if</span> j &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="string">&#x27;0&#x27;</span>            temp = <span class="built_in">ord</span>(n1) + <span class="built_in">ord</span>(n2) - <span class="number">2</span>*<span class="built_in">ord</span>(<span class="string">&#x27;0&#x27;</span>) + carry            cur = temp%<span class="number">10</span>             carry = temp//<span class="number">10</span>            res = <span class="built_in">chr</span>(cur+<span class="number">48</span>) + res            i -= <span class="number">1</span>            j -= <span class="number">1</span>         <span class="keyword">return</span> <span class="string">&#x27;1&#x27;</span> + res <span class="keyword">if</span> carry != <span class="number">0</span> <span class="keyword">else</span> res</span><br></pre></td></tr></table></figure>

<h2 id="相遇问题"><a href="#相遇问题" class="headerlink" title="相遇问题"></a>相遇问题</h2><h3 id="462-最少移动次数使数组元素相等-II"><a href="#462-最少移动次数使数组元素相等-II" class="headerlink" title="462. 最少移动次数使数组元素相等 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements-ii/">462. 最少移动次数使数组元素相等 II</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 找中位数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minMoves2</span>(<span class="params">self, a: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        a.sort()</span><br><span class="line">        i, j = <span class="number">0</span>, <span class="built_in">len</span>(a)-<span class="number">1</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;j:</span><br><span class="line">            ans += a[j]-a[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span>     </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="多数投票"><a href="#多数投票" class="headerlink" title="多数投票"></a>多数投票</h2><h3 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169. 多数元素"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/majority-element/">169. 多数元素</a></h3><p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[3,2,3]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        half = <span class="built_in">len</span>(nums) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> nums[half]</span><br><span class="line">      </span><br><span class="line"><span class="comment"># 摩尔投票</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        major = <span class="number">0</span> <span class="comment"># 选中</span></span><br><span class="line">        count = <span class="number">0</span> <span class="comment"># 计数</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> count == <span class="number">0</span>:</span><br><span class="line">                major = n</span><br><span class="line">            <span class="keyword">if</span> n == major:</span><br><span class="line">                count = count + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count = count - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> major</span><br></pre></td></tr></table></figure>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="367-有效的完全平方数"><a href="#367-有效的完全平方数" class="headerlink" title="367. 有效的完全平方数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-perfect-square/">367. 有效的完全平方数</a></h3><p>给定一个 正整数 num ，编写一个函数，如果 num 是一个完全平方数，则返回 true ，否则返回 false 。</p>
<p>进阶：不要 使用任何内置的库函数，如  sqrt 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入：num &#x3D; 16输出：true</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">isPerfectSquare</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; bool:</span>        x = <span class="built_in">int</span>(num ** <span class="number">0.5</span>)        <span class="keyword">if</span> x ** <span class="number">2</span> == num:            <span class="keyword">return</span> <span class="literal">True</span>        <span class="keyword">else</span>:            <span class="keyword">return</span> <span class="literal">False</span>                </span><br></pre></td></tr></table></figure>

<h3 id="326-3的幂"><a href="#326-3的幂" class="headerlink" title="326. 3的幂"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/power-of-three/">326. 3的幂</a></h3><p>给定一个整数，写一个函数来判断它是否是 3 的幂次方。如果是，返回 true ；否则，返回 false 。</p>
<p>整数 n 是 3 的幂次方需满足：存在整数 x 使得 n == 3x</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 27输出：true</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一直除 3，判断最后的结果是否为 1class Solution:    def isPowerOfThree(self, n: int) -&gt; bool:        if n &lt;= 0: return False                while n &gt; 1:            n =  n / 3        return n == 1</span></span><br></pre></td></tr></table></figure>

<h3 id="238-除自身以外数组的乘积"><a href="#238-除自身以外数组的乘积" class="headerlink" title="238. 除自身以外数组的乘积"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/product-of-array-except-self/">238. 除自身以外数组的乘积</a></h3><p>给你一个长度为 n 的整数数组 nums，其中 n &gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4]输出: [24,12,8,6]</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">productExceptSelf</span>(<span class="params">self, nums: [<span class="built_in">int</span>]</span>) -&gt; [int]:</span>        res, p, q = [<span class="number">1</span>], <span class="number">1</span>, <span class="number">1</span>        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) - <span class="number">1</span>): <span class="comment"># bottom triangle            p *= nums[i]            res.append(p)        for i in range(len(nums) - 1, 0, -1): # top triangle            q *= nums[i]            res[i - 1] *= q        return res</span></span><br></pre></td></tr></table></figure>

<h3 id="628-三个数的最大乘积"><a href="#628-三个数的最大乘积" class="headerlink" title="628. 三个数的最大乘积"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-product-of-three-numbers/">628. 三个数的最大乘积</a></h3><p>给你一个整型数组 <code>nums</code> ，在数组中找出由三个数组成的最大乘积，并输出这个乘积。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3]输出：6</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">maximumProduct</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span>        nums.sort()        <span class="comment"># 全正数 或者 全负数        res1 = nums[-1]*nums[-2]*nums[-3]        # 有正数有负数        res2 = nums[0]*nums[1]*nums[-1]        return max(res1, res2)</span></span><br></pre></td></tr></table></figure>



<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">160. 相交链表</a></h2><p>一种比较巧妙的方式是，分别为链表A和链表B设置指针A和指针B，然后开始遍历链表，如果遍历完当前链表，则将指针指向另外一个链表的头部继续遍历，直至两个指针相遇。<br>最终两个指针分别走过的路径为：<br>指针A :a+c+b<br>指针B :b+c+a<br>明显 a+c+b = b+c+a,因而如果两个链表相交，则指针A和指针B必定在相交结点相遇。</p>
<p>这一方法的时间复杂度为o(m+n),其中m和n分别为两个指针的长度，空间复杂度为o(1)。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; ListNode:        if not headA or not headB:            return None        nodeA = headA # A 节点        nodeB = headB # B 节点        # 相遇 A+C+B = B+C+A        while(nodeA !=nodeB):            nodeA = nodeA.next if nodeA else headB            nodeB = nodeB.next if nodeB else headA        return nodeA</span></span><br></pre></td></tr></table></figure>

<h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-linked-list/">206. 反转链表</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 迭代class Solution:    def reverseList(self, head: ListNode) -&gt; ListNode:        pre, cur = None, head        while cur:            nxt = cur.next            cur.next = pre            pre = cur            cur = nxt        return pre# 递归class Solution:    def reverseList(self, head: ListNode) -&gt; ListNode:        if not head or not head.next:            return head        newHead = self.reverseList(head.next)        head.next.next = head        head.next = None        return newHead</span></span><br></pre></td></tr></table></figure>

<h2 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">92. 反转链表 II</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.# class ListNode:#     def __init__(self, val=0, next=None):#         self.val = val#         self.next = nextclass Solution:    def reverseBetween(self, head: ListNode, left: int, right: int) -&gt; ListNode:        # 设置 dummyNode 是这一类问题的一般做法        dummy_node = ListNode()        dummy_node.next = head        pre = dummy_node        for _ in range(left - 1):            pre = pre.next        cur = pre.next        for _ in range(right - left):            nxt = cur.next            cur.next = nxt.next            nxt.next = pre.next            pre.next = nxt        return dummy_node.next</span></span><br></pre></td></tr></table></figure>



<h2 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></h2><p>如果 l1 或者 l2 一开始就是空链表 ，那么没有任何操作需要合并，所以我们只需要返回非空链表。否则，我们要判断 l1 和 l2 哪一个链表的头节点的值更小，然后递归地决定下一个添加到结果里的节点。如果两个链表有一个为空，递归结束。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 递归# Definition for singly-linked list.# class ListNode:#     def __init__(self, val=0, next=None):#         self.val = val#         self.next = nextclass Solution:    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -&gt; ListNode:        # 终止条件，直到两个链表都空        if not l1: return l2          if not l2: return l1                # 递归调用        if l1.val &lt;= l2.val:              l1.next = self.mergeTwoLists(l1.next, l2)            return l1        else:            l2.next = self.mergeTwoLists(l1, l2.next)            return l2</span></span><br></pre></td></tr></table></figure>

<h2 id="83-删除排序链表中的重复元素"><a href="#83-删除排序链表中的重复元素" class="headerlink" title="83. 删除排序链表中的重复元素"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">83. 删除排序链表中的重复元素</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 递归# Definition for singly-linked list.# class ListNode:#     def __init__(self, val=0, next=None):#         self.val = val#         self.next = nextclass Solution(object):    def deleteDuplicates(self, head):        if not head or not head.next:            return head        if head.val != head.next.val:            head.next = self.deleteDuplicates(head.next)        else:            move = head.next            while move.next and head.val == move.next.val:                move = move.next            return self.deleteDuplicates(move)        return head    # 递归 删除相同元素class Solution(object):    def deleteDuplicates(self, head):        if not head or not head.next: return head        head.next = self.deleteDuplicates(head.next)        return head if head.val != head.next.val else head.next    # 一次遍历# Definition for singly-linked list.# class ListNode:#     def __init__(self, val=0, next=None):#         self.val = val#         self.next = nextclass Solution:    def deleteDuplicates(self, head: ListNode) -&gt; ListNode:        if not head: return None        prev, cur = head, head.next        while cur:            if cur.val == prev.val:                prev.next = cur.next            else:                prev = cur            cur = cur.next        return head</span></span><br></pre></td></tr></table></figure>

<h2 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.# class ListNode:#     def __init__(self, val=0, next=None):#         self.val = val#         self.next = next&#x27;&#x27;&#x27;一种容易想到的方法是，我们首先从头节点开始对链表进行一次遍历，得到链表的长度 L。随后我们再从头节点开始对链表进行一次遍历，当遍历到第 L-n+1 个节点时，它就是我们需要删除的节点。&#x27;&#x27;&#x27;class Solution:    def removeNthFromEnd(self, head: ListNode, n: int) -&gt; ListNode:        def getLength(head: ListNode) -&gt; int:            length = 0            while head:                length += 1                head = head.next            return length                dummy = ListNode(0, head)        length = getLength(head)        cur = dummy        for i in range(1, length - n + 1):            cur = cur.next        cur.next = cur.next.next        return dummy.next&#x27;&#x27;&#x27;我们也可以在遍历链表的同时将所有节点依次入栈。根据栈「先进后出」的原则，我们弹出栈的第 n 个节点就是需要删除的节点，并且目前栈顶的节点就是待删除节点的前驱节点。这样一来，删除操作就变得十分方便了。&#x27;&#x27;&#x27;class Solution:    def removeNthFromEnd(self, head: ListNode, n: int) -&gt; ListNode:        dummy = ListNode(0, head)        stack = list()        cur = dummy        while cur:            stack.append(cur)            cur = cur.next                for i in range(n):            stack.pop()        prev = stack[-1]        prev.next = prev.next.next        return dummy.next</span></span><br></pre></td></tr></table></figure>

<h2 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 递归class Solution:    def swapPairs(self, head: ListNode) -&gt; ListNode:        if not head or not head.next:            return head        newHead = head.next        head.next = self.swapPairs(newHead.next)        newHead.next = head        return newHead# 迭代class Solution:    def swapPairs(self, head: ListNode) -&gt; ListNode:        dummy = ListNode()        dummy.next = head        tmp = dummy        while tmp.next and tmp.next.next:            node1 = tmp.next            node2 = node1.next            tmp.next = node2            node1.next = node2.next            node2.next = node1            tmp = node1        return dummy.next</span></span><br></pre></td></tr></table></figure>

<h2 id="445-两数相加-II"><a href="#445-两数相加-II" class="headerlink" title="445. 两数相加 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/add-two-numbers-ii/">445. 两数相加 II</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:        if l1 == None: return l2        if l2 == None: return l1        def listnode2stack(node):  # 将链表转换为各位的数字并压入栈中，返回一个 stack,栈底为数字的高位，栈顶为数字的低位            res = []            while node:                res.append(node.val)                node = node.next            return res        stack1, stack2 = listnode2stack(l1), listnode2stack(l2)        remaining = 0  # 存储 10 进制下进位数        dummynode = ListNode()  # 创建一个 dummynode，链表通常都需要创建一个 dummynode        while stack1 != [] or stack2 != [] or remaining != 0:  # 当 stack 或进位数不为空            tmp_sum = remaining  # 定义 tmp_sum 为某一位数上累计的值            # 栈顶为数字的低位，如果有则累加到这一位对应的 tmp_sum 中            if stack1 != []:                tmp_sum += stack1.pop()            if stack2 != []:                tmp_sum += stack2.pop()            new_node = ListNode(tmp_sum % 10)  # 创建新节点存储当前位的数字，由于存在进位，所以新节点的值为 tmp_sum 对 10 取余数            remaining = tmp_sum // 10  # 更新 remainging,即进到下一高位的值，即 tmp 对 10 的商            new_node.next = dummynode.next  # 将新节点的 next 指向 dummynode 的 next            dummynode.next = new_node  # 更新 dummynode 的 next 让它指向新节点        return dummynode.next</span></span><br></pre></td></tr></table></figure>

<h2 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/palindrome-linked-list/">234. 回文链表</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数组# Definition for singly-linked list.# class ListNode:#     def __init__(self, val=0, next=None):#         self.val = val#         self.next = nextclass Solution:    def isPalindrome(self, head: ListNode) -&gt; bool:        vals = []        cur = head        while cur:            vals.append(cur.val)            cur = cur.next        return vals == vals[::-1]# 递归class Solution:    def isPalindrome(self, head: ListNode) -&gt; bool:        self.front_pointer = head        def recursively_check(current_node=head):            if current_node is not None:                if not recursively_check(current_node.next):                    return False                if self.front_pointer.val != current_node.val:                    return False                self.front_pointer = self.front_pointer.next            return True        return recursively_check()</span></span><br></pre></td></tr></table></figure>

<h2 id="725-分隔链表"><a href="#725-分隔链表" class="headerlink" title="725. 分隔链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/split-linked-list-in-parts/">725. 分隔链表</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span>    <span class="function"><span class="keyword">def</span> <span class="title">splitListToParts</span>(<span class="params">self, root, k</span>):</span>        cur = root        <span class="keyword">for</span> N <span class="keyword">in</span> xrange(<span class="number">1001</span>):            <span class="keyword">if</span> <span class="keyword">not</span> cur: <span class="keyword">break</span>            cur = cur.<span class="built_in">next</span>        width, remainder = <span class="built_in">divmod</span>(N, k)        ans = []        cur = root        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(k):            head = write = ListNode(<span class="literal">None</span>)            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(width + (i &lt; remainder)):                write.<span class="built_in">next</span> = write = ListNode(cur.val)                <span class="keyword">if</span> cur: cur = cur.<span class="built_in">next</span>            ans.append(head.<span class="built_in">next</span>)        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="328-奇偶链表"><a href="#328-奇偶链表" class="headerlink" title="328. 奇偶链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/odd-even-linked-list/">328. 奇偶链表</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">oddEvenList</span>(<span class="params">self, head</span>):</span>        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:            <span class="keyword">return</span> head        half = mid = head.<span class="built_in">next</span>        cur = head        <span class="keyword">while</span> mid <span class="keyword">and</span> mid.<span class="built_in">next</span>:            cur.<span class="built_in">next</span> = mid.<span class="built_in">next</span>            cur = cur.<span class="built_in">next</span>            mid.<span class="built_in">next</span> = cur.<span class="built_in">next</span>            mid = mid.<span class="built_in">next</span>        cur.<span class="built_in">next</span> = half        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>

<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><h3 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = right# 深度优先遍历，树高为root的左子树和右子树中最高的高度加1（root节点）&#x27;&#x27;&#x27;树的总深度 = max(左子树深度，右子树深度) + 当前节点所在的一层深度左子树深度 = max(左子树的左子树深度，左子树的右子树深度) + 当前节点所在的一层深度右子树深度 = max(右子树的左子树深度，右子树的右子树深度) + 当前节点所在的一层深度递归，直到节点为null&#x27;&#x27;&#x27;class Solution:    def maxDepth(self, root: TreeNode) -&gt; int:        if not root:            return 0        l = self.maxDepth(root.left)        r = self.maxDepth(root.right)        return max(l, r) + 1</span></span><br></pre></td></tr></table></figure>

<h3 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110. 平衡二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/balanced-binary-tree/">110. 平衡二叉树</a></h3><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
<p>本题中，一棵高度平衡二叉树定义为：</p>
<blockquote>
<p>一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1 。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = right# 求左右子树的高度class Solution:    def isBalanced(self, root: TreeNode) -&gt; bool:        if not root:            return True        return abs(self.height(root.right)-self.height(root.left))&lt;2 and self.isBalanced(root.left) and self.isBalanced(root.right)	# 求高度    def height(self, node):        if not node:            return 0        return 1+max(self.height(node.right),self.height(node.left))</span></span><br></pre></td></tr></table></figure>

<h3 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543. 二叉树的直径"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">543. 二叉树的直径</a></h3><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:    def diameterOfBinaryTree(self, root: TreeNode) -&gt; int:        self.ans = 1        def depth(node):            # 访问到空节点了，返回0            if not node:                return 0            # 左儿子为根的子树的深度            L = depth(node.left)            # 右儿子为根的子树的深度            R = depth(node.right)            # 计算d_node即L+R+1 并更新ans            self.ans = max(self.ans, L + R + 1)            # 返回该节点为根的子树的深度            return max(L, R) + 1        depth(root)        return self.ans - 1</span></span><br></pre></td></tr></table></figure>

<h3 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/invert-binary-tree/">226. 翻转二叉树</a></h3><p>只要把二叉树上的每一个节点的左右子节点进行交换，最后的结果就是完全翻转之后的二叉树。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:    def invertTree(self, root: TreeNode) -&gt; TreeNode:        if not root:            return root                left = self.invertTree(root.left)        right = self.invertTree(root.right)                root.left, root.right = right, left # 交换        return root</span></span><br></pre></td></tr></table></figure>

<h3 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617. 合并二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-two-binary-trees/">617. 合并二叉树</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">mergeTrees</span>(<span class="params">self, t1: TreeNode, t2: TreeNode</span>) -&gt; TreeNode:</span>        <span class="keyword">if</span> <span class="keyword">not</span> t1:            <span class="keyword">return</span> t2        <span class="keyword">if</span> <span class="keyword">not</span> t2:            <span class="keyword">return</span> t1                merged = TreeNode(t1.val + t2.val)        merged.left = self.mergeTrees(t1.left, t2.left)        merged.right = self.mergeTrees(t1.right, t2.right)        <span class="keyword">return</span> merged</span><br></pre></td></tr></table></figure>

<h3 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum/">112. 路径总和</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:    def hasPathSum(self, root: TreeNode, sum: int) -&gt; bool:        if not root:            return False        if not root.left and not root.right:            return sum == root.val        return self.hasPathSum(root.left, sum - root.val) or self.hasPathSum(root.right, sum - root.val)</span></span><br></pre></td></tr></table></figure>

<h3 id="437-路径总和-III"><a href="#437-路径总和-III" class="headerlink" title="437. 路径总和 III"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum-iii/">437. 路径总和 III</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:    def pathSum(self, root: TreeNode, sum: int) -&gt; int:        def dfs(root, sumlist):            if root is None:                return 0                        sumlist = [num + root.val for num in sumlist]            sumlist.append(root.val)                        count = 0            for num in sumlist:                if num == sum:                    count += 1            # count = sumlist.count(sum)            return count + dfs(root.left, sumlist) + dfs(root.right, sumlist)        return dfs(root, [])</span></span><br></pre></td></tr></table></figure>

<h3 id="572-另一棵树的子树"><a href="#572-另一棵树的子树" class="headerlink" title="572. 另一棵树的子树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subtree-of-another-tree/">572. 另一棵树的子树</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.# class TreeNode(object):#     def __init__(self, x):#         self.val = x#         self.left = None#         self.right = None&#x27;&#x27;&#x27;而判断 t 是否为 s 的子树的三个条件是或的关系，即：当前两棵树相等；或者，t 是 s 的左子树；或者，t 是 s 的右子树。&#x27;&#x27;&#x27;class Solution(object):    def isSubtree(self, s, t):        &quot;&quot;&quot;        :type s: TreeNode        :type t: TreeNode        :rtype: bool        &quot;&quot;&quot;        if not s and not t:            return True        if not s or not t:            return False        return self.isSameTree(s, t) or self.isSubtree(s.left, t) or self.isSubtree(s.right, t)            def isSameTree(self, s, t):        if not s and not t:            return True        if not s or not t:            return False        return s.val == t.val and self.isSameTree(s.left, t.left) and self.isSameTree(s.right, t.right)</span></span><br></pre></td></tr></table></figure>

<h3 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/symmetric-tree/">101. 对称二叉树</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span>	<span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span>(<span class="params">self, root</span>):</span>		<span class="string">&quot;&quot;&quot;		:type root: TreeNode		:rtype: bool		&quot;&quot;&quot;</span>		<span class="keyword">if</span> <span class="keyword">not</span> root:			<span class="keyword">return</span> <span class="literal">True</span>		<span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">left,right</span>):</span>			<span class="comment"># 递归的终止条件是两个节点都为空			# 或者两个节点中有一个为空			# 或者两个节点的值不相等			if not (left or right):				return True			if not (left and right):				return False			if left.val!=right.val:				return False			return dfs(left.left,right.right) and dfs(left.right,right.left)		# 用递归函数，比较左节点，右节点		return dfs(root.left,root.right)</span></span><br></pre></td></tr></table></figure>

<h3 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111. 二叉树的最小深度"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">minDepth</span>(<span class="params">self, root: TreeNode</span>) -&gt; int:</span>        <span class="keyword">if</span> <span class="keyword">not</span> root:            <span class="keyword">return</span> <span class="number">0</span>        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">node</span>):</span>            <span class="keyword">if</span> <span class="keyword">not</span> node:                <span class="keyword">return</span> <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)            <span class="keyword">elif</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:                <span class="keyword">return</span> <span class="number">1</span>            <span class="keyword">return</span> <span class="built_in">min</span>(dfs(node.left) , dfs(node.right)) + <span class="number">1</span>        <span class="keyword">return</span> dfs(root)</span><br></pre></td></tr></table></figure>

<h3 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404. 左叶子之和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sum-of-left-leaves/">404. 左叶子之和</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.# class TreeNode:#     def __init__(self, x):#         self.val = x#         self.left = None#         self.right = Noneclass Solution:    def sumOfLeftLeaves(self, root: TreeNode) -&gt; int:            def dfs(root, flag = False):            # 初始化flag = False            if not root: return 0               # 先判断root是否为None，否则下面的判断语句会报错            if not root.right and not root.left and flag:    # 前两个条件保证是否是叶子节点，flag保证是否是左孩子                return root.val                 # 如果是左叶子结点就加上其值            return dfs(root.right, False) + dfs(root.left, True)   # 递归root的左孩子并让flag = True, 右孩子flag = False        return dfs(root)                        # 返回结果</span></span><br></pre></td></tr></table></figure>

<h3 id="687-最长同值路径"><a href="#687-最长同值路径" class="headerlink" title="687. 最长同值路径"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-univalue-path/">687. 最长同值路径</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span>    <span class="function"><span class="keyword">def</span> <span class="title">longestUnivaluePath</span>(<span class="params">self, root</span>):</span>        self.ans = <span class="number">0</span>        <span class="function"><span class="keyword">def</span> <span class="title">arrow_length</span>(<span class="params">node</span>):</span>            <span class="keyword">if</span> <span class="keyword">not</span> node: <span class="keyword">return</span> <span class="number">0</span>            left_length = arrow_length(node.left)            right_length = arrow_length(node.right)            left_arrow = right_arrow = <span class="number">0</span>            <span class="keyword">if</span> node.left <span class="keyword">and</span> node.left.val == node.val:                left_arrow = left_length + <span class="number">1</span>            <span class="keyword">if</span> node.right <span class="keyword">and</span> node.right.val == node.val:                right_arrow = right_length + <span class="number">1</span>            self.ans = <span class="built_in">max</span>(self.ans, left_arrow + right_arrow)            <span class="keyword">return</span> <span class="built_in">max</span>(left_arrow, right_arrow)        arrow_length(root)        <span class="keyword">return</span> self.ans</span><br></pre></td></tr></table></figure>

<h3 id="337-打家劫舍-III"><a href="#337-打家劫舍-III" class="headerlink" title="337. 打家劫舍 III"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/house-robber-iii/">337. 打家劫舍 III</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.# class TreeNode:#     def __init__(self, x):#         self.val = x#         self.left = None#         self.right = Noneclass Solution:    def rob(self, root: TreeNode) -&gt; int:        def _rob(root):            if not root: return 0, 0  # 偷，不偷            left = _rob(root.left)            right = _rob(root.right)            # 偷当前节点, 则左右子树都不能偷            v1 = root.val + left[1] + right[1]            # 不偷当前节点, 则取左右子树中最大的值            v2 = max(left) + max(right)            return v1, v2        return max(_rob(root))</span></span><br></pre></td></tr></table></figure>

<h3 id="671-二叉树中第二小的节点"><a href="#671-二叉树中第二小的节点" class="headerlink" title="671. 二叉树中第二小的节点"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/">671. 二叉树中第二小的节点</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:    def findSecondMinimumValue(self, root: TreeNode) -&gt; int:        def find_sec(node):            if not node:                return float(&#x27;inf&#x27;)            if node.val!=root.val:                return node.val            else:                return min(find_sec(node.left), find_sec(node.right))        x=find_sec(root)        if x==float(&#x27;inf&#x27;):            return -1        return x</span></span><br></pre></td></tr></table></figure>

<h3 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116. 填充每个节点的下一个右侧节点指针"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/">116. 填充每个节点的下一个右侧节点指针</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; &#x27;Node&#x27;:</span>                <span class="keyword">if</span> <span class="keyword">not</span> root:            <span class="keyword">return</span> root                <span class="comment"># 从根节点开始        leftmost = root                while leftmost.left:                        # 遍历这一层节点组织成的链表，为下一层的节点更新 next 指针            head = leftmost            while head:                                # CONNECTION 1                head.left.next = head.right                                # CONNECTION 2                if head.next:                    head.right.next = head.next.left                                # 指针向后移动                head = head.next                        # 去下一层的最左的节点            leftmost = leftmost.left                return root </span></span><br></pre></td></tr></table></figure>



<h2 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h2><h3 id="637-二叉树的层平均值"><a href="#637-二叉树的层平均值" class="headerlink" title="637. 二叉树的层平均值"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/">637. 二叉树的层平均值</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.# class TreeNode:#     def __init__(self, x):#         self.val = x#         self.left = None#         self.right = None# BFSclass Solution:    def averageOfLevels(self, root: TreeNode) -&gt; List[float]:        # 题目数组非空，        # if not root:        #     return []        # 返回结果        res = []        from collections import deque        # 定义队列        queue = deque()        # 将根节点入队        queue.append(root)        # 队列不为空，表达式二叉树还有节点，循环遍历        while queue:            # 先标记每层的节点数            size = len(queue)            # 定义变量，记录每次节点值            total = 0            # 这里开始遍历当前层的节点            for _ in range(size):                # 出队                node = queue.popleft()                # 先将当前节点的值存储                total += node.val                # 节点的左右节点非空时，入队                if node.left:                    queue.append(node.left)                if node.right:                    queue.append(node.right)            # 添加每层的节点值均值            res.append(total/size)        return res# DFSclass Solution:    def averageOfLevels(self, root: TreeNode) -&gt; List[float]:        totals = []        cnts = []        def dfs(node, depth):            if not node:                return                        if depth &gt;= len(totals):                totals.append(node.val)                cnts.append(1)            else:                totals[depth] += node.val                cnts[depth] += 1                        dfs(node.left, depth+1)            dfs(node.right, depth+1)                dfs(root, 0)        return [total / cnt for total, cnt in zip(totals, cnts)]</span></span><br></pre></td></tr></table></figure>

<h3 id="513-找树左下角的值"><a href="#513-找树左下角的值" class="headerlink" title="513. 找树左下角的值"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-bottom-left-tree-value/">513. 找树左下角的值</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:    def findBottomLeftValue(self, root: TreeNode) -&gt; int:        queue = deque()        if root:             queue.append(root)                    result = 0        while queue:             q_len = len(queue)            for i in range(q_len):                 if i == 0:                     result = queue[i].val                 cur = queue.popleft()                if cur.left:                     queue.append(cur.left)                if cur.right:                     queue.append(cur.right)        return result</span></span><br></pre></td></tr></table></figure>

<h2 id="前中后序遍历"><a href="#前中后序遍历" class="headerlink" title="前中后序遍历"></a>前中后序遍历</h2><p>遍历方式</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1guiko5f8g3j60h20eagly02.jpg" alt="img"></p>
<ul>
<li>Preoder 根左右：<code>根节点 -&gt; 左孩子 -&gt; 右孩子</code> 的方式遍历，即「先序遍历」，每次先遍历根节点，遍历结果为 <code>1 2 4 5 3 6 7</code>；</li>
<li>Inorder 左根右：<code>左孩子 -&gt; 根节点 -&gt; 右孩子</code> 的方式遍历，即「中序序遍历」，遍历结果为 <code>4 2 5 1 6 3 7</code>；</li>
<li>Postoder 左右根：<code>左孩子 -&gt; 右孩子 -&gt; 根节点</code> 的方式遍历，即「后序序遍历」，遍历结果为 <code>4 5 2 6 7 3 1</code>；</li>
<li>上左右下：<code>层次遍历</code> 就是按照每一层从左向右的方式进行遍历，遍历结果为<code>1 2 3 4 5 6 7</code>。</li>
</ul>
<h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 递归# 时间复杂度：O(n)，n为节点数，访问每个节点恰好一次。# 空间复杂度：空间复杂度：O(h)，h为树的高度。最坏情况下需要空间O(n)，平均情况为O(logn)# 递归1：二叉树遍历最易理解和实现版本class Solution:    def preorderTraversal(self, root: TreeNode) -&gt; List[int]:        if not root:            return []        # 前序递归        return [root.val] + self.preorderTraversal(root.left) + self.preorderTraversal(root.right)        # 中序递归         return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)        # 后序递归        return self.postorderTraversal(root.left) + self.postorderTraversal(root.right) + [root.val]# 递归2：通用模板，可以适应不同的题目，添加参数、增加返回条件、修改进入递归条件、自定义返回值class Solution:    def preorderTraversal(self, root: TreeNode) -&gt; List[int]:        def dfs(cur):            if not cur:                return                  # 前序递归            res.append(cur.val)            dfs(cur.left)</span></span><br></pre></td></tr></table></figure>



<h3 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></h3><p>按照访问根节点——左子树——右子树的方式遍历这棵树</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span>        <span class="function"><span class="keyword">def</span> <span class="title">preorder</span>(<span class="params">root: TreeNode</span>):</span>            <span class="keyword">if</span> <span class="keyword">not</span> root:                <span class="keyword">return</span>            res.append(root.val) <span class="comment"># 根            preorder(root.left)  # 左根            preorder(root.right) # 右根                res = list()        preorder(root)        return res</span></span><br></pre></td></tr></table></figure>

<h3 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145. 二叉树的后序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a></h3><p>按照访问左子树——右子树——根节点的方式遍历这棵树</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span>        <span class="function"><span class="keyword">def</span> <span class="title">postorder</span>(<span class="params">root: TreeNode</span>):</span>            <span class="keyword">if</span> <span class="keyword">not</span> root:                <span class="keyword">return</span>            postorder(root.left)            postorder(root.right)            res.append(root.val)                res = <span class="built_in">list</span>()        postorder(root)        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h3 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.# class TreeNode:#     def __init__(self, val=0, left=None, right=None):#         self.val = val#         self.left = left#         self.right = rightclass Solution:    def inorderTraversal(self, root: TreeNode) -&gt; List[int]:        def inorder(root: TreeNode):            if not root:                return            inorder(root.left)            res.append(root.val)            inorder(root.right)                            res = list()        inorder(root)        return res</span></span><br></pre></td></tr></table></figure>

<h2 id="BST二叉查找树"><a href="#BST二叉查找树" class="headerlink" title="BST二叉查找树"></a>BST二叉查找树</h2><p>二叉搜索树是一个有序树：</p>
<ul>
<li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li>
<li>它的左、右子树也分别为二叉搜索树</li>
</ul>
<h3 id="二叉树迭代"><a href="#二叉树迭代" class="headerlink" title="二叉树迭代"></a>二叉树迭代</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">searchBST</span>(<span class="params">self, root: TreeNode, val: <span class="built_in">int</span></span>) -&gt; TreeNode:</span>        <span class="comment"># 为什么要有返回值:         #   因为搜索到目标节点就要立即return，        #   这样才是找到节点就返回（搜索某一条边），如果不加return，就是遍历整棵树了。        if not root or root.val == val:             return root        if root.val &gt; val:             return self.searchBST(root.left, val)        if root.val &lt; val:             return self.searchBST(root.right, val)</span></span><br></pre></td></tr></table></figure>



<h3 id="669-修剪二叉搜索树"><a href="#669-修剪二叉搜索树" class="headerlink" title="669. 修剪二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/trim-a-binary-search-tree/">669. 修剪二叉搜索树</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="230-二叉搜索树中第K小的元素"><a href="#230-二叉搜索树中第K小的元素" class="headerlink" title="230. 二叉搜索树中第K小的元素"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/">230. 二叉搜索树中第K小的元素</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="538-把二叉搜索树转换为累加树"><a href="#538-把二叉搜索树转换为累加树" class="headerlink" title="538. 把二叉搜索树转换为累加树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/">538. 把二叉搜索树转换为累加树</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235. 二叉搜索树的最近公共祖先"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108. 将有序数组转换为二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="109-有序链表转换二叉搜索树"><a href="#109-有序链表转换二叉搜索树" class="headerlink" title="109. 有序链表转换二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/">109. 有序链表转换二叉搜索树</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="653-两数之和-IV-输入-BST"><a href="#653-两数之和-IV-输入-BST" class="headerlink" title="653. 两数之和 IV - 输入 BST"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/">653. 两数之和 IV - 输入 BST</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="530-二叉搜索树的最小绝对差"><a href="#530-二叉搜索树的最小绝对差" class="headerlink" title="530. 二叉搜索树的最小绝对差"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/">530. 二叉搜索树的最小绝对差</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="501-二叉搜索树中的众数"><a href="#501-二叉搜索树中的众数" class="headerlink" title="501. 二叉搜索树中的众数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/">501. 二叉搜索树中的众数</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h2><p>Trie，又称前缀树或字典树，用于判断字符串是否存在或者是否具有某种字符串前缀。</p>
<h3 id="208-实现-Trie-前缀树"><a href="#208-实现-Trie-前缀树" class="headerlink" title="208. 实现 Trie (前缀树)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/">208. 实现 Trie (前缀树)</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="677-键值映射"><a href="#677-键值映射" class="headerlink" title="677. 键值映射"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/map-sum-pairs/">677. 键值映射</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1><h2 id="-40"><a href="#-40" class="headerlink" title=""></a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="-41"><a href="#-41" class="headerlink" title=""></a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="-42"><a href="#-42" class="headerlink" title=""></a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="-43"><a href="#-43" class="headerlink" title=""></a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="-44"><a href="#-44" class="headerlink" title=""></a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="-45"><a href="#-45" class="headerlink" title=""></a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/two-sum/">1. 两数之和</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hash tableclass Solution:    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:        hashtable = dict()         for i, num in enumerate(nums):            if target - num in hashtable:                return [hashtable[target - num], i]            hashtable[nums[i]] = i        return []</span></span><br></pre></td></tr></table></figure>

<h2 id="217-存在重复元素"><a href="#217-存在重复元素" class="headerlink" title="217. 存在重复元素"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/contains-duplicate/">217. 存在重复元素</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">containsDuplicate</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; bool:</span>        hashtable = <span class="built_in">dict</span>()         <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):            <span class="keyword">if</span> num <span class="keyword">in</span> hashtable:                <span class="keyword">return</span> <span class="literal">True</span>            hashtable[nums[i]] = i        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h2 id="594-最长和谐子序列"><a href="#594-最长和谐子序列" class="headerlink" title="594. 最长和谐子序列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-harmonious-subsequence/">594. 最长和谐子序列</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">findLHS</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span>        dicts = &#123;&#125;        <span class="keyword">for</span> num <span class="keyword">in</span> nums:            dicts[num] = dicts.get(num, <span class="number">0</span>) + <span class="number">1</span>        res = <span class="number">0</span>        <span class="keyword">for</span> i <span class="keyword">in</span> dicts:            <span class="keyword">if</span> i + <span class="number">1</span> <span class="keyword">in</span> dicts:                res=<span class="built_in">max</span>(res, dicts[i] + dicts[i + <span class="number">1</span>])        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="128-最长连续序列"><a href="#128-最长连续序列" class="headerlink" title="128. 最长连续序列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-consecutive-sequence/">128. 最长连续序列</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242. 有效的字母异位词"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-anagram/">242. 有效的字母异位词</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">isAnagram</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; bool:</span>        <span class="comment"># return sorted(list(s)) == sorted(list(t))    	return sorted(s) == sorted(t)        # Counter    from collections import Counterclass Solution:    def isAnagram(self, s: str, t: str) -&gt; bool:        s_ = Counter(s)        t_ = Counter(t)        return s_ == t_</span></span><br></pre></td></tr></table></figure>

<h2 id="409-最长回文串"><a href="#409-最长回文串" class="headerlink" title="409. 最长回文串"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-palindrome/">409. 最长回文串</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; int:</span>        count = defaultdict(<span class="built_in">int</span>)        <span class="keyword">for</span> a <span class="keyword">in</span> s:            count[a] += <span class="number">1</span>        length = <span class="number">0</span>        odd = []        <span class="keyword">for</span> value <span class="keyword">in</span> count.values():            <span class="keyword">if</span> value % <span class="number">2</span> == <span class="number">0</span>:                length += value            <span class="keyword">else</span>:                odd.append(value)        <span class="keyword">if</span> odd != []:            length += <span class="built_in">sum</span>(odd) - <span class="built_in">len</span>(odd) + <span class="number">1</span>        <span class="keyword">return</span> length</span><br></pre></td></tr></table></figure>


<h2 id="-46"><a href="#-46" class="headerlink" title=""></a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="-47"><a href="#-47" class="headerlink" title=""></a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="-48"><a href="#-48" class="headerlink" title=""></a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="-49"><a href="#-49" class="headerlink" title=""></a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="-50"><a href="#-50" class="headerlink" title=""></a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="-51"><a href="#-51" class="headerlink" title=""></a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="数组与矩阵"><a href="#数组与矩阵" class="headerlink" title="数组与矩阵"></a>数组与矩阵</h1><h2 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/move-zeroes/">283. 移动零</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 双指针class Solution:    def moveZeroes(self, nums: List[int]) -&gt; None:        n = len(nums)        left = right = 0        while right &lt; n:            if nums[right] != 0:                nums[left], nums[right] = nums[right], nums[left]                left += 1            right += 1# remove appendclass Solution:    def moveZeroes(self, nums: List[int]) -&gt; None:        &quot;&quot;&quot;        Do not return anything, modify nums in-place instead.        &quot;&quot;&quot;        cnt = 0        while 0 in nums:            nums.remove(0)            cnt += 1        for _ in range(cnt):            nums.append(0)</span></span><br></pre></td></tr></table></figure>

<h2 id="566-重塑矩阵"><a href="#566-重塑矩阵" class="headerlink" title="566. 重塑矩阵"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reshape-the-matrix/">566. 重塑矩阵</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切片class Solution(object):    def matrixReshape(self, nums, r, c):        M, N = len(nums), len(nums[0])        if M * N != r * c:            return nums        res = [[0] * c for _ in range(r)]        row, col = 0, 0        for i in range(M):            for j in range(N):                if col == c:                    row += 1                    col = 0                res[row][col] = nums[i][j]                col += 1        return res</span></span><br></pre></td></tr></table></figure>

<h2 id="485-最大连续-1-的个数"><a href="#485-最大连续-1-的个数" class="headerlink" title="485. 最大连续 1 的个数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/max-consecutive-ones/">485. 最大连续 1 的个数</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 转换为 str 非常耗时...class Solution:    def findMaxConsecutiveOnes(self, nums: List[int]) -&gt; int:          strNums = [str(x) for x in nums]        res = 0        for i in range(len(&quot;&quot;.join(strNums).split(&#x27;0&#x27;))):            res = max(res, len(&quot;&quot;.join(strNums).split(&#x27;0&#x27;)[i]))        return res    # 一次遍历class Solution:    def findMaxConsecutiveOnes(self, nums: List[int]) -&gt; int:        count = 0        maxCount = 0        for num in nums:            if num == 1:                count += 1            else:                maxCount = max(maxCount, count)                count = 0        maxCount = max(maxCount, count) # [0, 1, 1, 1]        return maxCount</span></span><br></pre></td></tr></table></figure>

<h2 id="240-搜索二维矩阵-II"><a href="#240-搜索二维矩阵-II" class="headerlink" title="240. 搜索二维矩阵 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/">240. 搜索二维矩阵 II</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">searchMatrix</span>(<span class="params">self, matrix: List[List[<span class="built_in">int</span>]], target: <span class="built_in">int</span></span>) -&gt; bool:</span>        row = <span class="built_in">len</span>(matrix)        col = <span class="built_in">len</span>(matrix[<span class="number">0</span>])        <span class="comment"># 双指针         i = 0        j = col - 1                while matrix[i][j] != target:            if matrix[i][j] &lt; target:                i += 1            else:                j -= 1            if i &gt;= row or j &lt; 0:                return False        return True</span></span><br></pre></td></tr></table></figure>

<h2 id="378-有序矩阵中第-K-小的元素"><a href="#378-有序矩阵中第-K-小的元素" class="headerlink" title="378. 有序矩阵中第 K 小的元素"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/">378. 有序矩阵中第 K 小的元素</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span>(<span class="params">self, matrix: List[List[<span class="built_in">int</span>]], k: <span class="built_in">int</span></span>) -&gt; int:</span>        one_matrix = reduce(operator.add, matrix)        <span class="keyword">return</span> <span class="built_in">sorted</span>(one_matrix)[k - <span class="number">1</span>]<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span>(<span class="params">self, matrix: List[List[<span class="built_in">int</span>]], k: <span class="built_in">int</span></span>) -&gt; int:</span>        rec = <span class="built_in">sorted</span>(<span class="built_in">sum</span>(matrix, []))        <span class="keyword">return</span> rec[k - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h2 id="645-错误的集合"><a href="#645-错误的集合" class="headerlink" title="645. 错误的集合"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/set-mismatch/">645. 错误的集合</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">findErrorNums</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span>        ln, total = <span class="built_in">len</span>(nums), <span class="built_in">sum</span>(<span class="built_in">set</span>(nums))        <span class="keyword">return</span> [<span class="built_in">sum</span>(nums) - total, (<span class="number">1</span> + ln) * ln // <span class="number">2</span> - total] <span class="comment"># 1+2+...+n = n*(n+1)/2</span></span><br></pre></td></tr></table></figure>

<h2 id="287-寻找重复数-1"><a href="#287-寻找重复数-1" class="headerlink" title="287. 寻找重复数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-the-duplicate-number/">287. 寻找重复数</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (<span class="built_in">sum</span>(nums) - <span class="built_in">sum</span>(<span class="built_in">set</span>(nums))) // (<span class="built_in">len</span>(nums) - <span class="built_in">len</span>(<span class="built_in">set</span>(nums)))<span class="comment"># 快慢指针def findDuplicate(self, nums: List[int]) -&gt; int:        slow, fast = 0, 0        while True:            slow, fast = nums[slow], nums[nums[fast]]            if slow == fast:                break        slow = 0        while slow != fast:            slow, fast = nums[slow], nums[fast]        return slow</span></span><br></pre></td></tr></table></figure>

<h2 id="667-优美的排列-II"><a href="#667-优美的排列-II" class="headerlink" title="667. 优美的排列 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/beautiful-arrangement-ii/">667. 优美的排列 II</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="697-数组的度"><a href="#697-数组的度" class="headerlink" title="697. 数组的度"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/degree-of-an-array/">697. 数组的度</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="766-托普利茨矩阵"><a href="#766-托普利茨矩阵" class="headerlink" title="766. 托普利茨矩阵"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/toeplitz-matrix/">766. 托普利茨矩阵</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="565-数组嵌套"><a href="#565-数组嵌套" class="headerlink" title="565. 数组嵌套"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/array-nesting/">565. 数组嵌套</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="769-最多能完成排序的块"><a href="#769-最多能完成排序的块" class="headerlink" title="769. 最多能完成排序的块"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/max-chunks-to-make-sorted/">769. 最多能完成排序的块</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="785-判断二分图"><a href="#785-判断二分图" class="headerlink" title="785. 判断二分图"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/is-graph-bipartite/">785. 判断二分图</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="207-课程表"><a href="#207-课程表" class="headerlink" title="207. 课程表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/course-schedule/">207. 课程表</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="210-课程表-II"><a href="#210-课程表-II" class="headerlink" title="210. 课程表 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/course-schedule-ii/">210. 课程表 II</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="684-冗余连接"><a href="#684-冗余连接" class="headerlink" title="684. 冗余连接"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/redundant-connection/">684. 冗余连接</a></h2><p>并查集</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><h2 id="定义总结"><a href="#定义总结" class="headerlink" title="定义总结"></a>定义总结</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 0s 代表 0000...# 1s 代表 1111...# ^ 异或：不同为 1# &amp; 与：同 1 为 1# | 或：有 1 为 1# ～ 非# &lt;&lt; 左移# &gt;&gt; 右移x ^ 0s = x      x &amp; 0s = 0      x | 0s = xx ^ 1s = ~x # 翻转 1100 -&gt; 0011   x &amp; 1s = x      x | 1s = 1sx ^ x = 0   # 去重 1^1^2 = 2    x &amp; x = x       x | x = x# 利用 x &amp; 0s = 0 和 x &amp; 1s = x 的特点，可以实现掩码操作01011011 &amp; 00111100   --------00011000# 利用 x | 0s = x 和 x | 1s = 1s 的特点，可以实现设值操作01011011 |00111100--------01111111# n&amp;(n-1) 去除 n 的位级表示中最低的那一位 101011011 &amp;01011010--------01011010# n&amp;(-n) 得到 n 的位级表示中最低的那一位 1，-n=~n+110110100 &amp;01001100--------00000100# 1. num ^ num = 0# 2. num ^ (-num) 可以使num中第一个1为1, 并使其他位全为0# 不需要额外变量交换a = a ^ bb = a ^ ba = a ^ b</span></span><br></pre></td></tr></table></figure>



<h2 id="461-汉明距离"><a href="#461-汉明距离" class="headerlink" title="461. 汉明距离"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/hamming-distance/">461. 汉明距离</a></h2><p>两个整数之间的 汉明距离 指的是这两个数字对应二进制位不同的位置的数目。</p>
<p>给你两个整数 x 和 y，计算并返回它们之间的汉明距离。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">示例 1：输入：x = 1, y = 4输出：2解释：1   (0 0 0 1)4   (0 1 0 0)       ↑   ↑上面的箭头指出了对应二进制位不同的位置。</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 异或class Solution:    def hammingDistance(self, x, y):        return bin(x ^ y).count(&#x27;1&#x27;)# 右移class Solution:    def hammingDistance(self, x: int, y: int) -&gt; int:        n = x ^ y        count = 0        while n:            if (n &amp; 1): count += 1 # 最低位 1            n &gt;&gt;= 1        return count# Brian Kernighan 算法 class Solution:    def hammingDistance(self, x: int, y: int) -&gt; int:        c = x ^ y        count = 0        while c:            count += 1            c = c &amp; (c-1) #  c = c &amp; (c-1) 可以将 c 的最低一位的 1 变为 0        return count</span></span><br></pre></td></tr></table></figure>

<h2 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136. 只出现一次的数字"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/single-number/">136. 只出现一次的数字</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span>        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):            nums[<span class="number">0</span>] ^= nums[i]        <span class="keyword">return</span> nums[<span class="number">0</span>]<span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span>        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span>:            <span class="keyword">return</span> nums[<span class="number">0</span>]        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums) ):            nums[<span class="number">0</span>]^=nums[i]        <span class="keyword">return</span> nums[<span class="number">0</span>]<span class="comment"># reduce() 函数会对参数序列中元素进行累class Solution:    def singleNumber(self, nums: List[int]) -&gt; int:        return reduce(lambda x, y: x ^ y, nums)</span></span><br></pre></td></tr></table></figure>

<h2 id="268-丢失的数字"><a href="#268-丢失的数字" class="headerlink" title="268. 丢失的数字"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/missing-number/">268. 丢失的数字</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">missingNumber</span>(<span class="params">self, nums</span>):</span>        missing = <span class="built_in">len</span>(nums)        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums): <span class="comment"># 不用zip            missing ^= i ^ num        return missing    # 列表求和class Solution:    def missingNumber(self, nums: List[int]) -&gt; int:        return sum(list(range(len(nums) + 1))) - sum(nums)</span></span><br></pre></td></tr></table></figure>

<h2 id="260-只出现一次的数字-III"><a href="#260-只出现一次的数字-III" class="headerlink" title="260. 只出现一次的数字 III"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/single-number-iii/">260. 只出现一次的数字 III</a></h2><p>两个不相等的元素在位级表示上必定会有一位存在不同。</p>
<p>将数组的所有元素异或得到的结果为不存在重复的两个元素异或的结果。</p>
<p>diff &amp;= -diff 得到出 diff 最右侧不为 0 的位，也就是不存在重复的两个元素在位级表示上最右侧不同的那一位，利用这一位就可以将两个元素区分开来。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span>        eor = <span class="number">0</span>        <span class="keyword">for</span> num <span class="keyword">in</span> nums:            eor ^= num        rightOne = eor &amp; - eor <span class="comment"># 恰好有两个元素只出现一次        res = 0        for num in nums:            if num &amp; rightOne != 0:                res ^= num        return [res, res ^ eor]</span></span><br></pre></td></tr></table></figure>

<h2 id="190-颠倒二进制位"><a href="#190-颠倒二进制位" class="headerlink" title="190. 颠倒二进制位"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-bits/">190. 颠倒二进制位</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">reverseBits</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span>        result = <span class="number">0</span>        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):            result = (result &lt;&lt; <span class="number">1</span>) + (n &amp; <span class="number">1</span>)            n &gt;&gt;= <span class="number">1</span>        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h2 id="231-2-的幂"><a href="#231-2-的幂" class="headerlink" title="231. 2 的幂"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/power-of-two/">231. 2 的幂</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">isPowerOfTwo</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; bool:</span>        <span class="comment"># 二进制表示只有一个 1 存在。        return n &gt; 0 and n &amp; (n - 1) == 0    	return bin(n).count(&quot;1&quot;) == 1 and n &gt;= 0 # 数二进制 1 的个数</span></span><br></pre></td></tr></table></figure>

<h2 id="342-4的幂"><a href="#342-4的幂" class="headerlink" title="342. 4的幂"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/power-of-four/">342. 4的幂</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span>    <span class="function"><span class="keyword">def</span> <span class="title">isPowerOfFour</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; bool:</span>        <span class="keyword">return</span> n &gt; <span class="number">0</span> <span class="keyword">and</span> (n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span> <span class="keyword">and</span> (n &amp; <span class="number">0xaaaaaaaa</span>) == <span class="number">0</span> <span class="comment"># 这种数在二进制表示中有且只有一个奇数位为 1</span></span><br></pre></td></tr></table></figure>

<h2 id="693-交替位二进制数"><a href="#693-交替位二进制数" class="headerlink" title="693. 交替位二进制数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-number-with-alternating-bits/">693. 交替位二进制数</a></h2><p>如果原始数字符合条件的话，比如101，那么运算后的temp应该是全1的，比如111，这样的话，+1后就变成了1000,&amp;运算后就为0，证明确实是111. 对于其他位数的二进制数也一样的，temp &amp; (temp + 1) == 0 目的就是判断temp 是不是全1二进制数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span>    <span class="function"><span class="keyword">def</span> <span class="title">hasAlternatingBits</span>(<span class="params">self, n</span>):</span>        <span class="string">&quot;&quot;&quot;        :type n: int        :rtype: bool        &quot;&quot;&quot;</span>        temp = n ^ (n &gt;&gt; <span class="number">1</span>)        <span class="keyword">return</span> temp &amp; (temp + <span class="number">1</span>) == <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="476-数字的补数"><a href="#476-数字的补数" class="headerlink" title="476. 数字的补数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-complement/">476. 数字的补数</a></h2><p>给你一个 正 整数 num ，输出它的补数。补数是对该数的二进制表示取反。</p>
<p>输入：num = 5<br>输出：2<br>解释：5 的二进制表示为 101（没有前导零位），其补数为 010。所以你需要输出 2 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findComplement</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> num^(<span class="number">2</span>**(<span class="built_in">len</span>(<span class="built_in">bin</span>(num))-<span class="number">2</span>)-<span class="number">1</span>) <span class="comment"># 2**(n-1)-1</span></span><br></pre></td></tr></table></figure>

<h2 id="371-两整数之和"><a href="#371-两整数之和" class="headerlink" title="371. 两整数之和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sum-of-two-integers/">371. 两整数之和</a></h2><p>a ^ b 表示没有考虑进位的情况下两数的和，(a &amp; b) &lt;&lt; 1 就是进位。</p>
<p>递归会终止的原因是 (a &amp; b) &lt;&lt; 1 最右边会多一个 0，那么继续递归，进位最右边的 0 会慢慢增多，最后进位会变为 0，递归终止。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="318-最大单词长度乘积"><a href="#318-最大单词长度乘积" class="headerlink" title="318. 最大单词长度乘积"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-product-of-word-lengths/">318. 最大单词长度乘积</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="338-比特位计数"><a href="#338-比特位计数" class="headerlink" title="338. 比特位计数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/counting-bits/">338. 比特位计数</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countBits</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>):</span><br><span class="line">            res.append(<span class="built_in">bin</span>(i).count(<span class="string">&quot;1&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Ashin Wang"
      src="https://tva1.sinaimg.cn/large/006y8mN6ly1g74lvmm1zhj3074074q4r.jpg">
  <p class="site-author-name" itemprop="name">Ashin Wang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">67</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">86</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/AshinWang" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;AshinWang" rel="noopener" target="_blank"><i class="fa fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ashin Wang</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="//cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script>
<script src="/js/algolia-search.js"></script>














  

  


</body>
</html>
