<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.ashin.wang","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"algolia":{"appID":"S30ZCDT4BR","apiKey":"6988e9b27ba9570d9ed85020ebf48b01","indexName":"blog","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="笔试第一道编程题输入一个字符串，判断这个字符串是不是全对称字符串 零钱兑换问题第二道编程题有很多种不同的木材，每种木材可以选取任意次，让你选择最少的木材数量，使得木材长度和刚好等于k 123456789class Solution:    def coinChange(self, coins: List[int], amount: int) -&gt; int:                dp">
<meta property="og:type" content="article">
<meta property="og:title" content="sxf">
<meta property="og:url" content="https://www.ashin.wang/sxf/index.html">
<meta property="og:site_name" content="Ashin Wang&#39;s Blog">
<meta property="og:description" content="笔试第一道编程题输入一个字符串，判断这个字符串是不是全对称字符串 零钱兑换问题第二道编程题有很多种不同的木材，每种木材可以选取任意次，让你选择最少的木材数量，使得木材长度和刚好等于k 123456789class Solution:    def coinChange(self, coins: List[int], amount: int) -&gt; int:                dp">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/008i3skNgy1gvylmn99ugj313e0i4whn.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/008i3skNgy1gvibrcdoldg60u00gwhdx02.gif">
<meta property="og:image" content="https://assets.leetcode-cn.com/solution-static/225/225_fig1.gif">
<meta property="og:image" content="https://assets.leetcode-cn.com/solution-static/155/155_fig1.gif">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/008i3skNgy1gv890goha7j60qu0gc41z02.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/0082zybpgy1gbtoun6ic4g30m908r0wt.gif">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/0082zybpgy1gbtprp6xjfg30mj06wdsb.gif">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/0082zybpgy1gbtqzysve0g30mj0e1n6v.gif">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/0082zybpgy1gbuvgp28bag307p09kgsu.gif">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/0082zybpgy1gbuvg1qamsg30mj0e1k05.gif">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/008i3skNgy1gv87ene21hj611h0u0whh02.jpg">
<meta property="og:image" content="https://pic.leetcode-cn.com/d13bd82917a8eba049efa261bebd3beb74b9e7c1adf39ce51bf1c9dd60d49f57-Quicksort-example.gif">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/0082zybpgy1gbuvm1jkf0g30mj070jyl.gif">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/0082zybpgy1gbuvq87o7sg30f70a4hdt.gif">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/0082zybpgy1gbuvq613sbg30go0goabf.gif">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/0082zybpgy1gbuvuexgkng30s40fhjww.gif">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/0082zybpgy1gbuvy7lbqqj308n03nt8q.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/0082zybpgy1gbuw3cz71lg30s40fywic.gif">
<meta property="og:image" content="https://camo.githubusercontent.com/df92e0deefb619759aa435aca99720cf4113a5ba705eb09f1636f91c89d3eb1e/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f66623438396663302d626562392d313165622d383566362d3666616337376330633962332e706e67">
<meta property="og:image" content="https://camo.githubusercontent.com/245cf8925daac2792d36f0f07066826a955175fe6e09030ae0a7ae17d1be9954/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f30613365626239302d626562612d313165622d383566362d3666616337376330633962332e706e67">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-a9976ebe153157fde548aaa7b8d73e28_1440w.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/008i3skNgy1gulaxem2zdj609u06uaa302.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/008i3skNgy1gulay0ol1fj60ac0780sv02.jpg">
<meta property="og:image" content="https://www.runoob.com/wp-content/uploads/2017/03/1489720930-5882-BO4qO.png">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/008i3skNgy1gvmyj6ow8qj60ns1cgwgy02.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/008i3skNgy1gvzg1squ51j30ea0ciaaf.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/008i3skNgy1gvzg2ind8cj30fy09pwet.jpg">
<meta property="og:image" content="https://ask.qcloudimg.com/http-save/yehe-2662963/s1o8cgc0y3.jpeg?imageView2/2/w/1620">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/008i3skNgy1gvzhmqgas4j30kq08r74r.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/008i3skNgy1gvzhy87hfoj30k008ygm3.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/008i3skNgy1gvzhyk2tdlj30k009vjrx.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/008i3skNgy1gvznzgedadj30t80ghn1s.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/008i3skNgy1gvzn5tz9klj30cc08k3yt.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/008i3skNgy1gvzn6eo4f0j30l40ihq3k.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/008i3skNgy1gvzmov50uuj305l06lglh.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/5.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/3.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/4.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/5.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/6.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/7.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/8.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/9.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/10.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/11.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/12.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/13.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/14.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/15.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/16.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/17.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/18.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/19.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/20.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/21.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/22.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/23.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/24.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/25.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/26.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/27.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/28.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/29.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/30.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/31.png">
<meta property="article:published_time" content="1977-12-31T16:00:00.000Z">
<meta property="article:modified_time" content="2021-11-01T11:27:24.355Z">
<meta property="article:author" content="Ashin Wang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tva1.sinaimg.cn/large/008i3skNgy1gvylmn99ugj313e0i4whn.jpg">

<link rel="canonical" href="https://www.ashin.wang/sxf/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>sxf | Ashin Wang's Blog</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?1d0c251d59c914b8a773d2fd3302cc56";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Ashin Wang's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

      
    </div>
  </div>

</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.ashin.wang/sxf/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://tva1.sinaimg.cn/large/006y8mN6ly1g74lvmm1zhj3074074q4r.jpg">
      <meta itemprop="name" content="Ashin Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ashin Wang's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          sxf
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：1978-01-01 00:00:00" itemprop="dateCreated datePublished" datetime="1978-01-01T00:00:00+08:00">1978-01-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="笔试"><a href="#笔试" class="headerlink" title="笔试"></a>笔试</h1><h2 id="第一道编程题"><a href="#第一道编程题" class="headerlink" title="第一道编程题"></a>第一道编程题</h2><p>输入一个字符串，判断这个字符串是不是全对称字符串</p>
<h2 id="零钱兑换问题"><a href="#零钱兑换问题" class="headerlink" title="零钱兑换问题"></a>零钱兑换问题</h2><p>第二道编程题有很多种不同的木材，每种木材可以选取任意次，让你选择最少的木材数量，使得木材长度和刚好等于k</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">coinChange</span>(<span class="params">self, coins: List[<span class="built_in">int</span>], amount: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        </span><br><span class="line">        dp = [<span class="number">0</span>] + [<span class="number">10001</span>] * (amount)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(coin, amount + <span class="number">1</span>):</span><br><span class="line">                dp[j] = <span class="built_in">min</span>(dp[j], dp[j - coin] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>] <span class="keyword">if</span> dp[-<span class="number">1</span>] != <span class="number">10001</span> <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="旅行家问题"><a href="#旅行家问题" class="headerlink" title="旅行家问题"></a>旅行家问题</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mincostTickets</span>(<span class="params">self, days: List[<span class="built_in">int</span>], costs: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (days[-<span class="number">1</span>] + <span class="number">1</span>)</span><br><span class="line">        <span class="comment">#dp = [0 for _ in range(days[-1] + 1)]  # dp数组，每个元素代表到当前天数最少钱数，为下标方便对应，多加一个 0 位置</span></span><br><span class="line">        days_idx = <span class="number">0</span>  <span class="comment"># 设定一个days指标，标记应该处理 days 数组中哪一个元素</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(dp)):</span><br><span class="line">            <span class="keyword">if</span> i != days[days_idx]:  <span class="comment"># 若当前天数不是待处理天数，则其花费费用和前一天相同</span></span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 若 i 走到了待处理天数，则从三种方式中选一个最小的</span></span><br><span class="line">                dp[i] = <span class="built_in">min</span>(dp[<span class="built_in">max</span>(<span class="number">0</span>, i - <span class="number">1</span>)] + costs[<span class="number">0</span>],</span><br><span class="line">                            dp[<span class="built_in">max</span>(<span class="number">0</span>, i - <span class="number">7</span>)] + costs[<span class="number">1</span>],</span><br><span class="line">                            dp[<span class="built_in">max</span>(<span class="number">0</span>, i - <span class="number">30</span>)] + costs[<span class="number">2</span>])</span><br><span class="line">                days_idx += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]  <span class="comment"># 返回最后一天对应的费用即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 二分法 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mincostTickets</span>(<span class="params">self, days: List[<span class="built_in">int</span>], costs: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        ans = [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i, day <span class="keyword">in</span> <span class="built_in">enumerate</span>(days):</span><br><span class="line">            ans.append(<span class="built_in">min</span>(</span><br><span class="line">                ans[-<span class="number">1</span>] + costs[<span class="number">0</span>],</span><br><span class="line">                ans[bisect.bisect(days, day - <span class="number">7</span>)] + costs[<span class="number">1</span>],</span><br><span class="line">                ans[bisect.bisect(days, day - <span class="number">30</span>)] + costs[<span class="number">2</span>]</span><br><span class="line">            ))</span><br><span class="line">        <span class="keyword">return</span> ans[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h2 id="厨师做饭-LRU"><a href="#厨师做饭-LRU" class="headerlink" title="厨师做饭(LRU)"></a>厨师做饭(LRU)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSatisfaction</span>(<span class="params">self, satisfaction: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        satisfaction.sort(reverse=<span class="literal">True</span>)</span><br><span class="line">        presum, ans = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> si <span class="keyword">in</span> satisfaction:</span><br><span class="line">            <span class="keyword">if</span> presum + si &gt; <span class="number">0</span>:</span><br><span class="line">                presum += si</span><br><span class="line">                ans += presum</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h2 id="小机器人方案数"><a href="#小机器人方案数" class="headerlink" title="小机器人方案数"></a>小机器人方案数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">n, m, k, p = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">eps = <span class="number">1e9</span> + <span class="number">7</span></span><br><span class="line"></span><br><span class="line">last = [<span class="number">0</span>] * (n + <span class="number">2</span>)</span><br><span class="line">curr = [<span class="number">0</span>] * (n + <span class="number">2</span>)</span><br><span class="line">last[m] = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, k+<span class="number">1</span>):</span><br><span class="line">    l = <span class="built_in">max</span>(<span class="number">1</span>, m-i)</span><br><span class="line">    r = <span class="built_in">min</span>(n, m+i)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(l, r+<span class="number">1</span>):</span><br><span class="line">        curr[j] = (last[j-<span class="number">1</span>] + last[j + <span class="number">1</span>]) % eps</span><br><span class="line">    last[:] = curr[:]</span><br><span class="line">print(<span class="built_in">int</span>(curr[p]))</span><br></pre></td></tr></table></figure>

<h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-linked-list/">206. 反转链表</a></h2><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvylmn99ugj313e0i4whn.jpg" style="zoom:67%;" />

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        prev, curr = <span class="literal">None</span>, head</span><br><span class="line">        <span class="keyword">while</span> curr <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            nxt = curr.<span class="built_in">next</span> <span class="comment"># 移动指针</span></span><br><span class="line">            curr.<span class="built_in">next</span> = prev</span><br><span class="line">            prev = curr</span><br><span class="line">            curr = nxt <span class="comment"># 移动指针</span></span><br><span class="line">            <span class="keyword">return</span> prev</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">    <span class="comment"># 单个节点</span></span><br><span class="line">    <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    </span><br><span class="line">    p = self.reverseList(head.<span class="built_in">next</span>)</span><br><span class="line">    head.<span class="built_in">next</span>.<span class="built_in">next</span> = head</span><br><span class="line">    head.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure>



<h2 id="列表分子"><a href="#列表分子" class="headerlink" title="列表分子"></a>列表分子</h2><p>k1 对应的 value 相同的放在同一列表里面</p>
<p>手撕代码：列表分子，k1 对应的value相同的放在同一列表里面 </p>
<p> 输入：[{‘k1’:1, ‘k2’:1},  {‘k1 ‘:2, ‘k2’:2}, {‘k1’:1, ‘k2’:2}] </p>
<p> 输出：[{‘k1’:1, ‘k2’:1}, {‘k1’, 1, ‘k2’: 2}], [{k1’: 2,’k2’: 2}] </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">arr = [&#123;<span class="string">&#x27;k1&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;k2&#x27;</span>:<span class="number">1</span>&#125;,  &#123;<span class="string">&#x27;k1&#x27;</span>:<span class="number">2</span>, <span class="string">&#x27;k2&#x27;</span>:<span class="number">2</span>&#125;, &#123;<span class="string">&#x27;k1&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;k2&#x27;</span>:<span class="number">2</span>&#125;, &#123;<span class="string">&#x27;k1&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;k2&#x27;</span>:<span class="number">2</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># [&#123;&#x27;k1&#x27;:1, &#x27;k2&#x27;:1&#125;, &#123;&#x27;k1&#x27;, 1, &#x27;k2&#x27;: 2&#125;], [&#123;k1&#x27;: 2,&#x27;k2&#x27;: 2&#125;] </span></span><br><span class="line"></span><br><span class="line">res = []</span><br><span class="line">cnt = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)):</span><br><span class="line">    tmp = []</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, <span class="built_in">len</span>(arr)):</span><br><span class="line">        <span class="keyword">if</span> arr[j][<span class="string">&#x27;k1&#x27;</span>] == arr[i][<span class="string">&#x27;k1&#x27;</span>]:</span><br><span class="line">            tmp.append(arr[i])</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> cnt &lt;= <span class="built_in">len</span>(arr):</span><br><span class="line">        res.append(tmp)</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure>



<h2 id="撕代码，快速-排序"><a href="#撕代码，快速-排序" class="headerlink" title="撕代码，快速[排序]"></a>撕代码，快速[排序]</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span>(<span class="params">nums</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quick</span>(<span class="params">left, right</span>):</span></span><br><span class="line">        <span class="keyword">if</span> left &gt;= right:</span><br><span class="line">            <span class="keyword">return</span> nums</span><br><span class="line">        pivot = left <span class="comment"># 最左边</span></span><br><span class="line">        i = left</span><br><span class="line">        j = right</span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> nums[j] &gt; nums[pivot]:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> nums[i] &lt;= nums[pivot]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">        nums[pivot], nums[j] = nums[j], nums[pivot]</span><br><span class="line">        <span class="comment"># 分区</span></span><br><span class="line">        quick(left, j - <span class="number">1</span>)</span><br><span class="line">        quick(j + <span class="number">1</span>, right)</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    <span class="keyword">return</span> quick(<span class="number">0</span>, n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>



<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入<a href="">排序</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertion_sort</span>(<span class="params">nums</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        <span class="keyword">while</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i - <span class="number">1</span>] &gt; nums[i]:</span><br><span class="line">            nums[i - <span class="number">1</span>], nums[i] = nums[i], nums[i - <span class="number">1</span>] <span class="comment"># 交换</span></span><br><span class="line">            i -= <span class="number">1</span> <span class="comment"># 倒回去比较</span></span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>



<h2 id="回文数"><a href="#回文数" class="headerlink" title="回文数"></a>回文数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validPalindrome</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment">#lambda [arg1 [,arg2,.....argn]]:expression, x[start:end:span] 当 span&lt;0 时，列表翻转</span></span><br><span class="line">        isPalindrome = <span class="keyword">lambda</span> x : x == x[::-<span class="number">1</span>] <span class="comment"># isPalindrome 返回值就是 bool</span></span><br><span class="line"></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            <span class="keyword">if</span> s[left] == s[right]:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> isPalindrome(s[left + <span class="number">1</span> : right + <span class="number">1</span>]) <span class="keyword">or</span> isPalindrome(s[left: right])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> <span class="comment"># True</span></span><br></pre></td></tr></table></figure>



<h2 id="前中后序遍历"><a href="#前中后序遍历" class="headerlink" title="前中后序遍历"></a>前中后序遍历</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 递归1：二叉树遍历最易理解和实现版本</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="comment"># 前序递归</span></span><br><span class="line">        <span class="keyword">return</span> [root.val] + self.preorderTraversal(root.left) + self.preorderTraversal(root.right)</span><br><span class="line">        <span class="comment"># 中序递归 </span></span><br><span class="line">        <span class="keyword">return</span> self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)</span><br><span class="line">        <span class="comment"># 后序递归</span></span><br><span class="line">        <span class="keyword">return</span> self.postorderTraversal(root.left) + self.postorderTraversal(root.right) + [root.val]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归2：通用模板，可以适应不同的题目，添加参数、增加返回条件、修改进入递归条件、自定义返回值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">cur</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur:</span><br><span class="line">                <span class="keyword">return</span>      </span><br><span class="line">            <span class="comment"># 前序递归</span></span><br><span class="line">            res.append(cur.val)</span><br><span class="line">            dfs(cur.left)</span><br></pre></td></tr></table></figure>



<h2 id="类，读数据和写数据"><a href="#类，读数据和写数据" class="headerlink" title="类，读数据和写数据"></a>类，读数据和写数据</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadWrite</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, path</span>):</span></span><br><span class="line">        self.path = path</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read_data</span>(<span class="params">self</span>):</span></span><br><span class="line">        f = <span class="built_in">open</span>(self.path, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">        print(f)</span><br><span class="line">        <span class="keyword">return</span> f    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write_data</span>(<span class="params">self, content</span>):</span></span><br><span class="line">        file = self.read_data()</span><br><span class="line">        file.write(content)</span><br><span class="line">        file.close()</span><br><span class="line"></span><br><span class="line">rw = ReadWrite(<span class="string">&#x27;/Users/ashin/Desktop/test.py&#x27;</span>).write_data(content = <span class="string">&#x27;hello word&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h2 id="数组转换成链表再去重"><a href="#数组转换成链表再去重" class="headerlink" title="数组转换成链表再去重"></a>数组转换成<a href="">链表</a>再去重</h2><p>根据数组构造<a href="">链表</a>，然后删除其中重复数字（构造删除同时输出<a href="">链表</a>节点的值和地址）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val=<span class="literal">None</span>, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">list2link</span>(<span class="params">list_</span>):</span></span><br><span class="line">    head = Node(list_[<span class="number">0</span>])</span><br><span class="line">    p = head</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(list_)):</span><br><span class="line">        p.<span class="built_in">next</span> = Node(list_[i])</span><br><span class="line">        p = p.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span>(<span class="params">self, head</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    pre, cur = head, head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> cur:</span><br><span class="line">        <span class="keyword">if</span> pre.val == cur.val:</span><br><span class="line">            pre.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pre = cur</span><br><span class="line">        cur = cur.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicateNodes</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:<span class="comment">#如果head里本来就没东西，那就返回head本身</span></span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">        r = head <span class="comment">#r是head的代言人，负责迭代和更新，head负责原地不动</span></span><br><span class="line">        record = &#123;head.val&#125; <span class="comment">#record负责储存看见过的值。现在已经储存了第一个值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> r <span class="keyword">and</span> r.<span class="built_in">next</span>: <span class="comment">#只要r接下来还有东西，就看看下一个东西是不是已经在record当中 </span></span><br><span class="line">            <span class="comment">#这里判断时要同时符合这两个条件，因为如果r已经是None了，判断r.next会报错，所以每次得先判断r</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> r.<span class="built_in">next</span>.val <span class="keyword">not</span> <span class="keyword">in</span> record: <span class="comment">#如果下一环的值没被储存过,不用对head作任何修改</span></span><br><span class="line">                record.add(r.<span class="built_in">next</span>.val) <span class="comment">#在record中添加这个值</span></span><br><span class="line">                r = r.<span class="built_in">next</span> <span class="comment">#并且让r进入下一环</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span>: <span class="comment">#如果下一环的值已经见过了</span></span><br><span class="line">                r.<span class="built_in">next</span> = r.<span class="built_in">next</span>.<span class="built_in">next</span> <span class="comment">#直接让r的下一环变为下下环，即把r.next这一环删了</span></span><br><span class="line">                <span class="comment">#这里不用再写&quot;r=r.next&quot;让r进入下一环，原因是r.next已经更改了，要重新进入loop判断现在的r.next(即原来的r.next.next)是否已经遇见过</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>



<h2 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line">        size = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="comment"># 特殊处理</span></span><br><span class="line">        <span class="keyword">if</span> size == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        <span class="comment"># 创建动态规划dynamic programing表</span></span><br><span class="line">        dp = [[<span class="literal">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size)]</span><br><span class="line">        <span class="comment"># 初始长度为1，这样万一不存在回文，就返回第一个值（初始条件设置的时候一定要考虑输出）</span></span><br><span class="line">        max_len = <span class="number">1</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, size):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(j):</span><br><span class="line">                <span class="comment"># 边界条件：</span></span><br><span class="line">                <span class="comment"># 只要头尾相等（s[i]==s[j]）就能返回True</span></span><br><span class="line">                <span class="keyword">if</span> j - i &lt;= <span class="number">2</span>:</span><br><span class="line">                    <span class="keyword">if</span> s[i] == s[j]:</span><br><span class="line">                        dp[i][j] = <span class="literal">True</span></span><br><span class="line">                        cur_len = j - i + <span class="number">1</span></span><br><span class="line">                <span class="comment"># 状态转移方程 </span></span><br><span class="line">                <span class="comment"># 当前dp[i][j]状态：头尾相等（s[i]==s[j]）</span></span><br><span class="line">                <span class="comment"># 过去dp[i][j]状态：去掉头尾之后还是一个回文（dp[i+1][j-1] is True）</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> s[i] == s[j] <span class="keyword">and</span> dp[i + <span class="number">1</span>][j - <span class="number">1</span>]:</span><br><span class="line">                        dp[i][j] = <span class="literal">True</span></span><br><span class="line">                        cur_len = j - i + <span class="number">1</span></span><br><span class="line">                <span class="comment"># 出现回文更新输出</span></span><br><span class="line">                <span class="keyword">if</span> dp[i][j]:</span><br><span class="line">                    <span class="keyword">if</span> cur_len &gt; max_len:</span><br><span class="line">                        max_len = cur_len</span><br><span class="line">                        start = i</span><br><span class="line">        <span class="keyword">return</span> s[start: start + max_len]</span><br></pre></td></tr></table></figure>



<h2 id="不用＋号实现a-b"><a href="#不用＋号实现a-b" class="headerlink" title="不用＋号实现a+b"></a>不用＋号实现a+b</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 位运算</span></span><br><span class="line"><span class="comment"># ^ 异或 操作实现无进位加法</span></span><br><span class="line"><span class="comment"># &amp; 与 实现进位</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getSum</span>(<span class="params">self, a: <span class="built_in">int</span>, b: <span class="built_in">int</span></span>) -&gt; int:</span> <span class="comment">#a=-2, b=3</span></span><br><span class="line">        a &amp;= <span class="number">0xFFFFFFFF</span> <span class="comment"># a=1110 --&gt; 14</span></span><br><span class="line">        b &amp;= <span class="number">0xFFFFFFFF</span> <span class="comment"># b=3</span></span><br><span class="line">        <span class="keyword">while</span> b:</span><br><span class="line">            carry = a &amp; b</span><br><span class="line">            a ^= b </span><br><span class="line">            b = ((carry) &lt;&lt; <span class="number">1</span>) &amp; <span class="number">0xFFFFFFFF</span> <span class="comment"># 左移动</span></span><br><span class="line">            <span class="comment"># print((a, b))</span></span><br><span class="line">        <span class="keyword">return</span> a <span class="keyword">if</span> a &lt; <span class="number">0x80000000</span> <span class="keyword">else</span> ~(a^<span class="number">0xFFFFFFFF</span>)</span><br></pre></td></tr></table></figure>



<h2 id="链表结构，链表排序"><a href="#链表结构，链表排序" class="headerlink" title="链表结构，链表排序"></a><a href="">链表</a>结构，<a href="">链表</a><a href="">排序</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 归并排序</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>: <span class="keyword">return</span> head</span><br><span class="line">        left_end = self.find_mid(head)</span><br><span class="line">        mid = left_end.<span class="built_in">next</span> </span><br><span class="line">        left_end.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        left, right = self.sortList(head), self.sortList(mid)</span><br><span class="line">        <span class="keyword">return</span> self.merged(left, right)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 快慢指针查找链表中点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_mid</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>: <span class="keyword">return</span> head</span><br><span class="line">        slow,fast = head, head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> fast.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            slow=slow.<span class="built_in">next</span></span><br><span class="line">            fast=fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 合并有序链表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merged</span>(<span class="params">self, left, right</span>):</span></span><br><span class="line">        res = ListNode()</span><br><span class="line">        h = res</span><br><span class="line">        <span class="keyword">while</span> left <span class="keyword">and</span> right:</span><br><span class="line">            <span class="keyword">if</span> left.val &lt; right.val: </span><br><span class="line">                h.<span class="built_in">next</span>, left = left, left.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                h.<span class="built_in">next</span>, right = right, right.<span class="built_in">next</span></span><br><span class="line">            h = h.<span class="built_in">next</span></span><br><span class="line">        h.<span class="built_in">next</span> = left <span class="keyword">if</span> left <span class="keyword">else</span> right</span><br><span class="line">        <span class="keyword">return</span> res.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>



<h2 id="写一个装饰器"><a href="#写一个装饰器" class="headerlink" title="写一个装饰器"></a>写一个装饰器</h2><p>装饰器（Decorators） 是 Python 的一个重要部分。简单地说：他们是修改其他函数的功能的函数。是一种函数的函数，因为装饰器传入的参数就是一个函数，然后通过实现各种功能来对这个函数的功能进行增强。</p>
<p>简洁明了</p>
<p><strong>@wraps</strong>接受一个函数来进行装饰，并加入了复制函数名称、注释文档、参数列表等等的功能。这可以让我们在装饰器里面访问在装饰之前的函数的属性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator_name</span>(<span class="params">f</span>):</span></span><br><span class="line"><span class="meta">    @wraps(<span class="params">f</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorated</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> can_run:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Function will not run&quot;</span></span><br><span class="line">        <span class="keyword">return</span> f(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> decorated</span><br><span class="line"> </span><br><span class="line"><span class="meta">@decorator_name</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">    <span class="keyword">return</span>(<span class="string">&quot;Function is running&quot;</span>)</span><br><span class="line"> </span><br><span class="line">can_run = <span class="literal">True</span></span><br><span class="line">print(func())</span><br><span class="line"><span class="comment"># Output: Function is running</span></span><br><span class="line"> </span><br><span class="line">can_run = <span class="literal">False</span></span><br><span class="line">print(func())</span><br><span class="line"><span class="comment"># Output: Function will not run</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Flask</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">requires_auth</span>(<span class="params">f</span>):</span></span><br><span class="line"><span class="meta">    @wraps(<span class="params">f</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorated</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        auth = request.authorization</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> auth <span class="keyword">or</span> <span class="keyword">not</span> check_auth(auth.username, auth.password):</span><br><span class="line">            authenticate()</span><br><span class="line">        <span class="keyword">return</span> f(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> decorated</span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logit</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">with_logging</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        print(func.__name__ + <span class="string">&quot; was called&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> with_logging</span><br><span class="line"> </span><br><span class="line"><span class="meta">@logit</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addition_func</span>(<span class="params">x</span>):</span></span><br><span class="line">   <span class="string">&quot;&quot;&quot;Do some math.&quot;&quot;&quot;</span></span><br><span class="line">   <span class="keyword">return</span> x + x</span><br><span class="line"> </span><br><span class="line">result = addition_func(<span class="number">4</span>)</span><br><span class="line"><span class="comment"># Output: addition_func was called</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 装饰器类</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">logit</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, logfile=<span class="string">&#x27;out.log&#x27;</span></span>):</span></span><br><span class="line">        self.logfile = logfile</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, func</span>):</span></span><br><span class="line"><span class="meta">        @wraps(<span class="params">func</span>)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapped_function</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">            log_string = func.__name__ + <span class="string">&quot; was called&quot;</span></span><br><span class="line">            print(log_string)</span><br><span class="line">            <span class="comment"># 打开logfile并写入</span></span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(self.logfile, <span class="string">&#x27;a&#x27;</span>) <span class="keyword">as</span> opened_file:</span><br><span class="line">                <span class="comment"># 现在将日志打到指定的文件</span></span><br><span class="line">                opened_file.write(log_string + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            <span class="comment"># 现在，发送一个通知</span></span><br><span class="line">            self.notify()</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> wrapped_function</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">notify</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># logit只打日志，不做别的</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment"># 时间</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func_timer</span>(<span class="params">function</span>):</span></span><br><span class="line"><span class="meta">  @wraps(<span class="params">function</span>)</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">function_timer</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">    start = time.time()</span><br><span class="line">    result = function(*args, **kwargs)</span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;函数%s总运行时间: %s s&quot;</span> %(function.__name__, <span class="built_in">str</span>(end - start)))</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  <span class="keyword">return</span> function_timer</span><br></pre></td></tr></table></figure>



<h2 id="146-LRU-缓存机制"><a href="#146-LRU-缓存机制" class="headerlink" title="146. LRU 缓存机制"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lru-cache/">146. LRU 缓存机制</a></h2><p>LRU：least recently used，最近最少使用算法。其实就是按使用时间倒排序，然后从尾部删除元素。它的使用场景是：在有限的空间中存储对象时，当空间满时，会按一定的原则删除原有的对象，常用的原则（算法）有 LRU，FIFO，LFU 等。在计算机的 Cache 硬件，以及主存到虚拟内存的页面置换，还有Redis缓存系统中都用到了该算法。我在一次面试和一个笔试时，也遇到过这个问题。</p>
<p> LRU的算法是比较简单的，当对key进行访问时（一般有查询，更新，增加，在get()和set()两个方法中实现即可）时，将该key放到队列的最前端（或最后端）就行了，这样就实现了对key按其<strong>最后一次访问的时间</strong>降序（或升序）排列，当向空间中增加新对象时，如果空间满了，删除队尾（或队首）的对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">哈希表 + 双向链表</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">哈希表用于满足题目时间复杂度O(1)的要求，双向链表用于存储顺序</span></span><br><span class="line"><span class="string">哈希表键值类型：&lt;Integer, ListNode&gt;，哈希表的键用于存储输入的 key，哈希表的值用于存储双向链表的节点</span></span><br><span class="line"><span class="string">双向链表的节点中除了 value 外还需要包含 key，因为在删除最久未使用的数据时，需要通过链表来定位 hashmap 中应当删除的键值对</span></span><br><span class="line"><span class="string">一些操作：双向链表中，在后面的节点表示被最近访问</span></span><br><span class="line"><span class="string">i. 新加入的节点放在链表末尾，addNodeToLast(node)</span></span><br><span class="line"><span class="string">ii. 若容量达到上限，去除最久未使用的数据，removeNode(head.next)</span></span><br><span class="line"><span class="string">iii. 若数据新被访问过，比如被get了或被put了新值，把该节点挪到链表末尾，moveNodeToLast(node)</span></span><br><span class="line"><span class="string">为了操作的方便，在双向链表头和尾分别定义一个head和tail节点。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, key = <span class="number">0</span>, val = <span class="number">0</span></span>):</span></span><br><span class="line">        self.key = key</span><br><span class="line">        self.val = val</span><br><span class="line">        self.prev = <span class="literal">None</span></span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, capacity: <span class="built_in">int</span></span>):</span></span><br><span class="line">        self.capacity = capacity</span><br><span class="line">        self.hashmap = &#123;&#125;</span><br><span class="line">        self.head = ListNode()</span><br><span class="line">        self.tail = ListNode()</span><br><span class="line">        self.head.<span class="built_in">next</span> = self.tail</span><br><span class="line">        self.tail.prev = self.head</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove_node</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        node.prev.<span class="built_in">next</span> = node.<span class="built_in">next</span></span><br><span class="line">        node.<span class="built_in">next</span>.prev = node.prev</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_node_to_last</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        self.tail.prev.<span class="built_in">next</span> = node</span><br><span class="line">        node.prev = self.tail.prev</span><br><span class="line">        node.<span class="built_in">next</span> = self.tail</span><br><span class="line">        self.tail.prev = node</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move_node_to_last</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        self.remove_node(node)</span><br><span class="line">        self.add_node_to_last(node)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.hashmap:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        node = self.hashmap[key]</span><br><span class="line">        self.move_node_to_last(node)</span><br><span class="line">        <span class="keyword">return</span> node.val</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self, key: <span class="built_in">int</span>, value: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.hashmap:</span><br><span class="line">            node = self.hashmap[key]</span><br><span class="line">            node.val = value</span><br><span class="line">            self.move_node_to_last(node)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.hashmap) == self.capacity:</span><br><span class="line">            <span class="keyword">del</span> self.hashmap[self.head.<span class="built_in">next</span>.key]</span><br><span class="line">            self.remove_node(self.head.<span class="built_in">next</span>)</span><br><span class="line">        node = ListNode(key, value)</span><br><span class="line">        self.hashmap[key] = node</span><br><span class="line">        self.add_node_to_last(node)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="comment"># OrderedDict       </span></span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, capacity</span>):</span></span><br><span class="line">        self.capacity = capacity</span><br><span class="line">        self.cache = collections.OrderedDict()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            value = self.cache.pop(key)</span><br><span class="line">            self.cache[key] = value</span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set</span>(<span class="params">self, key, value</span>):</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.cache.pop(key)</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(self.cache) &gt;= self.capacity:</span><br><span class="line">                self.cache.popitem(last=<span class="literal">False</span>)</span><br><span class="line">        self.cache[key] = value</span><br></pre></td></tr></table></figure>



<h2 id="子序列算法"><a href="#子序列算法" class="headerlink" title="子序列算法"></a>子序列<a href="">算法</a></h2><p>给一个字符串，求有多少种切分方式使得每一个子序列代表的数字都在给定范围内</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"><span class="comment">## [1297. 子串的最大出现次数](https://leetcode-cn.com/problems/maximum-number-of-occurrences-of-a-substring/)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入：s = “aababcaab”, maxLetters = 2, minSize = 3, maxSize = 4<br>输出：2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#96;&#96;&#96;python</span><br><span class="line">class Solution:</span><br><span class="line">    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -&gt; int:</span><br><span class="line">        n &#x3D; len(s)</span><br><span class="line">        dic &#x3D; defaultdict(int)</span><br><span class="line"></span><br><span class="line">        for i in range(n - minSize + 1):   #防止越界</span><br><span class="line">            cur &#x3D; s[i: i + minSize]       #maxSize没有用 长的都行  短的更可以</span><br><span class="line">            if len(set(cur)) &lt;&#x3D; maxLetters:</span><br><span class="line">                dic[cur] +&#x3D; 1</span><br><span class="line">                </span><br><span class="line">        if len(dic) &#x3D;&#x3D; 0:</span><br><span class="line">            return 0</span><br><span class="line">        return max(dic.values())</span><br></pre></td></tr></table></figure>



<h2 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232. 用栈实现队列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/implement-queue-using-stacks/">232. 用栈实现队列</a></h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvibrcdoldg60u00gwhdx02.gif" alt="232.gif"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为了满足队列的 FIFO 的特性，我们需要用到两个栈，用它们其中一个来反转元素的入队顺序，用另一个来存储元素的最终顺序。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.stack1 = []</span><br><span class="line">        self.stack2 = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.stack1.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.stack2:</span><br><span class="line">            <span class="keyword">while</span> self.stack1:</span><br><span class="line">                self.stack2.append(self.stack1.pop())</span><br><span class="line">        <span class="keyword">return</span> self.stack2.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.stack2:</span><br><span class="line">            <span class="keyword">while</span> self.stack1:</span><br><span class="line">                self.stack2.append(self.stack1.pop())</span><br><span class="line">        <span class="keyword">return</span> self.stack2[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">empty</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self.stack1 <span class="keyword">and</span> <span class="keyword">not</span> self.stack2</span><br></pre></td></tr></table></figure>

<h2 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225. 用队列实现栈"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/implement-stack-using-queues/">225. 用队列实现栈</a></h2><p><img src="https://assets.leetcode-cn.com/solution-static/225/225_fig1.gif" alt="fig1"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.queue1 = collections.deque()</span><br><span class="line">        self.queue2 = collections.deque()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Push element x onto stack.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.queue2.append(x)</span><br><span class="line">        <span class="keyword">while</span> self.queue1:</span><br><span class="line">            self.queue2.append(self.queue1.popleft())</span><br><span class="line">        self.queue1, self.queue2 = self.queue2, self.queue1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Removes the element on top of the stack and returns that element.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.queue1.popleft()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Get the top element.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.queue1[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">empty</span>(<span class="params">self</span>) -&gt; bool:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Returns whether the stack is empty.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self.queue1</span><br></pre></td></tr></table></figure>

<h2 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155. 最小栈"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/min-stack/">155. 最小栈</a></h2><p><img src="https://assets.leetcode-cn.com/solution-static/155/155_fig1.gif" alt="fig1"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.stack = []</span><br><span class="line">        self.min_stack = [math.inf]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.stack.append(x)</span><br><span class="line">        self.min_stack.append(<span class="built_in">min</span>(x, self.min_stack[-<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.stack.pop()</span><br><span class="line">        self.min_stack.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.stack[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMin</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.min_stack[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h2 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40. 组合总和 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum-ii/">40. 组合总和 II</a></h2><p>数组中等于指定数的数字组合 不会 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">为了避免产生重复解，本题candidates务必排序</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">backtrack步骤如下：</span></span><br><span class="line"><span class="string">剪枝：如果当前tmp数组的和cur已经大于目标target，没必要枚举了，直接return</span></span><br><span class="line"><span class="string">如果当前tmp数组的和cur正好和目标target相等，找到一个组合，加到结果res中去，并return</span></span><br><span class="line"><span class="string">for循环遍历从index开始的数，选一个数进入下一层递归。</span></span><br><span class="line"><span class="string">如果从index开始的数有连续出现的重复数字，跳过该数字continue，因为这会产生重复解</span></span><br><span class="line"><span class="string">因为数不可以重复选择，所以在进入下一层递归时，i要加1，从i之后的数中选择接下来的数</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum2</span>(<span class="params">self, candidates: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">tmp, cur, index</span>):</span></span><br><span class="line">            <span class="keyword">if</span> cur &gt; target:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> cur == target:</span><br><span class="line">                res.append(tmp)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index, n):</span><br><span class="line">                <span class="keyword">if</span> i &gt; index <span class="keyword">and</span> candidates[i] == candidates[i - <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                backtrack(tmp + [candidates[i]], cur + candidates[i], i + <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        res = []</span><br><span class="line">        n = <span class="built_in">len</span>(candidates)</span><br><span class="line">        candidates.sort()</span><br><span class="line">        backtrack([], <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>



<h2 id="字符串中所有字符出现字数"><a href="#字符串中所有字符出现字数" class="headerlink" title="字符串中所有字符出现字数"></a>字符串中所有字符出现字数</h2><p>不允许用字典 count 时间换空间一次迭代(<a href="">leetcode</a>做过 用字典哭死) 不会</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">areOccurrencesEqual</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        freq = Counter(s)   <span class="comment"># 每个字符的实际频数</span></span><br><span class="line">        occ = <span class="built_in">len</span>(s) // <span class="built_in">len</span>(freq)    <span class="comment"># 每个字符的理论频数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">all</span>(v == occ <span class="keyword">for</span> v <span class="keyword">in</span> freq.values())</span><br></pre></td></tr></table></figure>



<h2 id="运行时间装饰器"><a href="#运行时间装饰器" class="headerlink" title="运行时间装饰器"></a>运行时间装饰器</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 常规</span></span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>():</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>):</span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">            res -= <span class="number">1</span></span><br><span class="line">            </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    start = time() <span class="comment"># 获取函数开始的时间戳</span></span><br><span class="line">    run()</span><br><span class="line">    end = time() <span class="comment"># 获取函数结束的时间戳</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 装饰器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">time_costing</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">core</span>():</span></span><br><span class="line">        start = time()</span><br><span class="line">        func()</span><br><span class="line">        end = time</span><br><span class="line">        print(<span class="string">&#x27;time costing:&#x27;</span>, end - start)</span><br><span class="line">    <span class="keyword">return</span> core</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">@time_costing</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>():</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>):</span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">            res -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">	run()</span><br></pre></td></tr></table></figure>



<h2 id="跳台阶"><a href="#跳台阶" class="headerlink" title="跳台阶"></a>跳台阶</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, n + <span class="number">1</span>):</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i-<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>





<h2 id="最大回文字符串"><a href="#最大回文字符串" class="headerlink" title="最大回文字符串"></a>最大回文字符串</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line">        </span><br><span class="line">        size = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="comment"># 特殊处理</span></span><br><span class="line">        <span class="keyword">if</span> size == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        <span class="comment"># 创建动态规划dynamic programing表</span></span><br><span class="line">        dp = [[<span class="literal">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size)]</span><br><span class="line">        <span class="comment"># 初始长度为1，这样万一不存在回文，就返回第一个值（初始条件设置的时候一定要考虑输出）</span></span><br><span class="line">        max_len = <span class="number">1</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, size):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(j):</span><br><span class="line">                <span class="comment"># 边界条件：</span></span><br><span class="line">                <span class="comment"># 只要头尾相等（s[i]==s[j]）就能返回True</span></span><br><span class="line">                <span class="keyword">if</span> j - i &lt;= <span class="number">2</span>:</span><br><span class="line">                    <span class="keyword">if</span> s[i] == s[j]:</span><br><span class="line">                        dp[i][j] = <span class="literal">True</span></span><br><span class="line">                        cur_len = j - i + <span class="number">1</span></span><br><span class="line">                <span class="comment"># 状态转移方程 </span></span><br><span class="line">                <span class="comment"># 当前dp[i][j]状态：头尾相等（s[i]==s[j]）</span></span><br><span class="line">                <span class="comment"># 过去dp[i][j]状态：去掉头尾之后还是一个回文（dp[i+1][j-1] is True）</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> s[i] == s[j] <span class="keyword">and</span> dp[i + <span class="number">1</span>][j - <span class="number">1</span>]:</span><br><span class="line">                        dp[i][j] = <span class="literal">True</span></span><br><span class="line">                        cur_len = j - i + <span class="number">1</span></span><br><span class="line">                <span class="comment"># 出现回文更新输出</span></span><br><span class="line">                <span class="keyword">if</span> dp[i][j]:</span><br><span class="line">                    <span class="keyword">if</span> cur_len &gt; max_len:</span><br><span class="line">                        max_len = cur_len</span><br><span class="line">                        start = i</span><br><span class="line">        <span class="keyword">return</span> s[start: start + max_len]</span><br></pre></td></tr></table></figure>



<h2 id="力扣21-合并两个有序-链表"><a href="#力扣21-合并两个有序-链表" class="headerlink" title="力扣21 - 合并两个有序[链表"></a>力扣21 - 合并两个有序[链表</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 递归</span></span><br><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="comment"># 终止条件，直到两个链表都空</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l1: <span class="keyword">return</span> l2  </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l2: <span class="keyword">return</span> l1</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 递归调用</span></span><br><span class="line">        <span class="keyword">if</span> l1.val &lt;= l2.val:  </span><br><span class="line">            l1.<span class="built_in">next</span> = self.mergeTwoLists(l1.<span class="built_in">next</span>, l2)</span><br><span class="line">            <span class="keyword">return</span> l1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l2.<span class="built_in">next</span> = self.mergeTwoLists(l1, l2.<span class="built_in">next</span>)</span><br><span class="line">            <span class="keyword">return</span> l2</span><br></pre></td></tr></table></figure>



<h2 id="单链表逆转下标由m到n之间的节点"><a href="#单链表逆转下标由m到n之间的节点" class="headerlink" title="单链表逆转下标由m到n之间的节点"></a>单<a href="">链表</a>逆转下标由m到n之间的节点</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## [排序]()（将列表[排序]()）</span></span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="链表相关（合并，排序，反转）"><a href="#链表相关（合并，排序，反转）" class="headerlink" title="链表相关（合并，排序，反转）"></a><a href="">链表</a>相关（合并，<a href="">排序</a>，反转）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 合并</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="comment"># 终止条件，直到两个链表都空</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l1: <span class="keyword">return</span> l2  </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l2: <span class="keyword">return</span> l1</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 递归调用</span></span><br><span class="line">        <span class="keyword">if</span> l1.val &lt;= l2.val:  </span><br><span class="line">            l1.<span class="built_in">next</span> = self.mergeTwoLists(l1.<span class="built_in">next</span>, l2)</span><br><span class="line">            <span class="keyword">return</span> l1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l2.<span class="built_in">next</span> = self.mergeTwoLists(l1, l2.<span class="built_in">next</span>)</span><br><span class="line">            <span class="keyword">return</span> l2</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 反转</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        pre, cur = <span class="literal">None</span>, head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            nxt = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = nxt</span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure>



<h2 id="99乘法表"><a href="#99乘法表" class="headerlink" title="99乘法表"></a>99乘法表</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, i + <span class="number">1</span>):</span><br><span class="line">        print(<span class="string">&#x27;&#123;&#125; x &#123;&#125; = &#123;&#125;\t&#x27;</span>.<span class="built_in">format</span>(j, i, i*j), end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    print()</span><br></pre></td></tr></table></figure>



<h2 id="414-第三大的数"><a href="#414-第三大的数" class="headerlink" title="414. 第三大的数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/third-maximum-number/">414. 第三大的数</a></h2><p>（要考虑数组中元素重复的情况）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">thirdMax</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        heap = []</span><br><span class="line">        k = <span class="number">3</span></span><br><span class="line">        nums = <span class="built_in">set</span>(nums)</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            heapq.heappush(heap, num)</span><br><span class="line">            <span class="comment"># 一旦堆中的元素大于3，就把最小的（堆顶元素）抛出。始终保持一个 3 以内的堆</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(heap) &gt; k:</span><br><span class="line">                heapq.heappop(heap)</span><br><span class="line">	</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(heap) == k:</span><br><span class="line">            <span class="comment"># 堆顶元素在数组最前面</span></span><br><span class="line">            <span class="keyword">return</span> heap[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 不存在第三大元素，就返回最大的元素</span></span><br><span class="line">            <span class="keyword">return</span> heap[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>



<h2 id="判断回文字符串"><a href="#判断回文字符串" class="headerlink" title="判断回文字符串"></a>判断回文字符串</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validPalindrome</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment">#lambda [arg1 [,arg2,.....argn]]:expression, x[start:end:span] 当 span&lt;0 时，列表翻转</span></span><br><span class="line">        isPalindrome = <span class="keyword">lambda</span> x : x == x[::-<span class="number">1</span>] <span class="comment"># isPalindrome 返回值就是 bool</span></span><br><span class="line"></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            <span class="keyword">if</span> s[left] == s[right]:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> isPalindrome(s[left + <span class="number">1</span> : right + <span class="number">1</span>]) <span class="keyword">or</span> isPalindrome(s[left: right])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> <span class="comment"># True</span></span><br></pre></td></tr></table></figure>



<h2 id="兔子繁殖"><a href="#兔子繁殖" class="headerlink" title="兔子繁殖"></a>兔子繁殖</h2><p>兔子都是母兔子，每一只兔子每一年可以生4只或5只，求繁殖n年后一共有几只兔子</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 消消乐</span></span><br><span class="line"></span><br><span class="line">遇到连续<span class="number">3</span>个一样的字符就消去，输出给定字符串消消乐后的最终结果</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"><span class="comment"># 双指针</span></span><br><span class="line"></span><br><span class="line">s = <span class="string">&#x27;AAABBBDDDCCCCFCDDDCC&#x27;</span></span><br><span class="line">left = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> left &lt; <span class="built_in">len</span>(s):</span><br><span class="line">    right = left</span><br><span class="line">    <span class="keyword">while</span> right &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[right] == s[left]:</span><br><span class="line">        right += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> right &gt; <span class="number">2</span>:</span><br><span class="line">        s = s[:left] + s[right:]</span><br><span class="line">        left -= <span class="number">2</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        left = right</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure>



<h2 id="无重复三位数"><a href="#无重复三位数" class="headerlink" title="无重复三位数"></a>无重复三位数</h2><p>有1、2、3、4个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> arr:</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> arr:</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> arr:</span><br><span class="line">            <span class="keyword">if</span> i != j <span class="keyword">and</span> i != k <span class="keyword">and</span> j != k:</span><br><span class="line">                res.append(i*<span class="number">100</span> + j*<span class="number">10</span> +k*<span class="number">1</span>)</span><br><span class="line">print(res)               </span><br></pre></td></tr></table></figure>



<h2 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143. 最长公共子序列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-common-subsequence/">1143. 最长公共子序列</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonSubsequence</span>(<span class="params">self, text1, text2</span>):</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(text1), <span class="built_in">len</span>(text2)</span><br><span class="line">        dp = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> text1[i - <span class="number">1</span>] == text2[j - <span class="number">1</span>]:</span><br><span class="line">                    <span class="comment"># 可以定义 dp[i][j] 表示 text1[0:i-1] 和 text2[0:j-1] 的最长公共子序列</span></span><br><span class="line">                    <span class="comment"># 两个子字符串的最后一位相等，所以最长公共子序列又增加了 1</span></span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 那么此时的状态 dp[i][j] 应该是 dp[i - 1][j] 和 dp[i][j - 1] 的最大值</span></span><br><span class="line">                    <span class="comment"># 举个例子，比如对于 ace 和 bc 而言，他们的最长公共子序列的长度等于 ① ace 和 b 的最长公共子序列长度0 与</span></span><br><span class="line">                    <span class="comment"># ② ac 和 bc 的最长公共子序列长度1 的最大值，即 1。</span></span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>



<h2 id="Flask-加法"><a href="#Flask-加法" class="headerlink" title="Flask 加法"></a>Flask 加法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, render_template, request, url_for</span><br><span class="line"><span class="keyword">from</span> add <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"> </span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">home</span>():</span></span><br><span class="line">  <span class="keyword">return</span> render_template(<span class="string">&#x27;index.html&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>():</span></span><br><span class="line">    a = request.form[<span class="string">&#x27;adder1&#x27;</span>]</span><br><span class="line">    b = request.form[<span class="string">&#x27;adder2&#x27;</span>]</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">      a = <span class="built_in">float</span>(a)</span><br><span class="line">      b = <span class="built_in">float</span>(b)</span><br><span class="line">      result = sum_function(a, b)</span><br><span class="line">      <span class="keyword">return</span> render_template(<span class="string">&#x27;index.html&#x27;</span>, result=result, var1=a, var2=b)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">      <span class="keyword">return</span> render_template(<span class="string">&#x27;index.html&#x27;</span>, message=<span class="string">&#x27;inputs false!!!&#x27;</span>, var1=a, var2=b)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">  app.run(port=<span class="number">8080</span>)</span><br></pre></td></tr></table></figure>

<h2 id="字符串匹配问题（kmp算法）我主动写了一下代码"><a href="#字符串匹配问题（kmp算法）我主动写了一下代码" class="headerlink" title="字符串匹配问题（kmp算法）我主动写了一下代码"></a>字符串匹配问题（kmp<a href="">算法</a>）我主动写了一下代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切片</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span>(<span class="params">self, haystack: <span class="built_in">str</span>, needle: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> needle <span class="keyword">not</span> <span class="keyword">in</span> haystack:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> needle == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(haystack)):</span><br><span class="line">                <span class="keyword">if</span> haystack[i:<span class="built_in">len</span>(needle)+i] == needle[:]:</span><br><span class="line">                    <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line"><span class="comment"># KMP</span></span><br><span class="line"></span><br><span class="line">// 方法二</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span>(<span class="params">self, haystack: <span class="built_in">str</span>, needle: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        a=<span class="built_in">len</span>(needle)</span><br><span class="line">        b=<span class="built_in">len</span>(haystack)</span><br><span class="line">        <span class="keyword">if</span> a==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        i=j=<span class="number">0</span></span><br><span class="line">        <span class="built_in">next</span>=self.getnext(a,needle)</span><br><span class="line">        <span class="keyword">while</span>(i&lt;b <span class="keyword">and</span> j&lt;a):</span><br><span class="line">            <span class="keyword">if</span> j==-<span class="number">1</span> <span class="keyword">or</span> needle[j]==haystack[i]:</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">                j+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j=<span class="built_in">next</span>[j]</span><br><span class="line">        <span class="keyword">if</span> j==a:</span><br><span class="line">            <span class="keyword">return</span> i-j</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getnext</span>(<span class="params">self,a,needle</span>):</span></span><br><span class="line">        <span class="built_in">next</span>=[<span class="string">&#x27;&#x27;</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(a)]</span><br><span class="line">        j,k=<span class="number">0</span>,-<span class="number">1</span></span><br><span class="line">        <span class="built_in">next</span>[<span class="number">0</span>]=k</span><br><span class="line">        <span class="keyword">while</span>(j&lt;a-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> k==-<span class="number">1</span> <span class="keyword">or</span> needle[k]==needle[j]:</span><br><span class="line">                k+=<span class="number">1</span></span><br><span class="line">                j+=<span class="number">1</span></span><br><span class="line">                <span class="built_in">next</span>[j]=k</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                k=<span class="built_in">next</span>[k]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">next</span></span><br></pre></td></tr></table></figure>



<h2 id="找出不同文件中相同的IP地址"><a href="#找出不同文件中相同的IP地址" class="headerlink" title="找出不同文件中相同的IP地址"></a>找出不同文件中相同的IP地址</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">grep  -Ff  my.txt  ip.txt</span><br><span class="line">diff my.txt ip.txt</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;testt&quot;</span>,<span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f1:</span><br><span class="line">    list1 = f1.readlines() <span class="comment"># 行读取</span></span><br><span class="line">    print(list1)</span><br><span class="line"><span class="comment">#list1 = set(list1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;test2&quot;</span>,<span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f2:</span><br><span class="line">    list2 = f2.readlines()</span><br><span class="line">    print(list2)</span><br><span class="line"><span class="comment">#list2 = set(list2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2个文件的list进行比较，有重复取出</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_same_ip_for_two_file</span>(<span class="params">file1,file2</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(file1,<span class="built_in">list</span>) <span class="keyword">and</span> <span class="built_in">isinstance</span>(file2,<span class="built_in">list</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> file2:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> file1:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="排序算法比较"><a href="#排序算法比较" class="headerlink" title="排序算法比较"></a>排序算法比较</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gv890goha7j60qu0gc41z02.jpg" alt="849589-20171015233043168-1867817869.png"></p>
<ul>
<li>稳定性：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，A1=A2，且A1在A2之前，而在排序后的序列中，A1仍在A2之前，则称这种排序算法是稳定的；否则称为不稳定的。</li>
<li>排序方式</li>
</ul>
<h2 id="1-冒泡排序-BubbleSort"><a href="#1-冒泡排序-BubbleSort" class="headerlink" title="1 冒泡排序_BubbleSort"></a>1 冒泡排序_BubbleSort</h2><blockquote>
<p>冒泡排序是通过多次的比较和交换逐渐将序列排序的方法。大（小）的元素会经过交换<code>浮出</code>水面。</p>
</blockquote>
<ul>
<li>每次对相邻的两个数进行比较，若符合大小关系，则交换两个数；</li>
<li>每经过一次排序，将最大（小）的数放在后（前）面，剩下的未排序.length - 1。</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gbtoun6ic4g30m908r0wt.gif" alt="img"></p>
<p>算法分析：稳定排序，内排序，时间复杂度：O(n^2)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span>(<span class="params">nums</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 进行多次循环</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n - c):</span><br><span class="line">            <span class="keyword">if</span> nums[i - <span class="number">1</span>] &gt; nums[i]:</span><br><span class="line">                nums[i - <span class="number">1</span>], nums[i] = nums[i], nums[i - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>



<h2 id="2-选择排序-SelectionSort"><a href="#2-选择排序-SelectionSort" class="headerlink" title="2 选择排序_SelectionSort"></a>2 选择排序_SelectionSort</h2><blockquote>
<p>选择排序，每次遍历序列，找到最小（大）的数，并放在序列的最前面，对剩下未排序的序列重复上述操作。</p>
</blockquote>
<ul>
<li>每次初始设定为未序列的元素第一个为最小（大）元素，首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置；</li>
<li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾；</li>
<li>重复第二步，直到所有元素均排序完毕。</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gbtprp6xjfg30mj06wdsb.gif" alt="img"></p>
<p><strong>稳定性：</strong>用数组实现的选择排序是不稳定的，用链表实现的选择排序是稳定的；时间复杂度：O(n^2) ，<code>n</code>是数组长度</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selection_sort</span>(<span class="params">nums</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="comment"># n2</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, n):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; nums[j]:</span><br><span class="line">                nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>



<h2 id="3-插入排序-InsertionSort"><a href="#3-插入排序-InsertionSort" class="headerlink" title="3 插入排序_InsertionSort"></a>3 插入排序_InsertionSort</h2><blockquote>
<p>插入排序的基本操作就是从未排序的序列中取出一个数，插入到已经排序序列的正确位置中。</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gbtqzysve0g30mj0e1n6v.gif" alt="img"></p>
<p><strong>算法分析：</strong>稳定排序，内排序，时间复杂度：O(n^2)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertion_sort</span>(<span class="params">nums</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        <span class="keyword">while</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i - <span class="number">1</span>] &gt; nums[i]:</span><br><span class="line">            nums[i - <span class="number">1</span>], nums[i] = nums[i], nums[i - <span class="number">1</span>] <span class="comment"># 交换</span></span><br><span class="line">            i -= <span class="number">1</span> <span class="comment"># 倒回去比较</span></span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>





<h2 id="4-希尔排序-ShellSort"><a href="#4-希尔排序-ShellSort" class="headerlink" title="4 希尔排序_ShellSort"></a>4 希尔排序_ShellSort</h2><blockquote>
<p>先将整个序列划分为若若干子序列，分别进行插入排序排序。开始增量（Gap）= int(arr.length/2)，经过一次排序后，增量 int(arr.length/2)/2，一直到增量 = 1。</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gbuvgp28bag307p09kgsu.gif" alt="img"></p>
<p>算法分析：非稳定排序，内排序，O(nlogn)；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_sort</span>(<span class="params">nums</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    gap = n // <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> gap:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(gap, n):</span><br><span class="line">            <span class="keyword">while</span> i - gap &gt;= <span class="number">0</span> <span class="keyword">and</span> nums[i - gap] &gt; nums[i]:</span><br><span class="line">                nums[i - gap], nums[i] = nums[i], nums[i - gap] <span class="comment"># 交换 Gap 增量</span></span><br><span class="line">                i -= gap</span><br><span class="line">        gap //= <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>



<h2 id="5-归并排序-MergeSort"><a href="#5-归并排序-MergeSort" class="headerlink" title="5 归并排序_MergeSort"></a>5 归并排序_MergeSort</h2><blockquote>
<p>归并排序的思想：将序列分解成最小有序子序列，再逐个将有序的子序列进行合并，得到有序的子序列段，最终得到一个完整的有序序列。</p>
<p>分治：先将数组分成子序列，让子序列有序，再将子序列间有序，合并成有序数组。</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gbuvg1qamsg30mj0e1k05.gif" alt="img"></p>
<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gv87ene21hj611h0u0whh02.jpg" style="zoom:50%;" />

<p>算法分析：稳定排序，外排序（占用额外内存），时间复杂度O(nlogn)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span>(<span class="params">nums</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    mid = <span class="built_in">len</span>(nums) // <span class="number">2</span></span><br><span class="line">    <span class="comment"># 分</span></span><br><span class="line">    left = merge_sort(nums[:mid])</span><br><span class="line">    right = merge_sort(nums[mid:])</span><br><span class="line">    <span class="comment"># 合并</span></span><br><span class="line">    <span class="keyword">return</span> merge(left, right)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">left, right</span>):</span></span><br><span class="line">    res = []</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(left) <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(right):</span><br><span class="line">        <span class="keyword">if</span> left[i] &lt;= right[j]:</span><br><span class="line">            res.append(left[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res.append(right[j])</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">    res += left[i:]</span><br><span class="line">    res += right[j:]</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>





<h2 id="6-快速排序-QuickSort"><a href="#6-快速排序-QuickSort" class="headerlink" title="6 快速排序_QuickSort"></a>6 快速排序_QuickSort</h2><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p>
<ul>
<li>步骤1：从数列中挑出一个元素，称为 “基准”（pivot ）；</li>
<li>步骤2：重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后；该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>
<li>步骤3：递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>
</ul>
<p><img src="https://pic.leetcode-cn.com/d13bd82917a8eba049efa261bebd3beb74b9e7c1adf39ce51bf1c9dd60d49f57-Quicksort-example.gif"></p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gbuvm1jkf0g30mj070jyl.gif" alt="img"></p>
<p>算法分析：不稳定排序，内排序，时间复杂度度O(nlogn)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span>(<span class="params">nums</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quick</span>(<span class="params">left, right</span>):</span></span><br><span class="line">        <span class="keyword">if</span> left &gt;= right:</span><br><span class="line">            <span class="keyword">return</span> nums</span><br><span class="line">        pivot = left</span><br><span class="line">        i = left</span><br><span class="line">        j = right</span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> nums[j] &gt; nums[pivot]:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> nums[i] &lt;= nums[pivot]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">        nums[pivot], nums[j] = nums[j], nums[pivot]</span><br><span class="line">        quick(left, j - <span class="number">1</span>)</span><br><span class="line">        quick(j + <span class="number">1</span>, right)</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> quick(<span class="number">0</span>, n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>





<h2 id="7-堆排序-HeapSort"><a href="#7-堆排序-HeapSort" class="headerlink" title="7 堆排序_HeapSort"></a>7 堆排序_HeapSort</h2><p>堆排序是利用堆这个数据结构设计的排序算法。</p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gbuvq87o7sg30f70a4hdt.gif" alt="img"></p>
<p>建堆，从底向上调整堆，使得父亲节点比孩子节点值大，构成大顶堆；<br>交换堆顶和最后一个元素，重新调整堆。</p>
<p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gbuvq613sbg30go0goabf.gif" alt="img"></p>
<p>算法分析：不稳定排序，内排序，时间复杂度为O(nlogn)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span>(<span class="params">nums</span>):</span></span><br><span class="line">    <span class="comment"># 调整堆</span></span><br><span class="line">    <span class="comment"># 迭代写法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">adjust_heap</span>(<span class="params">nums, startpos, endpos</span>):</span></span><br><span class="line">        newitem = nums[startpos]</span><br><span class="line">        pos = startpos</span><br><span class="line">        childpos = pos * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> childpos &lt; endpos:</span><br><span class="line">            rightpos = childpos + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> rightpos &lt; endpos <span class="keyword">and</span> nums[rightpos] &gt;= nums[childpos]:</span><br><span class="line">                childpos = rightpos</span><br><span class="line">            <span class="keyword">if</span> newitem &lt; nums[childpos]:</span><br><span class="line">                nums[pos] = nums[childpos]</span><br><span class="line">                pos = childpos</span><br><span class="line">                childpos = pos * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        nums[pos] = newitem</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 递归写法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">adjust_heap</span>(<span class="params">nums, startpos, endpos</span>):</span></span><br><span class="line">        pos = startpos</span><br><span class="line">        chilidpos = pos * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> chilidpos &lt; endpos:</span><br><span class="line">            rightpos = chilidpos + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> rightpos &lt; endpos <span class="keyword">and</span> nums[rightpos] &gt; nums[chilidpos]:</span><br><span class="line">                chilidpos = rightpos</span><br><span class="line">            <span class="keyword">if</span> nums[chilidpos] &gt; nums[pos]:</span><br><span class="line">                nums[pos], nums[chilidpos] = nums[chilidpos], nums[pos]</span><br><span class="line">                adjust_heap(nums, pos, endpos)</span><br><span class="line"></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="comment"># 建堆</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="built_in">range</span>(n // <span class="number">2</span>)):</span><br><span class="line">        adjust_heap(nums, i, n)</span><br><span class="line">    <span class="comment"># 调整堆</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        nums[<span class="number">0</span>], nums[i] = nums[i], nums[<span class="number">0</span>]</span><br><span class="line">        adjust_heap(nums, <span class="number">0</span>, i)</span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>







<h2 id="8-计数排序-CountingSort"><a href="#8-计数排序-CountingSort" class="headerlink" title="8 计数排序_CountingSort"></a>8 计数排序_CountingSort</h2><p>计数排序是典型的空间换时间算法，开辟额外数据空间存储用索引号记录数组的值和数组值个数</p>
<p>算法描述：</p>
<ul>
<li>找出待排序的数组的最大值和最小值</li>
<li>统计数组值的个数</li>
<li>反向填充目标数组</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gbuvuexgkng30s40fhjww.gif" alt="img"></p>
<p>算法分析：稳定排序，外排序，时间复杂度O(n + k)，但是对于数据范围很大的数组，需要大量时间和内存。</p>
<h2 id="9-桶排序-BucketSort"><a href="#9-桶排序-BucketSort" class="headerlink" title="9 桶排序_BucketSort"></a>9 桶排序_BucketSort</h2><p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gbuvy7lbqqj308n03nt8q.jpg" alt="img"></p>
<p>桶排序是计数排序的升级版，原理是：输入数据服从均匀分布的，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的算法或是以递归方式继续使用桶排序，此文编码采用递归方式）</p>
<p>算法描述：</p>
<ul>
<li>人为设置一个桶的BucketSize，作为每个桶放置多少个不同数值（意思就是BucketSize = 5，可以放5个不同数字比如[1, 2, 3,4,5]也可以放 100000个3，只是表示该桶能存几个不同的数值）</li>
<li>遍历待排序数据，并且把数据一个一个放到对应的桶里去</li>
<li>对每个不是桶进行排序，可以使用其他排序方法，也递归排序</li>
<li>不是空的桶里数据拼接起来</li>
</ul>
<p>算法分析：稳定排序，外排序，时间复杂度O(n + k)<em>O</em>(<em>n</em>+<em>k</em>)，<code>k</code>为桶的个数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bucket_sort</span>(<span class="params">nums, bucketSize</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    _min = <span class="built_in">min</span>(nums)</span><br><span class="line">    _max = <span class="built_in">max</span>(nums)</span><br><span class="line">    <span class="comment"># 需要桶个数</span></span><br><span class="line">    bucketNum = (_max - _min) // bucketSize + <span class="number">1</span></span><br><span class="line">    buckets = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(bucketNum)]</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="comment"># 放入相应的桶中</span></span><br><span class="line">        buckets[(num - _min) // bucketSize].append(num)</span><br><span class="line">    res = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> bucket <span class="keyword">in</span> buckets:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> bucket: <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> bucketSize == <span class="number">1</span>:</span><br><span class="line">            res.extend(bucket)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 当都装在一个桶里,说明桶容量大了</span></span><br><span class="line">            <span class="keyword">if</span> bucketNum == <span class="number">1</span>:</span><br><span class="line">                bucketSize -= <span class="number">1</span></span><br><span class="line">            res.extend(bucket_sort(bucket, bucketSize))</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>





<h2 id="10-基数排序-RadixSort"><a href="#10-基数排序-RadixSort" class="headerlink" title="10 基数排序_RadixSort"></a>10 基数排序_RadixSort</h2><p>基数排序是对数字每一位进行排序，从最低位开始排序</p>
<p>算法描述：</p>
<ul>
<li>找到数组最大值，得最大位数；</li>
<li>从最低位开始取每个位组成radix数组；</li>
<li>对radix进行计数排序（计数排序适用于小范围的特点）。</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/0082zybpgy1gbuw3cz71lg30s40fywic.gif" alt="img"></p>
<p>算法分析：稳定排序，外排序，时间复杂度 posCount * (n + n)posCount∗(n+n) ，其中 posCount 为数组中最大元素的最高位数；简化下得：$O( k *n ) $；其中k为常数，n为元素个数。</p>
<h1 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h1><h2 id="数据结构算法"><a href="#数据结构算法" class="headerlink" title="数据结构算法"></a>数据结构算法</h2><p>常见的数据结构</p>
<ul>
<li><strong>栈（Stack）：</strong>栈是一种特殊的线性表，它只能在一个表的一个固定端进行数据结点的插入和删除操作。</li>
<li><strong>队列（Queue）：</strong>队列和栈类似，也是一种特殊的线性表。和栈不同的是，队列只允许在表的一端进行插入操作，而在另一端进行删除操作。</li>
<li><strong>数组（Array）：</strong>数组是一种聚合数据类型，它是将具有相同类型的若干变量有序地组织在一起的集合。</li>
<li><strong>链表（Linked List）：</strong>链表是一种数据元素按照链式存储结构进行存储的数据结构，这种存储结构具有在物理上存在非连续的特点。</li>
<li><strong>树（Tree）：</strong>树是典型的非线性结构，它是包括，2 个结点的有穷集合 K。</li>
<li><strong>图（Graph）：</strong>图是另一种非线性数据结构。在图结构中，数据结点一般称为顶点，而边是顶点的有序偶对。</li>
<li><strong>堆（Heap）：</strong>堆是一种特殊的树形数据结构，一般讨论的堆都是二叉堆。</li>
<li><strong>散列表（Hash table）：</strong>散列表源自于散列函数(Hash function)，其思想是如果在结构中存在关键字和T相等的记录，那么必定在F(T)的存储位置可以找到该记录，这样就可以不用进行比较操作而直接取得所查记录。</li>
</ul>
<h2 id="Hashmap处理哈希冲突的分析方法"><a href="#Hashmap处理哈希冲突的分析方法" class="headerlink" title="Hashmap处理哈希冲突的分析方法"></a>Hashmap处理哈希冲突的分析方法</h2><p><strong>哈希算法</strong>：根据设定的哈希函数H（key）和处理冲突方法将一组关键字映象到一个有限的地址区间上的算法。</p>
<p><strong>哈希表</strong>：数据经过哈希算法之后得到的集合。这样关键字和数据在集合中的位置存在一定的关系，可以根据这种关系快速查询。</p>
<p><strong>哈希冲突</strong>：对于散列表而言，无论设置的存储区域（n）有多大，当需要存储的数据大于 n 时，那么必然会存在哈希值相同的情况。这就是所谓的<strong>散列冲突</strong>。</p>
<h3 id="开放定址法"><a href="#开放定址法" class="headerlink" title="开放定址法"></a>开放定址法</h3><p>从发生冲突的那个单元起，按照一定的次序，从哈希表中找到一个空闲的单元。然后把发生冲突的元素存入到该单元的一种方法。开放定址法需要的表长度要大于等于所需要存放的元素。 在开放定址法中解决冲突的方法有：线行探查法、平方探查法、双散列函数探查法。 开放定址法的缺点在于删除元素的时候不能真的删除，否则会引起查找错误，只能做一个特殊标记。只到有下个元素插入才能真正删除该元素。</p>
<h4 id="线行探查法"><a href="#线行探查法" class="headerlink" title="线行探查法"></a>线行探查法</h4><p>线行探查法是开放定址法中最简单的冲突处理方法，它从发生冲突的单元起，依次判断下一个单元是否为空，当达到最后一个单元时，再从表首依次判断。直到碰到空闲的单元或者探查完全部单元为止。 </p>
<h4 id="平方探查法"><a href="#平方探查法" class="headerlink" title="平方探查法"></a>平方探查法</h4><p>平方探查法即是发生冲突时，用发生冲突的单元d[i], 加上 1²、 2²等。即d[i] + 1²，d[i] + 2², d[i] + 3²…直到找到空闲单元。 在实际操作中，平方探查法不能探查到全部剩余的单元。不过在实际应用中，能探查到一半单元也就可以了。若探查到一半单元仍找不到一个空闲单元，表明此散列表太满，应该重新建立。</p>
<h4 id="双散列函数探查法"><a href="#双散列函数探查法" class="headerlink" title="双散列函数探查法"></a>双散列函数探查法</h4><p>这种方法使用两个散列函数hl和h2。其中hl和前面的h一样，以关键字为自变量，产生一个0至m—l之间的数作为散列地址；h2也以关键字为自变量，产生一个l至m—1之间的、并和m互素的数(即m不能被该数整除)作为探查序列的地址增量(即步长)，探查序列的步长值是固定值l；对于平方探查法，探查序列的步长值是探查次数i的两倍减l；对于双散列函数探查法，其探查序列的步长值是同一关键字的另一散列函数的值。</p>
<h3 id="链地址法（拉链法）"><a href="#链地址法（拉链法）" class="headerlink" title="链地址法（拉链法）"></a>链地址法（拉链法）</h3><p>链接地址法的思路是将哈希值相同的元素构成一个同义词的单链表，并将单链表的头指针存放在哈希表的第i个单元中，查找、插入和删除主要在同义词链表中进行。链表法适用于经常进行插入和删除的情况。 如下一组数字,(32、40、36、53、16、46、71、27、42、24、49、64)哈希表长度为13，哈希函数为H(key)=key%13,则链表法结果如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>       </span><br><span class="line"><span class="number">1</span>  -&gt; <span class="number">40</span> -&gt; <span class="number">27</span> -&gt; <span class="number">53</span> </span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span>  -&gt; <span class="number">16</span> -&gt; <span class="number">42</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span>  -&gt; <span class="number">32</span> -&gt; <span class="number">71</span></span><br><span class="line"><span class="number">7</span>  -&gt; <span class="number">46</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span> -&gt; <span class="number">36</span> -&gt; <span class="number">49</span></span><br><span class="line"><span class="number">11</span> -&gt; <span class="number">24</span></span><br><span class="line"><span class="number">12</span> -&gt; <span class="number">64</span></span><br></pre></td></tr></table></figure>

<h3 id="再哈希法"><a href="#再哈希法" class="headerlink" title="再哈希法"></a>再哈希法</h3><p>就是同时构造多个不同的哈希函数： Hi = RHi(key)   i= 1,2,3 … k; 当H1 = RH1(key)  发生冲突时，再用H2 = RH2(key) 进行计算，直到冲突不再产生，这种方法不易产生聚集，但是增加了计算时间。</p>
<h3 id="建立公共溢出区"><a href="#建立公共溢出区" class="headerlink" title="建立公共溢出区"></a>建立公共溢出区</h3><p>将哈希表分为公共表和溢出表，当溢出发生时，将所有溢出数据统一放到溢出区。</p>
<h2 id="堆排序，大堆，小堆，堆排序的原理"><a href="#堆排序，大堆，小堆，堆排序的原理" class="headerlink" title="堆排序，大堆，小堆，堆排序的原理"></a>堆<a href="">排序</a>，大堆，小堆，堆<a href="">排序</a>的原理</h2><h2 id="统计一篇论文，前面出现前十的单词。Counter-List"><a href="#统计一篇论文，前面出现前十的单词。Counter-List" class="headerlink" title="统计一篇论文，前面出现前十的单词。Counter(), List"></a>统计一篇论文，前面出现前十的单词。Counter(), List</h2><p>Linux：<code>cat &lt;em&gt;filename&lt;/em&gt; | sort | unique -c | sort -k1,1nr | head 10</code></p>
<p>list –&gt; dict count(key)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#统计为字典</span></span><br><span class="line">counts=&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> all_set:</span><br><span class="line">     counts[key] = all_C.count(key)</span><br></pre></td></tr></table></figure>



<h2 id="元组和列表的区别"><a href="#元组和列表的区别" class="headerlink" title="元组和列表的区别"></a>元组和列表的区别</h2><ul>
<li><p>元组：元组中的元素无法修改，除非将元组整体替换掉，tuple 元组是一个只读版本的 list 列表，性能好（没有指针）。而元组是静态的，长度大小固定，无法增加删减或者改变（immutable）。</p>
</li>
<li><p>列表：列表中的元素可以进行任意修改表是动态的，长度大小不固定，可以随意地增加、删减或者改变元素（mutable）。</p>
</li>
</ul>
<h2 id="装饰器的作用"><a href="#装饰器的作用" class="headerlink" title="装饰器的作用"></a>装饰器的作用</h2><p>装饰器（Decorators） 是 Python 的一个重要部分。简单地说：他们是修改其他函数的功能的函数。是一种函数的函数，因为装饰器传入的参数就是一个函数，然后通过实现各种功能来对这个函数的功能进行增强。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;123&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hello</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;同学你好&#x27;</span>)</span><br><span class="line"></span><br><span class="line">say_hello()</span><br></pre></td></tr></table></figure>

<ul>
<li> wraps 装饰器</li>
</ul>
<p>一个函数不止有他的执行语句，还有着 <code>__name__</code>（函数名），<code>__doc__</code> （说明文档）等属性，我们之前的例子会导致这些属性改变。</p>
<ul>
<li>内置装饰器</li>
</ul>
<p>有三种我们经常会用到的装饰器， <code>property</code>、 <code>staticmethod</code>、 <code>classmethod</code>，他们有个共同点，都是作用于类方法之上。</p>
<ul>
<li>类装饰器</li>
</ul>
<h2 id="Python2和Python3之间的区别"><a href="#Python2和Python3之间的区别" class="headerlink" title="Python2和Python3之间的区别"></a>Python2和Python3之间的区别</h2><ul>
<li>print 不同</li>
<li>编码不同： 2是ASCII（原因在于 Python这门语言诞生的时候还没出现 Unicode） 3是UTF-8</li>
<li>字符串：str–&gt;byte unicode–&gt;str</li>
<li>True 和 False 变为两个关键字,永远指向两个固定的对象，不允许再被重新赋值, True = 1 报错</li>
<li>迭代器：xrange 返回列表对象， next</li>
<li>global nonlocal,非局部变量</li>
<li>format</li>
<li>统一 int</li>
</ul>
<h2 id="Python的优缺点"><a href="#Python的优缺点" class="headerlink" title="Python的优缺点"></a>Python的优缺点</h2><p>优点：</p>
<ul>
<li>开源。。。</li>
<li>Python 简单易用，学习成本低，看起来非常优雅干净，代码舒适；</li>
<li>面向对象，可扩展性强</li>
<li>Python 标准库和第三库众多，功能强大，既可以开发小工具，也可以开发企业级应用；</li>
<li>Python 站在了人工智能和<a target="_blank" rel="noopener" href="http://c.biancheng.net/big_data/">大数据</a>的风口上。</li>
</ul>
<p>缺点：</p>
<ul>
<li>运行速度慢是解释型语言的通病，Python 也不例外。（<strong>解释型语言</strong>（英语：Interpreted language）是一种编程<strong>语言</strong>类型。 这种类型的程式<strong>语言</strong>，会将程式码一句一句直接执行，不需要像编译<strong>语言</strong>（Compiled language）一样，经过编译器先行编译为机器码，之后再执行。）</li>
<li>强类型语言（python属于强类型）   数据类型不可以被忽略的语言 即变量的数据类型一旦被定义，那就不会再改变，除非进行强转。 在python中，例如：name = ‘egon’，这个变量name在被赋值的那一刻，数据类型就被确定死了，是字符型，值为’egon’。 </li>
<li>动态：运行时才进行数据类型检查 即在变量赋值时，就确定了变量的数据类型，不用事先给变量指定数据类型  </li>
<li>伪多线程</li>
</ul>
<h2 id="提高Python运行效率的方法"><a href="#提高Python运行效率的方法" class="headerlink" title="提高Python运行效率的方法"></a>提高Python运行效率的方法</h2><ul>
<li>外部包，<strong>关键代码使用外部功能包</strong><ul>
<li>Cython Pylnlne PyPy Pyrex</li>
</ul>
</li>
<li>使用局部变量，便于维护，提高性能并节省内存。</li>
<li><strong>先编译后调用</strong></li>
<li><strong>采用生成器表达式替代列表解析</strong></li>
<li>排序：最佳的排序方法其实是尽可能多地使用键和内置的 sort() 方法。</li>
<li><strong>优化算法时间</strong></li>
<li><strong>循环优化</strong></li>
<li>多核 多线程 ：因为GIL的存在，Python很难充分利用多核CPU的优势。但是，可以通过内置的模块multiprocessing实现下面几种并行模式：</li>
</ul>
<h2 id="判别两个类别的字符串"><a href="#判别两个类别的字符串" class="headerlink" title="判别两个类别的字符串"></a>判别两个类别的字符串</h2><h2 id="tcp保证数据传输的三个流程"><a href="#tcp保证数据传输的三个流程" class="headerlink" title="tcp保证数据传输的三个流程"></a>tcp保证数据传输的三个流程</h2><p>TCP为了提供可靠传输：<br>（1）首先，采用三次握手来建立TCP连接，四次握手来释放TCP连接，从而保证建立的传输信道是可靠的。<br>（2）其次，TCP采用了连续ARQ协议（回退N，Go-back-N；超时自动重传）(自动重传请求（Automatic Repeat-reQuest，ARQ）)来保证数据传输的正确性，使用滑动窗口协议来保证接方能够及时处理所接收到的数据，进行流量控制。<br>（3）最后，TCP使用慢开始、拥塞避免、快重传和快恢复来进行拥塞控制，避免网络拥塞。</p>
<h2 id="tcp-三次握手"><a href="#tcp-三次握手" class="headerlink" title="tcp 三次握手"></a>tcp 三次握手</h2><p>在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。<br>第一次握手： 建立连接时，客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；<br>第二次握手： 服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；<br>第三次握手： 客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。 完成三次握手，客户端与服务器开始传送数据.</p>
<p>三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送 3 个包</p>
<p>主要作用就是为了<strong>确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号</strong>为后面的可靠性传送做准备</p>
<p>过程如下：</p>
<ul>
<li>第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)，此时客户端处于 SYN_SENT 状态</li>
<li>第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，为了确认客户端的 SYN，将客户端的 ISN+1作为ACK的值，此时服务器处于 SYN_RCVD 的状态</li>
<li>第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，值为服务器的ISN+1。此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/df92e0deefb619759aa435aca99720cf4113a5ba705eb09f1636f91c89d3eb1e/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f66623438396663302d626562392d313165622d383566362d3666616337376330633962332e706e67"><img src="https://camo.githubusercontent.com/df92e0deefb619759aa435aca99720cf4113a5ba705eb09f1636f91c89d3eb1e/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f66623438396663302d626562392d313165622d383566362d3666616337376330633962332e706e67" alt="img"></a></p>
<p>上述每一次握手的作用如下：</p>
<ul>
<li>第一次握手：客户端发送网络包，服务端收到了<br>  这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</li>
<li>第二次握手：服务端发包，客户端收到了<br>  这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时<strong>服务器并不能确认客户端的接收能力</strong>是否正常</li>
<li>第三次握手：客户端发包，服务端收到了<br>  这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常</li>
</ul>
<p>通过三次握手，就能确定双方的接收和发送能力是正常的。之后就可以正常通信了</p>
<h2 id="为什么三次握手"><a href="#为什么三次握手" class="headerlink" title="为什么三次握手"></a>为什么三次握手</h2><p>第三次握手🤝服务端（接收端）确认自己发的包对方能接收到，如果采用两次握手的话, 客户端有可能因为网络阻塞等原因会发送多个请求报文，延时到达的请求又会与服务器建立连接，浪费掉许多服务器的资源。</p>
<p>如果是两次握手，发送端可以确定自己发送的信息能对方能收到，也能确定对方发的包自己能收到，但接收端只能确定对方发的包自己能收到 <strong>无法确定自己发的包对方能收到</strong>，并且两次握手的话, 客户端有可能因为网络阻塞等原因会发送多个请求报文，延时到达的请求又会与服务器建立连接，浪费掉许多服务器的资源</p>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p><code>tcp</code>终止一个连接，需要经过四次挥手</p>
<p>过程如下：</p>
<ul>
<li>第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态，停止发送数据，等待服务端的确认</li>
<li>第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态</li>
<li>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 <code>LAST_ACK</code> 的状态</li>
<li>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/245cf8925daac2792d36f0f07066826a955175fe6e09030ae0a7ae17d1be9954/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f30613365626239302d626562612d313165622d383566362d3666616337376330633962332e706e67"><img src="https://camo.githubusercontent.com/245cf8925daac2792d36f0f07066826a955175fe6e09030ae0a7ae17d1be9954/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f30613365626239302d626562612d313165622d383566362d3666616337376330633962332e706e67" alt="img"></a></p>
<h2 id="四次挥手原因"><a href="#四次挥手原因" class="headerlink" title="四次挥手原因"></a>四次挥手原因</h2><p>服务端在收到客户端断开连接<code>Fin</code>报文后，并不会立即关闭连接，而是先发送一个<code>ACK</code>包先告诉客户端收到关闭连接的请求，只有当<strong>服务器的所有报文发送完毕</strong>之后，才发送<code>FIN</code>报文断开连接，因此需要四次挥手</p>
<p>两个两次连接</p>
<ul>
<li>客户端 &lt;–&gt; 服务端</li>
<li>服务端 &lt;–&gt; 客户端</li>
</ul>
<h2 id="CLOSE-WAIT状态的含义，如果服务端出现过多C-W状态，该如何处理"><a href="#CLOSE-WAIT状态的含义，如果服务端出现过多C-W状态，该如何处理" class="headerlink" title="CLOSE-WAIT状态的含义，如果服务端出现过多C-W状态，该如何处理"></a>CLOSE-WAIT状态的含义，如果服务端出现过多C-W状态，该如何处理</h2><h3 id="1-1-出现的原因"><a href="#1-1-出现的原因" class="headerlink" title="1.1 出现的原因"></a>1.1 出现的原因</h3><ul>
<li>高并发短连接的服务器上会出现这样的情况，导致创建大量的tcp连接然后close，出现大量的连接出现time_wait的状态。</li>
</ul>
<h3 id="1-2-大量time-wait的危害"><a href="#1-2-大量time-wait的危害" class="headerlink" title="1.2.大量time_wait的危害"></a>1.2.大量time_wait的危害</h3><ul>
<li>在socket的TIME_WAIT状态结束之前，该socket所占用的本地端口号将一直无法释放</li>
<li>在高并发（每秒几万qps）并且采用短连接方式进行交互的系统中运行一段时间后，系统中就会存在大量的time_wait状态，如果time_wait状态把系统所有可用端口都占完了且尚未被系统回收时，就会出现无法向服务端创建新的socket连接的情况。此时系统几乎停转，任何链接都不能建立。</li>
<li>大量的time_wait状态也会系统一定的fd，内存和cpu资源，当然这个量一般比较小，并不是主要危害</li>
</ul>
<h3 id="1-3-大量time-wait解决方案"><a href="#1-3-大量time-wait解决方案" class="headerlink" title="1.3.大量time_wait解决方案"></a>1.3.大量time_wait解决方案</h3><p><strong>方式一：调整系统内核参数</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_tw_reuse = <span class="number">1</span> 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为<span class="number">0</span>，表示关闭；</span><br><span class="line">net.ipv4.tcp_tw_recycle = <span class="number">1</span> 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为<span class="number">0</span>，表示关闭。</span><br><span class="line">net.ipv4.tcp_tw_recycle = <span class="number">1</span>表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为<span class="number">0</span>，表示关闭。</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>允许允许将TIME-WAIT sockets重新用于新的TCP连接，同时TIME-WAIT sockets的加快回收</p>
<p><strong>方式二：改短连接为长连接</strong></p>
<ul>
<li>短连接和长连接工作方式的区别：</li>
</ul>
<p>短连接：</p>
<ul>
<li>连接-&gt;传输数据-&gt;关闭连接</li>
<li>HTTP是无状态的，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。</li>
<li>也可以这样说：短连接是指SOCKET连接后发送后接收完数据后马上断开连接。</li>
</ul>
<p>长连接：</p>
<ul>
<li>连接-&gt;传输数据-&gt;保持连接 -&gt; 传输数据-&gt; 。。。-&gt;关闭连接。</li>
<li>长连接指建立SOCKET连接后不管是否使用都保持连接，但安全性较差。</li>
</ul>
<p>从区别上可以看出，长连接比短连接从根本上减少了关闭连接的次数，减少了TIME_WAIT状态的产生数量，在高并发的系统中，这种方式的改动非常有效果，可以明显减少系统TIME_WAIT的数量。</p>
<h2 id="二-大量close-wait的出现"><a href="#二-大量close-wait的出现" class="headerlink" title="二. 大量close_wait的出现"></a>二. 大量close_wait的出现</h2><h3 id="2-1-出现的原因和解决方案"><a href="#2-1-出现的原因和解决方案" class="headerlink" title="2.1 出现的原因和解决方案"></a>2.1 出现的原因和解决方案</h3><ul>
<li>close_wait是被动关闭连接是形成的，根据TCP状态机，服务器端收到客户端发送的FIN，TCP协议栈会自动发送ACK，链接进入close_wait状态。但如果服务器端不执行socket的close()操作（即不向客户端发送FIN），状态就不能由close_wait迁移到last_ack，则系统中会存在很多close_wait状态的连接</li>
</ul>
<p>我觉得第一时间应该去判断是客户端的问题还是服务端的问题，有可能是客户端一直在向服务端发送FIN，也有可能是服务端一直没有发送自己的FIN。</p>
<p>可能的原因如下：</p>
<ul>
<li>关闭socket不及时：例如I/O线程被意外阻塞，或者I/O线程执行的用户自定义Task比例过高，导致I/O操作处理不及时，链路不能被及时释放。</li>
</ul>
<p>通常，CLOSE_WAIT 状态在服务器停留时间很短，如果你发现大量的 CLOSE_WAIT 状态，那么就意味着被动关闭的一方没有及时发出 FIN 包，一般有如下几种可能：</p>
<ul>
<li>程序问题：如果代码层面忘记了 close 相应的 socket 连接，那么自然不会发出 FIN 包，从而导致 CLOSE_WAIT 累积；或者代码不严谨，出现死循环之类的问题，导致即便后面写了 close 也永远执行不到。</li>
<li>响应太慢或者超时设置过小：如果连接双方不和谐，一方不耐烦直接 timeout，另一方却还在忙于耗时逻辑，就会导致 close 被延后。响应太慢是首要问题，不过换个角度看，也可能是 timeout 设置过小。</li>
</ul>
<h2 id="常见的网络模型"><a href="#常见的网络模型" class="headerlink" title="常见的网络模型"></a>常见的网络模型</h2><p><img src="https://pic1.zhimg.com/80/v2-a9976ebe153157fde548aaa7b8d73e28_1440w.jpg" alt="img"></p>
<h2 id="二、三级转发"><a href="#二、三级转发" class="headerlink" title="二、三级转发"></a>二、三级转发</h2><p>二层：交换机</p>
<p>三层：路由器</p>
<ul>
<li>路由器有多个端口，分别连接不同的数据链路。它通过识别目的 IP 地址的<strong>网络号</strong>，再根据<strong>路由表</strong>进行转发，路由表中有<strong>匹配</strong>的路由条目才会转发，无匹配的路由条目则直接丢弃。路由条目既可以手动设置静态路由，也可以通过路由协议自动生成动态路由。</li>
</ul>
<h2 id="TCP-UDP"><a href="#TCP-UDP" class="headerlink" title="TCP/UDP"></a>TCP/UDP</h2><p>UDP 不可靠不稳定 面向非连接</p>
<p>TCP 可靠稳定 面向连接</p>
<p><strong>TCP 应用场景：</strong></p>
<p>当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如 HTTP、HTTPS、FTP 等传输文件的协议，POP、SMTP 等邮件传输的协议。</p>
<p>在日常生活中，常见使用 TCP 协议的应用如下： 浏览器用的 HTTP， FlashFXP 用的 FTP，Outlook 用的 POP、SMTP，Putty 用的 Telnet、SSH，QQ 文件传输。</p>
<p><strong>UDP 应用场景：</strong> </p>
<p>当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用 UDP。 </p>
<p>比如，日常生活中，常见使用 UDP 协议的应用如下：QQ 语音，QQ 视频，TFTP 等。有些应用场景对可靠性要求不高会用到 UPD，比如长视频，要求速率。</p>
<h2 id="python垃圾回收"><a href="#python垃圾回收" class="headerlink" title="python垃圾回收"></a>python垃圾回收</h2><p><strong>引用计数为主，分代收集为辅。</strong>在 python 中，<strong>如果一个对象的引用数为 0， python 虚拟机就会回收这个对象的内存。</strong></p>
<ul>
<li><p>导致引用计数 +1 的情况：</p>
<blockquote>
<ul>
<li>对象被创建： a = classname()</li>
<li>对象被引用： b = a</li>
<li>对象被作为参数，传入到一个函数中： func(a)</li>
<li>对象作为一个元素，存储在容器内： list_name = [a, a]</li>
</ul>
</blockquote>
</li>
<li><p>导致引用计数 -1 的情况：</p>
<blockquote>
<ul>
<li>对象的别名被显式销毁， 如： del a </li>
<li>对象的别名被赋予新的对象，如：a = other_class()</li>
<li>一个对象离开它的作用域，如函数执行完毕时，func 函数中的局部变量</li>
<li>对象所在的容器被销毁，或从容器中删除对象</li>
</ul>
</blockquote>
</li>
</ul>
<p><strong>循环引用导致内存泄漏</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">c1 = ClassA() <span class="comment"># 内存 1 引用计数 +1 = 1</span></span><br><span class="line">c2 = ClassA() <span class="comment"># 内存 2 引用计数 +1 = 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环引用</span></span><br><span class="line">c1.t=c2  <span class="comment">#  内存 2 引用计数 +1 = 2</span></span><br><span class="line">c2.t=c1  <span class="comment">#  内存 1 引用计数 +1 = 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> c1  <span class="comment"># 内存 1 引用计数 -1 = 1</span></span><br><span class="line"><span class="keyword">del</span> c2  <span class="comment"># 内存 2 引用计数 -1 = 1 如上文描述，由于**循环引用**，导致垃圾回收器都不会回收它们，所以就会导致内存泄露。</span></span><br></pre></td></tr></table></figure>

<p><strong>垃圾回收机制模块： gc</strong></p>
<h2 id="浅、深拷贝"><a href="#浅、深拷贝" class="headerlink" title="浅、深拷贝"></a>浅、深拷贝</h2><ul>
<li><strong>直接赋值：</strong>其实就是对象的引用（别名）。</li>
<li><strong>浅拷贝(copy)：</strong>拷贝父对象，不会拷贝对象的内部的子对象。</li>
<li><strong>深拷贝(deepcopy)：</strong> copy 模块的 deepcopy 方法，完全拷贝了父对象及其子对象。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 浅</span></span><br><span class="line"><span class="comment"># 浅拷贝, a 和 b 是一个独立的对象，但他们的子对象还是指向统一对象（是引用）。</span></span><br><span class="line">&gt;&gt;&gt;a = &#123;<span class="number">1</span>: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a.copy()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b</span><br><span class="line">(&#123;<span class="number">1</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;, &#123;<span class="number">1</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>].append(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b</span><br><span class="line">(&#123;<span class="number">1</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]&#125;, &#123;<span class="number">1</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----------------------------------------</span><br><span class="line"><span class="comment"># 深</span></span><br><span class="line"><span class="comment">## 需要导入 copy, 深度拷贝, a 和 b 完全拷贝了父对象及其子对象，两者是完全独立的。</span></span><br><span class="line">&gt;&gt;&gt;<span class="keyword">import</span> copy</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = copy.deepcopy(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, c</span><br><span class="line">(&#123;<span class="number">1</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]&#125;, &#123;<span class="number">1</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>].append(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, c</span><br><span class="line">(&#123;<span class="number">1</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]&#125;, &#123;<span class="number">1</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]&#125;)</span><br></pre></td></tr></table></figure>



<p><strong>b=a</strong> 赋值引用，a 和 b 都指向同一个对象。<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gulaxem2zdj609u06uaa302.jpg" alt="img"></p>
<p>**b = a.copy():**浅拷贝, a 和 b 是一个独立的对象，但他们的子对象还是指向统一对象（是引用）<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gulay0ol1fj60ac0780sv02.jpg" alt="img"></p>
<p><strong>b = copy.deepcopy(a):</strong> 深度拷贝, a 和 b 完全拷贝了父对象及其子对象，两者是完全独立的。<img src="https://www.runoob.com/wp-content/uploads/2017/03/1489720930-5882-BO4qO.png" alt="img"></p>
<h2 id="10亿个数取最大的10个怎么取，说三种方案"><a href="#10亿个数取最大的10个怎么取，说三种方案" class="headerlink" title="10亿个数取最大的10个怎么取，说三种方案"></a>10亿个数取最大的10个怎么取，说三种方案</h2><p>直接排序<br>最容易想到的方法是将数据全部排序，然后在排序后的集合中进行查找，最快的排序算法的时间复杂度一般为O（nlogn），如快速排序。但是在32位的机器上，每个float类型占4个字节，1亿个浮点数就要占用400MB的存储空间，对于一些可用内存小于400M的计算机而言，很显然是不能一次将全部数据读入内存进行排序的。其实即使内存能够满足要求（我机器内存都是8GB），该方法也并不高效，因为题目的目的是寻找出最大的1000个数即可，而排序却是将所有的元素都排序了，做了很多的无用功。</p>
<p><strong>局部淘汰法</strong><br>第二种方法为局部淘汰法，该方法与排序方法类似，用一个容器保存<strong>前1000个数</strong>，然后将剩余的所有数字——<strong>与容器内的最小数字相比</strong>，如果所有后续的元素都比容器内的1000个数还小，那么容器内这个1000个数就是最大1000个数。如果某一后续元素比容器内最小数字大，则删掉容器内最小元素，并将该元素插入容器，最后遍历完这1亿个数，得到的结果容器中保存的数即为最终结果了。此时的时间复杂度为O（n+m^2），其中m为容器的大小，即1000。</p>
<p><strong>分治法</strong><br>第三种方法是分治法，将1亿个数据分成100份，每份100万个数据，找到每份数据中最大的1000个，最后在剩下的100*1000个数据里面找出最大的1000个。如果100万数据选择足够理想，那么可以过滤掉1亿数据里面99%的数据。100万个数据里面查找最大的1000个数据的方法如下：用快速排序的方法。。。</p>
<p>Hash法<br>第四种方法是Hash法。如果这1亿个数里面有很多重复的数，先通过Hash法，把这1亿个数字去重复，这样如果重复率很高的话，会减少很大的内存用量，从而缩小运算空间，然后通过分治法或最小堆法查找最大的1000个数。</p>
<p>最小堆<br>第五种方法采用最小堆。首先读入前1000个数来创建大小为1000的最小堆，建堆的时间复杂度为O（mlogm）（m为数组的大小即为1000），然后遍历后续的数字，并于堆顶（最小）数字进行比较。如果比最小的数小，则继续读取后续数字；如果比堆顶数字大，则替换堆顶元素并重新调整堆为最小堆。整个过程直至1亿个数全部遍历完为止。然后输出当前堆中的所有1000个数字。该算法的时间复杂度为O（nmlogm），空间复杂度是1000（常数）。</p>
<h2 id="linux命令说几个"><a href="#linux命令说几个" class="headerlink" title="linux命令说几个"></a>linux命令说几个</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvmyj6ow8qj60ns1cgwgy02.jpg"></p>
<h2 id="分库分表目的"><a href="#分库分表目的" class="headerlink" title="分库分表目的"></a>分库分表目的</h2><h2 id="Python锁"><a href="#Python锁" class="headerlink" title="Python锁"></a>Python锁</h2><p>一、全局解释器锁（GIL）</p>
<p>1、什么是全局解释器锁</p>
<p><strong>每个CPU在同一时间只能执行一个线程，那么其他的线程就必须等待该线程的全局解释器，</strong>使用权消失后才能使用全局解释器，即使多个线程直接不会相互影响在同一个进程下也只有一个线程使用cpu，这样的机制称为全局解释器锁（GIL）。GIL的设计简化了CPython的实现，使的对象模型包括关键的内建类型，如：字典等，都是隐含的，可以并发访问的，锁住全局解释器使得比较容易的实现对多线程的支持，但也损失了多处理器主机的并行计算能力。</p>
<p>2、全局解释器锁的好处</p>
<p>1）避免了大量的加锁解锁的好处</p>
<p>2）使数据更加安全，解决多线程间的数据完整性和状态同步</p>
<p>3、全局解释器的缺点</p>
<p>多核处理器退化成单核处理器，只能并发不能并行。</p>
<p>4、GIL的作用：</p>
<p>多线程情况下必须存在资源的竞争，GIL是为了保证在解释器级别的线程唯一使用共享资源（cpu）。</p>
<p>二、同步锁</p>
<p>1、什么是同步锁？</p>
<p>同一时刻的一个进程下的一个线程只能使用一个cpu，要确保这个线程下的程序在一段时间内被cpu执，那么就要用到同步锁。</p>
<p>2、为什么用同步锁？</p>
<p>因为有可能当一个线程在使用cpu时，该线程下的程序可能会遇到io操作，那么cpu就会切到别的线程上去，这样就有可能会影响到该程　　序结果的完整性。</p>
<p>3、怎么使用同步锁？</p>
<p>只需要在对公共数据的操作前后加上上锁和释放锁的操作即可。</p>
<p>4、同步锁的所用：</p>
<p>为了保证解释器级别下的自己编写的程序唯一使用共享资源产生了同步锁。</p>
<p>三、死锁</p>
<p>1、什么是死锁？</p>
<p>指两个或两个以上的线程或进程在执行程序的过程中，因争夺资源或者程序推进顺序不当而相互等待的一个现象。</p>
<p>2、死锁产生的必要条件？</p>
<p>互斥条件、请求和保持条件、不剥夺条件、环路等待条件</p>
<p>3、处理死锁的基本方法？</p>
<p>预防死锁、避免死锁（银行家算法）、检测死锁（资源分配）、解除死锁：剥夺资源、撤销进程</p>
<p>四、什么是递归锁？</p>
<p>在Python中为了支持同一个线程中多次请求同一资源，Python提供了可重入锁。这个RLock内部维护着一个Lock和一个counter变量，counter记录了acquire的次数，从而使得资源可以被多次require。直到一个线程所有的acquire都被release，其他的线程才能获得资源。递归锁分为可递归锁与非递归锁。</p>
<p>五、什么是乐观锁？</p>
<p>假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。</p>
<p>六、什么是悲观锁？</p>
<p>假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。</p>
<p>七、python常用的加锁方式？</p>
<p>互斥锁、可重入锁、迭代死锁、互相调用死锁、自旋锁。</p>
<h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>在执行过程中，遇到<code>yield</code>就中断，下次又继续执行</p>
<p>[] –&gt; ()</p>
<p>batch</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h2 id="数组链表的区别，操作的复杂度"><a href="#数组链表的区别，操作的复杂度" class="headerlink" title="数组链表的区别，操作的复杂度"></a>数组<a href="">链表</a>的区别，操作的复杂度</h2><h2 id="写一个排序（随意），及有关该排序的一系列问题"><a href="#写一个排序（随意），及有关该排序的一系列问题" class="headerlink" title="写一个排序（随意），及有关该排序的一系列问题"></a>写一个<a href="">排序</a>（随意），及有关该<a href="">排序</a>的一系列问题</h2><h2 id="数据库的特性，如何实现"><a href="#数据库的特性，如何实现" class="headerlink" title="数据库的特性，如何实现"></a>数据库的特性，如何实现</h2><h2 id="mysql索引的原理及实现"><a href="#mysql索引的原理及实现" class="headerlink" title="mysql索引的原理及实现"></a>mysql索引的原理及实现</h2><h2 id="HTTPS如何实现安全性"><a href="#HTTPS如何实现安全性" class="headerlink" title="HTTPS如何实现安全性"></a>HTTPS如何实现安全性</h2><p>HTTPS 加密：<code>HTTPS = HTTP + SSL/TLS</code>，通过 <code>SSL</code>证书来验证服务器的身份，并为浏览器和服务器之间的通信进行加密</p>
<p><code>SSL</code> 协议位于<code> TCP/IP</code> 协议与各种应用层协议之间，浏览器和服务器在使用 <code>SSL</code> 建立连接时需要选择一组恰当的加密算法来实现安全通信，为数据通讯提供安全支持</p>
<h3 id="SSL-加密算法"><a href="#SSL-加密算法" class="headerlink" title="SSL 加密算法"></a>SSL 加密算法</h3><ul>
<li><p>对称加密：采用协商的密钥对数据加密</p>
<ul>
<li>对称加密指的是加密和解密使用的秘钥都是同一个，是对称的。只要保证了密钥的安全，那整个通信过程就可以说具有了机密性</li>
</ul>
</li>
<li><p>非对称加密：实现身份认证和密钥协商</p>
<ul>
<li>非对称加密，存在两个秘钥，一个叫公钥，一个叫私钥。两个秘钥是不同的，公钥可以公开给任何人使用，私钥则需要保密</li>
</ul>
</li>
<li><p>摘要算法：验证信息的完整性</p>
<ul>
<li>实现完整性的手段主要是摘要算法，也就是常说的散列函数、哈希函数。可以理解成一种特殊的压缩算法，它能够把任意长度的数据“压缩”成固定长度、而且独一无二的“摘要”字符串，就好像是给这段数据生成了一个数字“指纹”</li>
</ul>
</li>
<li><p>数字签名：身份验证</p>
<ul>
<li>用私钥加密，公钥解密。公钥身份确认，需要证书：<code>CA验证机构</code>: 数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场</li>
</ul>
</li>
</ul>
<h2 id="Python-经常使用的包"><a href="#Python-经常使用的包" class="headerlink" title="Python 经常使用的包"></a>Python 经常使用的包</h2><ul>
<li>数据分析：numpy pandas matploylib seaborn</li>
<li>图像处理：opencv、pil</li>
<li>机器学习：TF Pytorch sklearn </li>
<li>后端：flask requests</li>
</ul>
<h2 id="知道dict和set的底层原理吗？"><a href="#知道dict和set的底层原理吗？" class="headerlink" title="知道dict和set的底层原理吗？"></a>知道dict和set的底层原理吗？</h2><p> 答：<a href="">哈希表</a>的构造 </p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvzg1squ51j30ea0ciaaf.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvzg2ind8cj30fy09pwet.jpg"></p>
<p>dict是用来存储键值对结构的数据的，set其实也是存储的键值对，只是默认键和值是相同的。Python中的dict和set都是通过散列表来实现的。下面来看与dict相关的几个比较重要的问题：</p>
<p>dict中的数据是无序存放的<br>操作的时间复杂度，插入、查找和删除都可以在O(1)的时间复杂度<br>键的限制，只有可哈希的对象才能作为字典的键和set的值。可hash的对象即python中的不可变对象和自定义的对象。可变对象(列表、字典、集合)是不能作为字典的键和st的值的。<br>与list相比：list的查找和删除的时间复杂度是O(n)，添加的时间复杂度是O(1)。但是dict使用hashtable内存的开销更大。为了保证较少的冲突，hashtable的装载因子，一般要小于0.75，在python中当<strong>装载因子达到2/3</strong>的时候就会自动进行扩容。</p>
<h2 id="问课余生活干什么？（强调除了学习）"><a href="#问课余生活干什么？（强调除了学习）" class="headerlink" title="问课余生活干什么？（强调除了学习）"></a>问课余生活干什么？（强调除了学习）</h2><ul>
<li>弹吉他</li>
<li>数码爱好（DIY 耳机、键盘，华强北淘机）</li>
</ul>
<h2 id="数据库索引，b-树的特点，与hash索引有什么异同"><a href="#数据库索引，b-树的特点，与hash索引有什么异同" class="headerlink" title="数据库索引，b+树的特点，与hash索引有什么异同"></a>数据库索引，b+树的特点，与hash索引有什么异同</h2><p>B+树是一个平衡的多叉树。B+树从根节点到叶子节点的搜索效率基本相当，不会出现大幅波动。</p>
<p>哈希索引采用一定的哈希算法，把键值换成新的哈希值，检索时不需要类似B+树那样从根节点逐级查找，只需一次哈希算法即可立刻定位到相应的位置。</p>
<p>两者的区别：</p>
<p>哈希索引的优势：</p>
<p>（1）等值查询。哈希索引具有绝对优势（前提是：没有大量重复键值，如果大量重复键值时，哈希索引的效率很低，因为存在所谓的哈希碰撞问题。）</p>
<p>哈希索引不适用的场景：</p>
<p>（1）不支持范围查询</p>
<p>（2）不支持索引完成排序</p>
<p>（3）不支持联合索引的最左前缀匹配规则</p>
<p>MySQL中，只有HEAP/MEMORY引擎才显示支持哈希索引。而常用的InnoDB引擎中默认使用的是B+树索引，它会实时监控表上索引的使用情况，如果认为建立哈希索引可以提高查询效率，则自动在内存中的“自适应哈希索引缓冲区”建立哈希索引（在InnoDB中默认开启自适应哈希索引），通过观察搜索模式，MySQL会利用index key的前缀建立哈希索引，如果一个表几乎大部分都在缓冲池中，那么建立一个哈希索引能够加快等值查询。</p>
<h2 id="数据库发现某一个表查询很慢可能有哪些原因"><a href="#数据库发现某一个表查询很慢可能有哪些原因" class="headerlink" title="数据库发现某一个表查询很慢可能有哪些原因"></a>数据库发现某一个表查询很慢可能有哪些原因</h2><h3 id="一-设计或编码问题"><a href="#一-设计或编码问题" class="headerlink" title="一.设计或编码问题"></a>一.设计或编码问题</h3><ol>
<li>数据库表设计是否合理，是否正确添加索引</li>
<li>sql语句编写是否合理，查询的时候没有加索引</li>
<li>sql语句编写不规范导致索引失效，改用全表扫描</li>
<li>数据库表的数据是否太大？是否需要分库分表？</li>
<li>程序设计缺陷导致死锁</li>
</ol>
<p><strong>索引失效的几种常见原因：</strong></p>
<ul>
<li>1）查询条件中出现or，!=，或&lt;&gt;</li>
<li>2）复合索引未用左列字段（最左匹配原则）</li>
<li>3）模糊查询 like以%开头;</li>
<li>4）where的判断条件对字段进行了null值判断。因为索引无法存储null</li>
<li>5）where中索引列使用了函数</li>
<li>6）where中索引列有运算</li>
</ul>
<h3 id="二-机器资源问题"><a href="#二-机器资源问题" class="headerlink" title="二. 机器资源问题"></a>二. 机器资源问题</h3><ol>
<li>连接池资源不够用了，参数优化</li>
<li>数据库所在的硬件资源情况：当查询慢的时候，内存占了多少？mysql磁盘IO是不是被其它应用共享且占用高？cpu是不是有负载？<br> 1） 硬件资源本身不够&gt;加资源<br> 2）硬件资源因为和其它进程共享，导致资源不够，可以考虑做资源隔离<br> 3）硬件资源性能不足，比如磁盘可以考虑换成SSD</li>
<li>网络资源<br> 1）应用连接数据库的网络是不是抖动，延时较高</li>
</ol>
<h3 id="三-高并发量导致"><a href="#三-高并发量导致" class="headerlink" title="三. 高并发量导致"></a>三. 高并发量导致</h3><ol>
<li>如果数据量真的炒鸡大，分库分表已经不能满足查询了，考虑将热点数据在redis做缓存。应用架构调整，把缓存模块加进去。</li>
<li>如果已经加了缓存还是慢，会不会是缓存雪崩了？击穿了？缓存命中率低？</li>
<li>缓存任然不能满足查询要求，比如很多字段的查询，可以将查询字段放到ES等大数据组件中，先查ES，ES拿到数据主键id再到MySQL中查询用户请求突然增加，导致查询变慢上有系统出现bug，导致循环调用接口做查询，这个时候是不是考虑异常情况限流</li>
</ol>
<h2 id="10亿个url怎么查询某一个url是否在其中"><a href="#10亿个url怎么查询某一个url是否在其中" class="headerlink" title="10亿个url怎么查询某一个url是否在其中"></a>10亿个url怎么查询某一个url是否在其中</h2><h3 id="为什么不能用散列表"><a href="#为什么不能用散列表" class="headerlink" title="为什么不能用散列表"></a><strong>为什么不能用散列表</strong></h3><p>100 亿是一个很大的数量级，这里每条 url 平均 64 字节，全部存储的话需要 640G 的内存空间。又因为使用了散列表这种数据结构，而散列表是会出现散列冲突的。为了让散列表维持较小的装载因子，避免出现过多的散列冲突，需要使用链表法来处理，这里就要存储链表指针。因此最后的内存空间可能超过 1000G 了。</p>
<h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a><strong>布隆过滤器</strong></h3><p>布隆过滤器（英语：Bloom Filter）是 1970 年由 <strong>Burton Bloom</strong> 提出的。</p>
<p><strong>它实际上是一个很长的二进制矢量和一系列随机映射函数</strong>。</p>
<p>它<strong>可以用来判断一个元素是否在一个集合中</strong>。它的优势是只需要占用很小的内存空间以及有着高效的查询效率。</p>
<p>对于布隆过滤器而言，它的本质是一个<strong>位数组</strong>：位数组就是数组的每个元素都只占用 1 bit ，并且每个元素只能是 0 或者 1。</p>
<p>一开始，布隆过滤器的位数组所有位都初始化为 0。比如，数组长度为 m ，那么将长度为 m 个位数组的所有的位都初始化为 0。</p>
<table>
<thead>
<tr>
<th align="left">0</th>
<th align="left">0</th>
<th align="left">0</th>
<th align="left">0</th>
<th align="left">0</th>
<th align="left">0</th>
<th align="left">0</th>
<th align="left">0</th>
<th align="left">0</th>
<th align="left">0</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">。</td>
<td align="left">。</td>
<td align="left">。</td>
<td align="left">。</td>
<td align="left">。</td>
<td align="left">m-2</td>
<td align="left">m-1</td>
</tr>
</tbody></table>
<p>在数组中的每一位都是二进制位。</p>
<p>布隆过滤器除了一个位数组，还有 K 个哈希函数。当一个元素加入布隆过滤器中的时候，会进行如下操作：</p>
<p>•使用 K 个哈希函数对元素值进行 K 次计算，得到 K 个哈希值。•根据得到的哈希值，在位数组中把对应下标的值置为 1。</p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-2662963/s1o8cgc0y3.jpeg?imageView2/2/w/1620" alt="img"></p>
<p>举个例子，假设布隆过滤器有 3 个哈希函数：f1, f2, f3 和一个位数组 <code>arr</code>。现在要把 <code>2333</code> 插入布隆过滤器中：</p>
<p>•对值进行三次哈希计算，得到三个值 n1, n2, n3。•把位数组中三个元素 arr[n1], arr[n2], arr[3] 都置为 1。</p>
<p>当要判断一个值是否在布隆过滤器中，对元素进行三次哈希计算，得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</p>
<h2 id="Python了解哪些底层原理"><a href="#Python了解哪些底层原理" class="headerlink" title="Python了解哪些底层原理"></a>Python了解哪些底层原理</h2><ul>
<li>内存管理</li>
<li>多线程</li>
</ul>
<h2 id="如果进程内存使用过高"><a href="#如果进程内存使用过高" class="headerlink" title="如果进程内存使用过高"></a>如果进程内存使用过高</h2><p>可能有几个G，在Python该如何查找具体是哪一个对象占用比较高（不会，就硬瞎说），通过哪个模块可以找到这些信息</p>
<ul>
<li><p>sys getsizeof</p>
</li>
<li><p>import psutil </p>
</li>
<li><p>df.memory_usage()显示</p>
</li>
</ul>
<h2 id="用-new-这种魔法函数实现单例，写伪代码"><a href="#用-new-这种魔法函数实现单例，写伪代码" class="headerlink" title="用__new__()这种魔法函数实现单例，写伪代码"></a>用__new__()这种魔法函数实现单例，写伪代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age</span>):</span></span><br><span class="line">    self.name = name</span><br><span class="line">    self.age = age</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(cls, <span class="string">&#x27;instance&#x27;</span>):</span><br><span class="line">      cls.instance = <span class="built_in">super</span>().__new__(cls)</span><br><span class="line">    <span class="keyword">return</span> cls.instance</span><br><span class="line"> </span><br><span class="line">a = Person(<span class="string">&#x27;p1&#x27;</span>,<span class="number">21</span></span><br><span class="line">b = Person(<span class="string">&#x27;p2&#x27;</span>,<span class="number">22</span></span><br><span class="line">print(a == b, a.name == b.name)</span><br></pre></td></tr></table></figure>



<h2 id="场景题：设计服务器，服务器只开了一个端口，但要在一分钟内处理上万的请求，用Python该处理这种上万级的请求"><a href="#场景题：设计服务器，服务器只开了一个端口，但要在一分钟内处理上万的请求，用Python该处理这种上万级的请求" class="headerlink" title="场景题：设计服务器，服务器只开了一个端口，但要在一分钟内处理上万的请求，用Python该处理这种上万级的请求"></a>场景题：设计服务器，服务器只开了一个端口，但要在一分钟内处理上万的请求，用Python该处理这种上万级的请求</h2><ul>
<li><p>多核</p>
</li>
<li><p>对于计算密集型工作，可以利用 PyPy 的即时编译</p>
</li>
<li><p>新的微服务框架japronto 全新微服务框架，异步</p>
</li>
</ul>
<h2 id="浏览器输入URL全过程"><a href="#浏览器输入URL全过程" class="headerlink" title="浏览器输入URL全过程"></a>浏览器输入URL全过程</h2><ul>
<li>DNS 解析: 将域名解析成 IP 地址</li>
<li>TCP 连接：TCP 三次握手</li>
<li>发送 HTTP 请求</li>
<li>服务器处理请求并返回 HTTP 报文</li>
<li>浏览器解析渲染页面</li>
<li>断开连接：TCP 四次挥手</li>
</ul>
<h2 id="请求的响应速度过慢"><a href="#请求的响应速度过慢" class="headerlink" title="请求的响应速度过慢"></a>请求的响应速度过慢</h2><p>如何分析排除出具体原因（面试官提示说服务端的问题）</p>
<ul>
<li><p>服务端：</p>
</li>
<li><p>可能的原因一：服务器出口带宽不够用。这是一个很常见的瓶颈。一方面，可能是本身购买的服务器出口带宽就很小（企业购买带宽相当昂贵），一旦用户访问量上来了，并发量大了，自然均分给用户的出口带宽就更小了，所以某些用户的访问速度就会下降了很多。另一个，就是跨运营商网络导致带宽缩减，例如很多公司的网站（服务器）是放在电信的网络上的，而如果用户这边对接的是长城或者说联通的宽带，运营商之间网络传输在对接时是会有限制的，这就可能导致带宽的缩减。</p>
<p>  （2）可能原因二：服务器负载过大忙不过来，比如说CPU和内存消耗完了，这个容易理解，不展开。</p>
<p>  （3）可能原因三：网站的开发代码没写好，例如mysql语句没有进行优化，导致数据库的读写相当耗费时间。</p>
<p>  （4）可能原因四：数据库的瓶颈，也是很常见的一个瓶颈，这点跟上面第三个原因可以一起来说。当我们的数据库变得愈发庞大，比如好多G好多T这么大，那对于数据库的读写就会变得相当缓慢了，索引优化固然能提升一些效率，但数据库已经如此庞大的话，如果每次查询都对这么大的数据库进行全局查询，自然会很慢。这个学过数据库的话也是挺容易理解的。</p>
</li>
</ul>
<h2 id="如何分析数据库慢查询"><a href="#如何分析数据库慢查询" class="headerlink" title="如何分析数据库慢查询"></a>如何分析数据库慢查询</h2><p>explan提示的字段有哪些，全表扫描的话会type字段会显示什么</p>
<h2 id="程序里的每一个进程最多可以申请多少的空间"><a href="#程序里的每一个进程最多可以申请多少的空间" class="headerlink" title="程序里的每一个进程最多可以申请多少的空间"></a>程序里的每一个进程最多可以申请多少的空间</h2><p>2 ^ 64 减去系统占用</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvzhmqgas4j30kq08r74r.jpg" alt="img"></p>
<h2 id="多线程过多协程，如果卡死，想要定位出错的点，怎样判断整个进程的状况"><a href="#多线程过多协程，如果卡死，想要定位出错的点，怎样判断整个进程的状况" class="headerlink" title="多线程过多协程，如果卡死，想要定位出错的点，怎样判断整个进程的状况"></a>多线程过多协程，如果卡死，想要定位出错的点，怎样判断整个进程的状况</h2><h2 id="namespace和entrypoint"><a href="#namespace和entrypoint" class="headerlink" title="namespace和entrypoint"></a>namespace和entrypoint</h2><h2 id="slots-（）是用来定义什么的"><a href="#slots-（）是用来定义什么的" class="headerlink" title="__slots__（）是用来定义什么的"></a>__slots__（）是用来定义什么的</h2><h2 id="Python协程原理"><a href="#Python协程原理" class="headerlink" title="Python协程原理"></a>Python协程原理</h2><h2 id="Django框架设计思维，设计机制"><a href="#Django框架设计思维，设计机制" class="headerlink" title="Django框架设计思维，设计机制"></a>Django框架设计思维，设计机制</h2><h2 id="Mysql中B树和B-树的使用场景和区别"><a href="#Mysql中B树和B-树的使用场景和区别" class="headerlink" title="Mysql中B树和B+树的使用场景和区别"></a>Mysql中B树和B+树的使用场景和区别</h2><h2 id="定义一张表，这张表最多可以存多少条数据，这是由什么决定的"><a href="#定义一张表，这张表最多可以存多少条数据，这是由什么决定的" class="headerlink" title="定义一张表，这张表最多可以存多少条数据，这是由什么决定的"></a>定义一张表，这张表最多可以存多少条数据，这是由什么决定的</h2><h2 id="项目中如何保证数据库高可用，是否用到了主从机制"><a href="#项目中如何保证数据库高可用，是否用到了主从机制" class="headerlink" title="项目中如何保证数据库高可用，是否用到了主从机制"></a><a href="">项目</a>中如何保证数据库高可用，是否用到了主从机制</h2><h2 id="介绍项目，用户量增加后，系统原型可以从哪些地方进行改进，有参考业界其他类似需求的常见做法吗（无），项目中得到的最大收获"><a href="#介绍项目，用户量增加后，系统原型可以从哪些地方进行改进，有参考业界其他类似需求的常见做法吗（无），项目中得到的最大收获" class="headerlink" title="介绍项目，用户量增加后，系统原型可以从哪些地方进行改进，有参考业界其他类似需求的常见做法吗（无），项目中得到的最大收获"></a>介绍<a href="">项目</a>，用户量增加后，系统原型可以从哪些地方进行改进，有参考业界其他类似需求的常见做法吗（无），<a href="">项目</a>中得到的最大收获</h2><h2 id="装饰器，多个装饰器顺序问题"><a href="#装饰器，多个装饰器顺序问题" class="headerlink" title="装饰器，多个装饰器顺序问题"></a>装饰器，多个装饰器顺序问题</h2><h2 id="元类"><a href="#元类" class="headerlink" title="元类"></a>元类</h2><h2 id="类方法和普通方法和实例方法，平时怎么用的"><a href="#类方法和普通方法和实例方法，平时怎么用的" class="headerlink" title="类方法和普通方法和实例方法，平时怎么用的"></a>类方法和普通方法和实例方法，平时怎么用的</h2><p>实例方法：可以获取类属性、构造函数定义的变量，属于 method 类型。只能通过实例化调用。</p>
<p>静态方法：不能获取类属性、构造函数定义的变量，属于 function 类型。两种调用方式：类.方法名 ，实例化调用。</p>
<p>类方法 ：可以获取类属性，不能获取构造函数定义的变量，属于 method 类型。两种调用方式：类.方法名 ，实例化调用。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h2 id="队列和元组区别"><a href="#队列和元组区别" class="headerlink" title="队列和元组区别"></a>队列和元组区别</h2><p>队列 == list</p>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><h2 id="is和-区别"><a href="#is和-区别" class="headerlink" title="is和==区别"></a>is和==区别</h2><p>is比较的是id是不是一样，==比较的是值是不是一样。</p>
<p>Python中，万物皆对象！万物皆对象！万物皆对象！(很重要，重复3遍)</p>
<p>每个对象包含3个属性，id，type，value</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">b = a</span><br><span class="line">c = <span class="number">1</span></span><br><span class="line">d = <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">id</span>(a)   <span class="comment"># 35556792L</span></span><br><span class="line"><span class="built_in">id</span>(b)   <span class="comment"># 35556792L</span></span><br><span class="line"><span class="built_in">id</span>(c)   <span class="comment"># 35556792L</span></span><br><span class="line"><span class="built_in">id</span>(d)   <span class="comment"># 21253459L</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断a is b的时候，实际上比较的是id(a)==id(b)。结果为True</span></span><br><span class="line"><span class="comment"># a==b时候，实际上比较的是id(a)这个地址指向的值是不是和id(b)这个地址指向值一样</span></span><br></pre></td></tr></table></figure>

<h2 id="io的多路复用"><a href="#io的多路复用" class="headerlink" title="io的多路复用"></a>io的多路复用</h2><ul>
<li>IO 多路复用是一种同步IO模型，实现一个线程可以监视多个文件句柄；</li>
<li>一旦某个文件句柄就绪，就能够通知应用程序进行相应的读写操作；</li>
<li>没有文件句柄就绪就会阻塞应用程序，交出CPU。</li>
</ul>
<h2 id="进程通信方式"><a href="#进程通信方式" class="headerlink" title="进程通信方式"></a>进程通信方式</h2><ul>
<li><p>管道 grep</p>
</li>
<li><p>消息队列</p>
</li>
<li><p>共享内存：系统加载一个进程的时候，分配给进程的内存并不是实际物理内存，而是虚拟内存空间。那么我们可以让两个进程各自拿出一块虚拟地址空间来，然后映射到相同的物理内存中，这样，两个进程虽然有着独立的虚拟内存空间，但有一部分却是映射到相同的物理内存，这就完成了内存共享机制了。</p>
</li>
</ul>
<h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvzhy87hfoj30k008ygm3.jpg" alt="img"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvzhyk2tdlj30k009vjrx.jpg" alt="img"></p>
<h2 id="数组和链表的区别"><a href="#数组和链表的区别" class="headerlink" title="数组和链表的区别"></a>数组和<a href="">链表</a>的区别</h2><p>两种数据结构都属于线性表，数组占用的是一块连续的内存区，而链表在内存中，是分散的，因为是分散的（指针）</p>
<p><strong>数组和链表时间复杂度分别是O(1)与O(n)，方式一种是“随机访问”，一种是“顺序访问”。</strong></p>
<p>数组：使用下标访问‘</p>
<p>链表：使用指针顺序查找（单向链表）</p>
<h2 id="排序算法了解那些？时间复杂度？"><a href="#排序算法了解那些？时间复杂度？" class="headerlink" title="排序算法了解那些？时间复杂度？"></a><a href="">排序</a><a href="">算法</a>了解那些？时间复杂度？</h2><h2 id="口排一下快速排序吧"><a href="#口排一下快速排序吧" class="headerlink" title="口排一下快速排序吧"></a>口排一下快速<a href="">排序</a>吧</h2><h2 id="孤儿进程，僵尸进程，能否用kill杀掉僵尸进程，怎么查看僵尸进程"><a href="#孤儿进程，僵尸进程，能否用kill杀掉僵尸进程，怎么查看僵尸进程" class="headerlink" title="孤儿进程，僵尸进程，能否用kill杀掉僵尸进程，怎么查看僵尸进程"></a>孤儿进程，僵尸进程，能否用kill杀掉僵尸进程，怎么查看僵尸进程</h2><h3 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h3><ul>
<li><p>一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。</p>
</li>
<li><p>孤儿进程将被 <code>init 进程（进程号为 1）</code>所收养，并由 <code>init 进程</code>对它们完成状态收集工作。</p>
</li>
<li><p>由于孤儿进程会被<code> init 进程</code>收养，所以孤儿进程不会对系统造成危害。</p>
</li>
</ul>
<h3 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h3><ul>
<li><p>一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过 <code>wait()</code> 或 <code>waitpid()</code> 获取了子进程信息后才会释放。如果子进程退出，而父进程并没有调用 <code>wait()</code> 或 <code>waitpid()</code>，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵尸进程。</p>
</li>
<li><p>僵尸进程通过 ps 命令显示出来的状态为 Z（zombie）。</p>
</li>
<li><p>系统所能使用的进程号是有限的，如果产生大量僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。</p>
</li>
<li><p>要消灭系统中大量的僵尸进程，只需要将其父进程杀死，此时僵尸进程就会变成孤儿进程，从而被 init 进程所收养，这样 init 进程就会释放所有的僵尸进程所占有的资源，从而结束僵尸进程。</p>
</li>
</ul>
<h2 id="top命令"><a href="#top命令" class="headerlink" title="top命令"></a>top命令</h2><h2 id="netstat命令"><a href="#netstat命令" class="headerlink" title="netstat命令"></a>netstat命令</h2><h2 id="事务ACID"><a href="#事务ACID" class="headerlink" title="事务ACID"></a>事务ACID</h2><h2 id="开发过程中多进程共享文件的问题-加锁-，加什么锁"><a href="#开发过程中多进程共享文件的问题-加锁-，加什么锁" class="headerlink" title="开发过程中多进程共享文件的问题(加锁)，加什么锁"></a>开发过程中多进程共享文件的问题(加锁)，加什么锁</h2><p> flock 文件锁</p>
<h2 id="深信服这在防护墙那有黑名单，如何快速匹配一个（hash表）如果数量很大呢（分治，在hash）"><a href="#深信服这在防护墙那有黑名单，如何快速匹配一个（hash表）如果数量很大呢（分治，在hash）" class="headerlink" title="深信服这在防护墙那有黑名单，如何快速匹配一个（hash表）如果数量很大呢（分治，在hash）"></a><a href="">深信服</a>这在防护墙那有黑名单，如何快速匹配一个（hash表）如果数量很大呢（分治，在hash）</h2><p>海量日志，文件太大，IP地址最多有2^32=4G，无法装入内存，，将这个大文件（hash映射：可以取模00）分成多个小文件（如1000）。</p>
<p>对每个小文件进行hash统计，hash_map(ip,value),得到每个文件出现频率最多的ip</p>
<p>将这些频率最高的ip进行统计，然后排序得出最大值，这里可以采用堆/快速/归并，但只取一个最大值的话可以采用堆排序。</p>
<h2 id="多线程进程协程"><a href="#多线程进程协程" class="headerlink" title="多线程进程协程"></a>多线程进程协程</h2><h2 id="静态实例类方法"><a href="#静态实例类方法" class="headerlink" title="静态实例类方法"></a>静态实例类方法</h2><h2 id="生成器迭代器"><a href="#生成器迭代器" class="headerlink" title="生成器迭代器"></a>生成器迭代器</h2><h2 id="垃圾回收-1"><a href="#垃圾回收-1" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><h2 id="列表元组"><a href="#列表元组" class="headerlink" title="列表元组"></a>列表元组</h2><h2 id="python的数据结构有哪些"><a href="#python的数据结构有哪些" class="headerlink" title="python的数据结构有哪些"></a>python的数据结构有哪些</h2><h2 id="python切片"><a href="#python切片" class="headerlink" title="python切片"></a>python切片</h2><h2 id="元组和列表的异同"><a href="#元组和列表的异同" class="headerlink" title="元组和列表的异同"></a>元组和列表的异同</h2><h2 id="手撕快排，并解释"><a href="#手撕快排，并解释" class="headerlink" title="手撕快排，并解释"></a>手撕快排，并解释</h2><h2 id="python的内存管理机制"><a href="#python的内存管理机制" class="headerlink" title="python的内存管理机制"></a>python的内存管理机制</h2><h2 id="发生内存泄漏如何排查"><a href="#发生内存泄漏如何排查" class="headerlink" title="发生内存泄漏如何排查"></a>发生内存泄漏如何排查</h2><h2 id="简述进程，线程，和协程"><a href="#简述进程，线程，和协程" class="headerlink" title="简述进程，线程，和协程"></a>简述进程，线程，和协程</h2><h2 id="Python垃圾回收机制，内存机制？"><a href="#Python垃圾回收机制，内存机制？" class="headerlink" title="Python垃圾回收机制，内存机制？"></a>Python垃圾回收机制，内存机制？</h2><h2 id="Mysql语句如何优化？B树和B＋树区别"><a href="#Mysql语句如何优化？B树和B＋树区别" class="headerlink" title="Mysql语句如何优化？B树和B＋树区别"></a>Mysql语句如何优化？B树和B＋树区别</h2><h2 id="new-和-init-的区别？"><a href="#new-和-init-的区别？" class="headerlink" title="__new__和__init__的区别？"></a>__new__和__init__的区别？</h2><p>作者：初识CV<br>链接：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/356064986">https://zhuanlan.zhihu.com/p/356064986</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h2 id="1-new-函数"><a href="#1-new-函数" class="headerlink" title="1. __ new__函数"></a>1. __ new__函数</h2><p><strong>new</strong>() 是一种负责创建类实例的静态方法，它无需使用 staticmethod 装饰器修饰，且该方法会优先 <strong>init</strong>() 初始化方法被调用。</p>
<p>一般情况下，覆写 <strong>new</strong>() 的实现将会使用合适的参数调用其超类的 super().<strong>new</strong>()，并在返回之前修改实例。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class demoClass:</span><br><span class="line">    instances_created &#x3D; 0</span><br><span class="line">    def __new__(cls,*args,**kwargs):</span><br><span class="line">        print(&quot;__new__():&quot;,cls,args,kwargs)</span><br><span class="line">        instance &#x3D; super().__new__(cls)</span><br><span class="line">        instance.number &#x3D; cls.instances_created</span><br><span class="line">        cls.instances_created +&#x3D; 1</span><br><span class="line">        return instance</span><br><span class="line">    def __init__(self,attribute):</span><br><span class="line">        print(&quot;__init__():&quot;,self,attribute)</span><br><span class="line">        self.attribute &#x3D; attribute</span><br><span class="line">test1 &#x3D; demoClass(&quot;abc&quot;)</span><br><span class="line">test2 &#x3D; demoClass(&quot;xyz&quot;)</span><br><span class="line">print(test1.number,test1.instances_created)</span><br><span class="line">print(test2.number,test2.instances_created)</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__new__(): &lt;class &#39;__main__.demoClass&#39;&gt; (&#39;abc&#39;,) &#123;&#125;</span><br><span class="line">__init__(): &lt;__main__.demoClass object at 0x0000025650FACF28&gt; abc</span><br><span class="line">__new__(): &lt;class &#39;__main__.demoClass&#39;&gt; (&#39;xyz&#39;,) &#123;&#125;</span><br><span class="line">__init__(): &lt;__main__.demoClass object at 0x000002565FFC4CF8&gt; xyz</span><br><span class="line">0 2</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure>

<p><strong>new</strong>() 通常会返回该类的一个实例，但有时也可能会返回其他类的实例，如果发生了这种情况，则会跳过对 <strong>init</strong>() 方法的调用。而在某些情况下（比如需要修改不可变类实例（Python 的某些内置类型）的创建行为），利用这一点会事半功倍。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class nonZero(int):</span><br><span class="line">    def __new__(cls,value):</span><br><span class="line">        return super().__new__(cls,value) if value !&#x3D; 0 else None</span><br><span class="line">    def __init__(self,skipped_value):</span><br><span class="line">        #此例中会跳过此方法</span><br><span class="line">        print(&quot;__init__()&quot;)</span><br><span class="line">        super().__init__()</span><br><span class="line">print(type(nonZero(-12)))</span><br><span class="line">print(type(nonZero(0)))</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__init__()</span><br><span class="line">&lt;class &#39;__main__.nonZero&#39;&gt;</span><br><span class="line">&lt;class &#39;NoneType&#39;&gt;</span><br></pre></td></tr></table></figure>

<p>那么，什么情况下使用 <strong>new</strong>() 呢？答案很简单，在 <strong>init</strong>() 不够用的时候。</p>
<p>例如，前面例子中对 Python 不可变的内置类型（如 int、str、float 等）进行了子类化，这是因为一旦创建了这样不可变的对象实例，就无法在 <strong>init</strong>() 方法中对其进行修改。</p>
<p>有些读者可能会认为，<strong>new</strong>() 对执行重要的对象初始化很有用，如果用户忘记使用 super()，可能会漏掉这一初始化。虽然这听上去很合理，但有一个主要的缺点，即如果使用这样的方法，那么即便初始化过程已经是预期的行为，程序员明确跳过初始化步骤也会变得更加困难。不仅如此，它还破坏了“<strong>init</strong>() 中执行所有初始化工作”的潜规则。</p>
<p>注意，由于 <strong>new</strong>() 不限于返回同一个类的实例，所以很容易被滥用，不负责任地使用这种方法可能会对代码有害，所以要谨慎使用。一般来说，对于特定问题，最好搜索其他可用的解决方案，最好不要影响对象的创建过程，使其违背程序员的预期。比如说，前面提到的覆写不可变类型初始化的例子，完全可以用工厂方法（一种设计模式）来替代。</p>
<h2 id="2-init"><a href="#2-init" class="headerlink" title="2. __ init__()"></a>2. __ init__()</h2><p><strong>所有类的超类object</strong>，有一个默认包含pass的__ init __()实现，这个函数会在对象初始化的时候调用，我们可以选择实现，也可以选择不实现，一般建议是实现的，不实现对象属性就不会被初始化。</p>
<p>**<strong>init</strong>() 方法可以包含多个参数，但必须包含一个名为 self 的参数，且必须作为第一个参数。**也就是说，类的构造方法最少也要有一个 self 参数，仅包含 self 参数的 <strong>init</strong>() 构造方法，又称为类的默认构造方法。例如，仍以 TheFirstDemo 类为例，添加构造方法的代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class TheFirstDemo:</span><br><span class="line">        &#39;&#39;&#39;这是一个学习Python定义的第一个类&#39;&#39;&#39;</span><br><span class="line"></span><br><span class="line">        # 构造方法</span><br><span class="line">        def __init__(self):</span><br><span class="line">                print(&quot;调用构造方法&quot;)</span><br><span class="line"></span><br><span class="line">        # 下面定义了一个类属性</span><br><span class="line">        add &#x3D; &#39;http:&#x2F;&#x2F;c.biancheng.net&#39;</span><br><span class="line"></span><br><span class="line">        # 下面定义了一个say方法</span><br><span class="line">        def say(self, content):</span><br><span class="line">                print(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">        result &#x3D; TheFirstDemo()</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">调用构造方法</span><br></pre></td></tr></table></figure>

<p>在创建 result  这个对象时，隐式调用了我们手动创建的 <strong>init</strong>() 构造方法。</p>
<p>不仅如此，在 <strong>init</strong>() 构造方法中，除了 self 参数外，还可以自定义一些参数，参数之间使用逗号“,”进行分割。例如，下面的代码在创建 <strong>init</strong>() 方法时，额外指定了 2 个参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class CLanguage:</span><br><span class="line">    &#39;&#39;&#39;这是一个学习Python定义的一个类&#39;&#39;&#39;</span><br><span class="line">    def __init__(self,name,add):</span><br><span class="line">        print(name,&quot;的网址为:&quot;,add)</span><br><span class="line"></span><br><span class="line">#创建 add 对象，并传递参数给构造函数</span><br><span class="line">add &#x3D; CLanguage(&quot;C语言中文网&quot;,&quot;http:&#x2F;&#x2F;c.biancheng.net&quot;)</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C语言中文网 的网址为: http:&#x2F;&#x2F;c.biancheng.net</span><br></pre></td></tr></table></figure>

<p>可以看到，虽然构造方法中有 self、name、add 3 个参数，但实际需要传参的仅有 name 和 add，也就是说，self 不需要手动传递参数。</p>
<h2 id="出现bug怎么去找到原因？"><a href="#出现bug怎么去找到原因？" class="headerlink" title="出现bug怎么去找到原因？"></a>出现bug怎么去找到原因？</h2><h2 id="过河问题，ABCD四个人，单独过河分别需要1，2，5，10，最多两个人同时过，并且只有一个手电筒，每次都需要电筒，两人过河按慢的时间算，问最少几分钟？（17分钟）如果有n个人过河，每个人过河的时间不定，怎么用算法实现"><a href="#过河问题，ABCD四个人，单独过河分别需要1，2，5，10，最多两个人同时过，并且只有一个手电筒，每次都需要电筒，两人过河按慢的时间算，问最少几分钟？（17分钟）如果有n个人过河，每个人过河的时间不定，怎么用算法实现" class="headerlink" title="过河问题，ABCD四个人，单独过河分别需要1，2，5，10，最多两个人同时过，并且只有一个手电筒，每次都需要电筒，两人过河按慢的时间算，问最少几分钟？（17分钟）如果有n个人过河，每个人过河的时间不定，怎么用算法实现"></a>过河问题，ABCD四个人，单独过河分别需要1，2，5，10，最多两个人同时过，并且只有一个手电筒，每次都需要电筒，两人过河按慢的时间算，问最少几分钟？（17分钟）如果有n个人过河，每个人过河的时间不定，怎么用<a href="">算法</a>实现</h2><h2 id="从一亿个ip找出指定的IP。"><a href="#从一亿个ip找出指定的IP。" class="headerlink" title="从一亿个ip找出指定的IP。"></a>从一亿个ip找出指定的IP。</h2><h2 id="列表和元组，字典的底层实现"><a href="#列表和元组，字典的底层实现" class="headerlink" title="列表和元组，字典的底层实现"></a>列表和元组，字典的底层实现</h2><p>数组 哈希表</p>
<h2 id="说了解web常见的漏洞原理、利用方式）"><a href="#说了解web常见的漏洞原理、利用方式）" class="headerlink" title="说了解web常见的漏洞原理、利用方式）"></a>说了解web常见的漏洞原理、利用方式）</h2><h2 id="说说SMB协议（不是很了解）"><a href="#说说SMB协议（不是很了解）" class="headerlink" title="说说SMB协议（不是很了解）"></a>说说SMB协议（不是很了解）</h2><h2 id="详细介绍了自己的一个项目（协议相关）"><a href="#详细介绍了自己的一个项目（协议相关）" class="headerlink" title="详细介绍了自己的一个项目（协议相关）"></a>详细介绍了自己的一个<a target="_blank" rel="noopener" href="https://www.nowcoder.com/jump/super-jump/word?word=%E9%A1%B9%E7%9B%AE">项目</a>（协议相关）</h2><h2 id="协议常见的攻击"><a href="#协议常见的攻击" class="headerlink" title="协议常见的攻击"></a>协议常见的攻击</h2><p>（中间人、重放 的原理、防御）</p>
<p>一般的TCP网络攻击</p>
<p>SYN Flood  - 可能是最古老的，但用作大多数攻击向量。攻击者正在向服务器发送大量SYN数据包。 IP不必是真实的，因为攻击不需要调查返回流量。通常这是一个无效的IP。这使得难以理解攻击者的来源并允许攻击者保持匿名。 SYN攻击技术多年来不断发展。</p>
<p>SYN攻击背后的主要思想是发送大量SYN数据包以消耗TCP \ IP堆栈上分配的内存。多年来，SYN攻击变得更加复杂。最新的变种是Tsunami SYN Flood Attack。这会使用TCP SYN位的<a target="_blank" rel="noopener" href="https://cloud.tencent.com/solution/bigdata?from=10680">大数据</a>包使Internet管道饱和，从而导致TCP \ IP堆栈的并行损坏。</p>
<p>除了SYN泛洪之外，TCP网络攻击还会针对各种攻击使用所有其他TCP，ACK泛洪，RST洪水，推送洪水，FIN洪水及其组合。只要存在腐败可能，攻击者就会尽一切努力。</p>
<p>HTTP L7攻击非常普遍。 HTTP L7攻击与上述网络攻击之间的主要区别在于HTTP事务需要有效的IP。 TCP握手不能IP欺骗HTTP请求，因为IP需要接收数据包并进行响应。如果没有IP，则无法建立连接。对于想要使用HTTP攻击的攻击者来说，这种差异非常困难。然而，在今天的世界中，对于最近的IoT僵尸网络攻击目标来说，拥有多个真实IP地址并不是一项不可能完成的任务。当从真实IP地址建立连接时，存在一些攻击选项。</p>
<p>垃圾洪水 - 最简单的攻击方式是打开与HTTP端口（通常是端口80或443）的连接并发送垃圾二进制数据。这种类型的攻击通常会忽略缓解，因为服务器和保护它的安全设备需要“有效”的HTTP流量。通常，此攻击的目的是将缓存设备中的Web服务器的内部缓冲区和队列置于它们之前。攻击方法很简单，但这种攻击可以用来使互联网管道饱和。</p>
<p>GET Flood  -  HTTP协议最常见的用途是GET请求。使用GET请求方法，例如GET泛洪，但数量很大。攻击者试图停止向服务器提供合法的GET请求。通常，此攻击根据HTTP协议标准使用RFC fcompliancy检查来防止减少。</p>
<p>其他HTTP方法 - 除了通常的GET方法之外，HTTP协议还允许其他方法，例如HEAD和POST。使用这些方法的攻击通常与GET泛洪一起使用，以试图攻击服务器代码的异常区域。通常，POST请求比GET请求大，因此大型POST请求更有可能通过缓解器来了解服务器，保护服务器比大型GET请求更可疑。这会增加服务器上的内存消耗和拒绝服务。</p>
<p>XSS攻击：跨站脚本攻击(Cross-Site Scripting)，为了不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS。XSS是一种常见的web安全漏洞，它允许攻击者将恶意代码植入到提供给其它用户使用的页面中。不同于大多数攻击(一般只涉及攻击者和受害者)，XSS涉及到三方，即攻击者、客户端与Web应用。XSS的攻击目标是为了盗取存储在客户端的cookie或者其他网站用于识别客户端身份的敏感信息。一旦获取到合法用户的信息后，攻击者甚至可以假冒合法用户与网站进行交互。</p>
<h2 id="什么是SQL注入"><a href="#什么是SQL注入" class="headerlink" title="什么是SQL注入"></a>什么是SQL注入</h2><p>攻击者成功的向服务器提交恶意的SQL查询代码，程序在接收后错误的将攻击者的输入作为查询语句的一部分执行，导致原始的查询逻辑被改变，额外的执行了攻击者精心构造的恶意代码。</p>
<p>举例：<code>&#39; OR &#39;1&#39;=&#39;1</code></p>
<p>这是最常见的 SQL注入攻击，当我们输如用户名 admin ，然后密码输如<code>&#39; OR &#39;1&#39;=1=&#39;1</code>的时候，我们在查询用户名和密码是否正确的时候，本来要执行的是<code>SELECT * FROM user WHERE username=&#39;&#39; and password=&#39;&#39;</code>,经过参数拼接后，会执行 SQL语句 <code>SELECT * FROM user WHERE username=&#39;&#39; and password=&#39;&#39; OR &#39;1&#39;=&#39;1&#39;</code>，这个时候1=1是成立，自然就跳过验证了。</p>
<p>CSRF（Cross-site request forgery），中文名称：跨站请求伪造，也被称为：one click attack/session riding，缩写为：CSRF/XSRF。</p>
<p>你这可以这么理解CSRF攻击：攻击者盗用了你的身份，以你的名义发送恶意请求。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账……造成的问题包括：个人隐私泄露以及财产安全。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvznzgedadj30t80ghn1s.jpg" alt="img"></p>
<h2 id="b树、b-树、红黑树"><a href="#b树、b-树、红黑树" class="headerlink" title="b树、b+树、红黑树"></a><strong>b树、b+树、红黑树</strong></h2><h2 id="快排和冒泡的比较（口述分别怎么实现的）"><a href="#快排和冒泡的比较（口述分别怎么实现的）" class="headerlink" title="快排和冒泡的比较（口述分别怎么实现的）"></a>快排和冒泡的比较（口述分别怎么实现的）</h2><h2 id="Try-except-else-finally中的问题，try中使用return了还会不会执行else-finally"><a href="#Try-except-else-finally中的问题，try中使用return了还会不会执行else-finally" class="headerlink" title="Try except else finally中的问题，try中使用return了还会不会执行else  finally"></a>Try except else finally中的问题，try中使用return了还会不会执行else  finally</h2><p>以运行结果为准，说明无论try里执行什么，<strong>即使是return，也会调用finally的</strong>。</p>
<p><strong>如果try中没有异常</strong>，那么except部分将跳过，<strong>执行else中的语句</strong>。（前提是try里没有返回值）</p>
<p>finally是无论是否有异常，最后都要做的一些事情。”（无论try里是否有返回值）</p>
<p>这里补充一句，在<strong>含有return的情况下，并不会阻碍finally的执行</strong>。（但是会阻碍else）</p>
<h2 id="python内存管理"><a href="#python内存管理" class="headerlink" title="python内存管理"></a>python内存管理</h2><p>（详细介绍了GC三种方式以及底层实现，和内存池相关）</p>
<h2 id="装饰器有用过么？（staticmethod和自己写的时间戳装饰器）"><a href="#装饰器有用过么？（staticmethod和自己写的时间戳装饰器）" class="headerlink" title="装饰器有用过么？（staticmethod和自己写的时间戳装饰器）"></a>装饰器有用过么？（staticmethod和自己写的时间戳装饰器）</h2><h2 id="进一步：-staticmethod讲一下？和其他类成员函数的区别？"><a href="#进一步：-staticmethod讲一下？和其他类成员函数的区别？" class="headerlink" title="进一步： staticmethod讲一下？和其他类成员函数的区别？"></a>进一步： staticmethod讲一下？和其他类成员函数的区别？</h2><h2 id="用过什么库？各自用来干什么？（答：numpy，os，sys，re，collections）"><a href="#用过什么库？各自用来干什么？（答：numpy，os，sys，re，collections）" class="headerlink" title="用过什么库？各自用来干什么？（答：numpy，os，sys，re，collections）"></a>用过什么库？各自用来干什么？（答：numpy，os，sys，re，collections）</h2><h2 id="re用过？讲讲用过哪些正则？（re-search-amp-re-match）"><a href="#re用过？讲讲用过哪些正则？（re-search-amp-re-match）" class="headerlink" title="re用过？讲讲用过哪些正则？（re.search &amp; re.match）"></a>re用过？讲讲用过哪些正则？（re.search &amp; re.match）</h2><h2 id="上面两者的区别？"><a href="#上面两者的区别？" class="headerlink" title="上面两者的区别？"></a>上面两者的区别？</h2><h2 id="深浅拷贝？详细说一下？"><a href="#深浅拷贝？详细说一下？" class="headerlink" title="深浅拷贝？详细说一下？"></a>深浅拷贝？详细说一下？</h2><h2 id="set了解么？和list的区别？底层如何实现的？（哈希map）"><a href="#set了解么？和list的区别？底层如何实现的？（哈希map）" class="headerlink" title="set了解么？和list的区别？底层如何实现的？（哈希map）"></a>set了解么？和list的区别？底层如何实现的？（哈希map）</h2><p>哈希映射</p>
<h2 id="类的继承了解么？项目里面有没有涉及到？"><a href="#类的继承了解么？项目里面有没有涉及到？" class="headerlink" title="类的继承了解么？项目里面有没有涉及到？"></a>类的继承了解么？<a href="">项目</a>里面有没有涉及到？</h2><p>Python中类的继承也就是一个类继承另一个类的话，便可以拥有所继承类的所有属性和方法，此时使用起来不仅方便且节省代码量。</p>
<p> <strong>Python单继承</strong></p>
<h2 id="TCP和UDP这个知道的吧？"><a href="#TCP和UDP这个知道的吧？" class="headerlink" title="TCP和UDP这个知道的吧？"></a>TCP和UDP这个知道的吧？</h2><p>（答：老熟人了）那好我问你个不常见的吧（我：危）， ARP协议了解嘛，具体的运作方式？（刚好面<a href="">华为</a>的时候看过，甚至答了RARP）</p>
<h2 id="第二次向同一个主机发送数据的时候还需要用ARP吗？（不用，有缓存）"><a href="#第二次向同一个主机发送数据的时候还需要用ARP吗？（不用，有缓存）" class="headerlink" title="第二次向同一个主机发送数据的时候还需要用ARP吗？（不用，有缓存）"></a>第二次向同一个主机发送数据的时候还需要用ARP吗？（不用，有缓存）</h2><h2 id="线程进程了解嘛？进程的调度？通讯方式？（经典八股文）项目里面有实现这些通讯方式嘛？（？？？）"><a href="#线程进程了解嘛？进程的调度？通讯方式？（经典八股文）项目里面有实现这些通讯方式嘛？（？？？）" class="headerlink" title="线程进程了解嘛？进程的调度？通讯方式？（经典八股文）项目里面有实现这些通讯方式嘛？（？？？）"></a>线程进程了解嘛？进程的调度？通讯方式？（经典八股文）<a href="">项目</a>里面有实现这些通讯方式嘛？（？？？）</h2><h2 id="python用哪个模块实现多线程？（import-thread）项目中有涉及多线程嘛？（无···）"><a href="#python用哪个模块实现多线程？（import-thread）项目中有涉及多线程嘛？（无···）" class="headerlink" title="python用哪个模块实现多线程？（import thread）项目中有涉及多线程嘛？（无···）"></a>python用哪个模块实现多线程？（import thread）<a href="">项目</a>中有涉及多线程嘛？（无···）</h2><h2 id="数据结构了解嘛？（本科软工）讲一下数组和链表的区别？（送分题）插入数据的话二者的复杂度？"><a href="#数据结构了解嘛？（本科软工）讲一下数组和链表的区别？（送分题）插入数据的话二者的复杂度？" class="headerlink" title="数据结构了解嘛？（本科软工）讲一下数组和链表的区别？（送分题）插入数据的话二者的复杂度？"></a>数据结构了解嘛？（本科软工）讲一下数组和<a href="">链表</a>的区别？（送分题）插入数据的话二者的复杂度？</h2><h2 id="排序和查找算法了解嘛？那些排序算法复杂度是nlogn？"><a href="#排序和查找算法了解嘛？那些排序算法复杂度是nlogn？" class="headerlink" title="排序和查找算法了解嘛？那些排序算法复杂度是nlogn？"></a><a href="">排序</a>和查找<a href="">算法</a>了解嘛？那些<a href="">排序</a><a href="">算法</a>复杂度是nlogn？</h2><h2 id="你觉得Python语言有什么特性呢？"><a href="#你觉得Python语言有什么特性呢？" class="headerlink" title="你觉得Python语言有什么特性呢？"></a>你觉得Python语言有什么特性呢？</h2><h2 id="解释性语言和编译性语言的区别"><a href="#解释性语言和编译性语言的区别" class="headerlink" title="解释性语言和编译性语言的区别"></a>解释性语言和编译性语言的区别</h2><h2 id="有了解Python虚拟机吗？（回答不了解，只知道Python解释器），那你说一下解释器吧"><a href="#有了解Python虚拟机吗？（回答不了解，只知道Python解释器），那你说一下解释器吧" class="headerlink" title="有了解Python虚拟机吗？（回答不了解，只知道Python解释器），那你说一下解释器吧"></a>有了解Python虚拟机吗？（回答不了解，只知道Python解释器），那你说一下解释器吧</h2><h2 id="解释器主要的功能是什么？"><a href="#解释器主要的功能是什么？" class="headerlink" title="解释器主要的功能是什么？"></a>解释器主要的功能是什么？</h2><h2 id="CPython"><a href="#CPython" class="headerlink" title="CPython"></a><strong>CPython</strong></h2><p>当从Python官方网站下载并安装好Python2.7后，就直接获得了一个官方版本的解释器：Cpython，这个解释器是用C语言开发的，所以叫CPython，在命名行下运行python，就是启动CPython解释器，CPython是使用最广的Python解释器。</p>
<h2 id="IPython"><a href="#IPython" class="headerlink" title="IPython"></a>IPython</h2><p>IPython是基于CPython之上的一个交互式解释器，也就是说，IPython只是在交互方式上有所增强，但是执行Python代码的功能和CPython是完全一样的，好比很多国产浏览器虽然外观不同，但内核其实是调用了IE。</p>
<h2 id="PyPy"><a href="#PyPy" class="headerlink" title="PyPy"></a>PyPy</h2><p>PyPy是另一个Python解释器，它的目标是执行速度，PyPy采用JIT技术，对Python代码进行动态编译，所以可以显著提高Python代码的执行速度。</p>
<h2 id="Jython"><a href="#Jython" class="headerlink" title="Jython"></a>Jython</h2><p>Jython是运行在Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行。</p>
<h2 id="IronPython"><a href="#IronPython" class="headerlink" title="IronPython"></a>IronPython</h2><p>IronPython和Jython类似，只不过IronPython是运行在微软.Net平台上的Python解释器，可以直接把Python代码编译成.Net的字节码。</p>
<h2 id="GIL锁有了解吗，解释一下"><a href="#GIL锁有了解吗，解释一下" class="headerlink" title="GIL锁有了解吗，解释一下"></a>GIL锁有了解吗，解释一下</h2><h2 id="协程和线程之间的区别"><a href="#协程和线程之间的区别" class="headerlink" title="协程和线程之间的区别"></a>协程和线程之间的区别</h2><h2 id="进程切换和线程切换的区别"><a href="#进程切换和线程切换的区别" class="headerlink" title="进程切换和线程切换的区别"></a>进程切换和线程切换的区别</h2><h2 id="Python函数声明中有三种类型的参数，说一下区别（听题没听清楚，以为问的三种函数类型，面试官指正了问的是三种参数类型，反应过来后就重答了一下）"><a href="#Python函数声明中有三种类型的参数，说一下区别（听题没听清楚，以为问的三种函数类型，面试官指正了问的是三种参数类型，反应过来后就重答了一下）" class="headerlink" title="Python函数声明中有三种类型的参数，说一下区别（听题没听清楚，以为问的三种函数类型，面试官指正了问的是三种参数类型，反应过来后就重答了一下）"></a>Python函数声明中有三种类型的参数，说一下区别（听题没听清楚，以为问的三种函数类型，面试官指正了问的是三种参数类型，反应过来后就重答了一下）</h2><h2 id="说一下你知道的Django组件"><a href="#说一下你知道的Django组件" class="headerlink" title="说一下你知道的Django组件"></a>说一下你知道的Django组件</h2><h2 id="Python中的迭代器是怎么用的"><a href="#Python中的迭代器是怎么用的" class="headerlink" title="Python中的迭代器是怎么用的"></a>Python中的迭代器是怎么用的</h2><h2 id="你是怎么理解线程安全的"><a href="#你是怎么理解线程安全的" class="headerlink" title="你是怎么理解线程安全的"></a>你是怎么理解线程安全的</h2><h2 id="有哪些进程间通信方式"><a href="#有哪些进程间通信方式" class="headerlink" title="有哪些进程间通信方式"></a>有哪些进程间通信方式</h2><h2 id="列表去重"><a href="#列表去重" class="headerlink" title="列表去重"></a>列表去重</h2><h2 id="自己实现set类，应该如何去实现"><a href="#自己实现set类，应该如何去实现" class="headerlink" title="自己实现set类，应该如何去实现"></a>自己实现set类，应该如何去实现</h2><h2 id="有写过单元测试吗（回答没写过），那你平时是怎么调试的（回答的打断点debug），有在Linux上调试过吗（无）"><a href="#有写过单元测试吗（回答没写过），那你平时是怎么调试的（回答的打断点debug），有在Linux上调试过吗（无）" class="headerlink" title="有写过单元测试吗（回答没写过），那你平时是怎么调试的（回答的打断点debug），有在Linux上调试过吗（无）"></a>有写过单元测试吗（回答没写过），那你平时是怎么调试的（回答的打断点debug），有在Linux上调试过吗（无）</h2><h2 id="数据结构这一块你比较熟悉哪个，或者算法（回答都还可以），那么树的使用场景有哪些（答了一些场景），比如红黑树一般会在哪里使用呢（不知道）"><a href="#数据结构这一块你比较熟悉哪个，或者算法（回答都还可以），那么树的使用场景有哪些（答了一些场景），比如红黑树一般会在哪里使用呢（不知道）" class="headerlink" title="数据结构这一块你比较熟悉哪个，或者算法（回答都还可以），那么树的使用场景有哪些（答了一些场景），比如红黑树一般会在哪里使用呢（不知道）"></a>数据结构这一块你比较熟悉哪个，或者<a href="">算法</a>（回答都还可以），那么树的使用场景有哪些（答了一些场景），比如<a href="">红黑树</a>一般会在哪里使用呢（不知道）</h2><h2 id="在100个数中找第K大的数，如何实现"><a href="#在100个数中找第K大的数，如何实现" class="headerlink" title="在100个数中找第K大的数，如何实现"></a>在100个数中找第K大的数，如何实现</h2><p>（答的快排分治，用K和基准值比较决定往左分支或右分支进行单支递归），还有其他的思路吗（思考后说了大根堆），讲一下大根堆是什么（讲了大根堆的实现原理）</p>
<h2 id="Python还有哪些是你比较熟悉的，是我刚才没有问到的？"><a href="#Python还有哪些是你比较熟悉的，是我刚才没有问到的？" class="headerlink" title="Python还有哪些是你比较熟悉的，是我刚才没有问到的？"></a>Python还有哪些是你比较熟悉的，是我刚才没有问到的？</h2><p>（答了列表元组和字典的底层实现原理），那你说一下字典的底层原理吧（讲了3.6前后的字典原理区别）</p>
<h2 id="Linux内核熟悉吗（不熟悉），Linux常规使用（不太用）"><a href="#Linux内核熟悉吗（不熟悉），Linux常规使用（不太用）" class="headerlink" title="Linux内核熟悉吗（不熟悉），Linux常规使用（不太用）"></a>Linux内核熟悉吗（不熟悉），Linux常规使用（不太用）</h2><h2 id="网络这一块熟悉吗，我在浏览器上输入URL，它的请求过程是怎样的"><a href="#网络这一块熟悉吗，我在浏览器上输入URL，它的请求过程是怎样的" class="headerlink" title="网络这一块熟悉吗，我在浏览器上输入URL，它的请求过程是怎样的"></a>网络这一块熟悉吗，我在浏览器上输入URL，它的请求过程是怎样的</h2><h2 id="IP层分片重组是用来做什么的"><a href="#IP层分片重组是用来做什么的" class="headerlink" title="IP层分片重组是用来做什么的"></a>IP层分片重组是用来做什么的</h2><p>1.1 服务器UDP程序发2000 byte 数据，以一整块的方式到IP层</p>
<p>1.2 IP MTU = 1500，2000 byte 被分成两片</p>
<h2 id="TCP拥塞控制是怎么做的"><a href="#TCP拥塞控制是怎么做的" class="headerlink" title="TCP拥塞控制是怎么做的"></a>TCP拥塞控制是怎么做的</h2><h2 id="文件系统中的软链接知道是什么吗（不知道）"><a href="#文件系统中的软链接知道是什么吗（不知道）" class="headerlink" title="文件系统中的软链接知道是什么吗（不知道）"></a>文件系统中的软链接知道是什么吗（不知道）</h2><h2 id="现在有一个任务，最多只有10个线程在执行，如何实现？"><a href="#现在有一个任务，最多只有10个线程在执行，如何实现？" class="headerlink" title="现在有一个任务，最多只有10个线程在执行，如何实现？"></a>现在有一个任务，最多只有10个线程在执行，如何实现？</h2><p>（答了线程池），线程池具体怎么实现？那如果池子满了，其他任务该如何处理？还有别的思路吗？（要求提示一下，面试官提示了用队列去实现，答了双端队列）</p>
<h2 id="Python中使用锁是不是比较少？（是的）"><a href="#Python中使用锁是不是比较少？（是的）" class="headerlink" title="Python中使用锁是不是比较少？（是的）"></a>Python中使用锁是不是比较少？（是的）</h2><h2 id="如果我两个主机网络不通了，该如何排查？"><a href="#如果我两个主机网络不通了，该如何排查？" class="headerlink" title="如果我两个主机网络不通了，该如何排查？"></a>如果我两个主机网络不通了，该如何排查？</h2><h2 id="为什么需要用nginx反向代理"><a href="#为什么需要用nginx反向代理" class="headerlink" title="为什么需要用nginx反向代理"></a>为什么需要用nginx反向代理</h2><h2 id="nginx如何实现负载均衡"><a href="#nginx如何实现负载均衡" class="headerlink" title="nginx如何实现负载均衡"></a>nginx如何实现负载均衡</h2><h2 id="通过论文，你觉得导师为什么能快速想到你想不到的idea，导师是如何达到这样的高度的"><a href="#通过论文，你觉得导师为什么能快速想到你想不到的idea，导师是如何达到这样的高度的" class="headerlink" title="通过论文，你觉得导师为什么能快速想到你想不到的idea，导师是如何达到这样的高度的"></a>通过论文，你觉得导师为什么能快速想到你想不到的idea，导师是如何达到这样的高度的</h2><h2 id="场景题，双十一高并发，阿里架构师推出的产品是怎么做的"><a href="#场景题，双十一高并发，阿里架构师推出的产品是怎么做的" class="headerlink" title="场景题，双十一高并发，阿里架构师推出的产品是怎么做的"></a>场景题，双十一高并发，阿里架构师推出的产品是怎么做的</h2><p>给你做能想到哪些技术难点（答了两个点，面试官问还有别的点吗，提示了数据库支撑不了，补充了中间件）</p>
<h2 id="介绍自己的技术优势"><a href="#介绍自己的技术优势" class="headerlink" title="介绍自己的技术优势"></a>介绍自己的技术优势</h2><h2 id="自己想要达到的程度"><a href="#自己想要达到的程度" class="headerlink" title="自己想要达到的程度"></a>自己想要达到的程度</h2><h2 id="如果涉及其他语言的项目，学习能力如何"><a href="#如果涉及其他语言的项目，学习能力如何" class="headerlink" title="如果涉及其他语言的项目，学习能力如何"></a>如果涉及其他语言的<a href="">项目</a>，学习能力如何</h2><h2 id="除了Python外还需要什么技能"><a href="#除了Python外还需要什么技能" class="headerlink" title="除了Python外还需要什么技能"></a>除了Python外还需要什么技能</h2><p>云/运维：docker、k8s</p>
<p>存储：数据库</p>
<p>协议：HTTP/TCP/UDP</p>
<p>优化</p>
<p>处理大数据 spark  hadoop</p>
<p>框架 消息</p>
<p>监控平台</p>
<h2 id="字符串拼接方法哪个更快"><a href="#字符串拼接方法哪个更快" class="headerlink" title="字符串拼接方法哪个更快"></a>字符串拼接方法哪个更快</h2><h2 id="指针和引用区别"><a href="#指针和引用区别" class="headerlink" title="指针和引用区别"></a>指针和引用区别</h2><h2 id="红黑树及应用"><a href="#红黑树及应用" class="headerlink" title="红黑树及应用"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%BA%A2%E9%BB%91%E6%A0%91">红黑树</a>及应用</h2><h2 id="项目用到哪些数据结构"><a href="#项目用到哪些数据结构" class="headerlink" title="项目用到哪些数据结构"></a><a href="">项目</a>用到哪些数据结构</h2><h2 id="python数据结构有哪些，各有啥特点"><a href="#python数据结构有哪些，各有啥特点" class="headerlink" title="python数据结构有哪些，各有啥特点"></a>python数据结构有哪些，各有啥特点</h2><h2 id="哈希表原理，哈希冲突怎么解决"><a href="#哈希表原理，哈希冲突怎么解决" class="headerlink" title="哈希表原理，哈希冲突怎么解决"></a><a href="">哈希表</a>原理，哈希冲突怎么解决</h2><h2 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a><a href="">二叉树</a>的定义</h2><h2 id="二叉树查找方式有哪些"><a href="#二叉树查找方式有哪些" class="headerlink" title="二叉树查找方式有哪些"></a><a href="">二叉树</a>查找方式有哪些</h2><h2 id="二叉树和其他数据结构相比有什么特点"><a href="#二叉树和其他数据结构相比有什么特点" class="headerlink" title="二叉树和其他数据结构相比有什么特点"></a><a href="">二叉树</a>和其他数据结构相比有什么特点</h2><h2 id="B-树有什么应用场景"><a href="#B-树有什么应用场景" class="headerlink" title="B+树有什么应用场景"></a>B+树有什么应用场景</h2><h2 id="二叉树和图有什么区别"><a href="#二叉树和图有什么区别" class="headerlink" title="二叉树和图有什么区别"></a><a href="">二叉树</a>和图有什么区别</h2><h2 id="知道最小生成树吗"><a href="#知道最小生成树吗" class="headerlink" title="知道最小生成树吗"></a>知道最小生成树吗</h2><h2 id="什么是元类"><a href="#什么是元类" class="headerlink" title="什么是元类"></a>什么是元类</h2><h2 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h2><p>1.栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈；</p>
<p>2.堆（操作系统）： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。</p>
<p>二.堆栈缓存方式区别：</p>
<p>1.栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放；</p>
<p>2.堆是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。</p>
<p>三.堆栈数据结构区别：</p>
<p>堆（数据结构）：堆可以被看成是一棵树，如：堆排序；</p>
<p>栈（数据结构）：一种先进后出的数据结构。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvzn5tz9klj30cc08k3yt.jpg" alt="img"></p>
<h2 id="什么是最小堆"><a href="#什么是最小堆" class="headerlink" title="什么是最小堆"></a>什么是最小堆</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvzn6eo4f0j30l40ihq3k.jpg" alt="img"></p>
<p>·<strong>最大堆性质</strong>： 结点的键值都小于等于其父结点的键值。</p>
<p>·<strong>最小堆性质</strong>： 结点的键值都大于等于其父结点的键值。</p>
<p>满足最大堆性质的二叉堆叫做最大堆，满足最小堆性质的二叉堆叫做最小堆。</p>
<p><strong>最小堆</strong></p>
<ol>
<li>数组来实现二叉树，所以满足二叉树的特性。</li>
<li>根元素是最小的元素，父节点小于它的两个子节点。</li>
<li>树中的元素是相对有序的。</li>
</ol>
<h2 id="动态规划是怎么解决问题的"><a href="#动态规划是怎么解决问题的" class="headerlink" title="动态规划是怎么解决问题的"></a><a href="">动态规划</a>是怎么解决问题的</h2><blockquote>
<p>动态编程是一种迭代解决递归性质问题的技术，适用于子问题的计算重叠的情况。而用记忆的方法可以防止重复计算子问题。</p>
<p>可以说动态规划问题可以用递归来解决。但是递归的问题不一定可以用动态规划问题解决，需要子问题的计算重叠。</p>
</blockquote>
<p>动态编程是一种迭代解决递归性质问题的技术，适用于子问题的计算重叠的情况。而用记忆的方法可以防止重复计算子问题。</p>
<p>可以说动态规划问题可以用递归来解决。但是递归的问题不一定可以用动态规划问题解决，需要子问题的<strong>计算重叠</strong>。</p>
<h2 id="python内置的算法有哪些"><a href="#python内置的算法有哪些" class="headerlink" title="python内置的算法有哪些"></a>python内置的<a href="">算法</a>有哪些</h2><ul>
<li>常用内置数据类型：list, tuple, dict, set, frozenset</li>
<li>collections</li>
<li>heapq</li>
<li>bisect</li>
</ul>
<h2 id="人生中最重要的算法是哪个"><a href="#人生中最重要的算法是哪个" class="headerlink" title="人生中最重要的算法是哪个"></a>人生中最重要的<a href="">算法</a>是哪个</h2><h2 id="字典、元组、列表的in方法哪个更快"><a href="#字典、元组、列表的in方法哪个更快" class="headerlink" title="字典、元组、列表的in方法哪个更快"></a>字典、元组、列表的in方法哪个更快</h2><p>很多人会告诉你，这是Hash Table，而Hash Table的访问速度是O(1)的</p>
<table>
<thead>
<tr>
<th>x in s （查找）</th>
<th>√ O(n)</th>
<th>√ O(n)</th>
<th>√ O(1)</th>
<th>√ O(1)</th>
</tr>
</thead>
</table>
<h2 id="open和with-open的区别"><a href="#open和with-open的区别" class="headerlink" title="open和with open的区别"></a>open和with open的区别</h2><p>平常用哪个比较多</p>
<p>由于文件读写时都有可能产生<code>IOError</code>，一旦出错，后面的<code>f.close()</code>就不会调用。所以，为了保证无论是否出错都能正确地关闭文件，我们可以使用<code>try ... finally</code>来实现：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def read_file():</span><br><span class="line">    try:</span><br><span class="line">        f = open(&#x27;sawako&#x27;, &#x27;r&#x27;)</span><br><span class="line">        try:</span><br><span class="line">            print(&#x27;&#x27;.join(f.readlines()))</span><br><span class="line">        except:</span><br><span class="line">            print(&#x27;error occurs while reading file&#x27;)</span><br><span class="line">        finally:</span><br><span class="line">            f.close()</span><br><span class="line">    except:</span><br><span class="line">        print(&quot;rror occurs while reading file&quot;)</span><br><span class="line">read_file()</span><br></pre></td></tr></table></figure>



<p>这样的操作太麻烦了，可以通过with open语法来代替：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def readFile():</span><br><span class="line">    try:</span><br><span class="line">        with open(&#x27;mio&#x27;, &#x27;r&#x27;) as f:</span><br><span class="line">            print((&#x27;&#x27;.join(f.readlines())))</span><br><span class="line">    except:</span><br><span class="line">        print(&#x27;error occurs while reading file&#x27;)</span><br><span class="line">readFile()</span><br></pre></td></tr></table></figure>

<p>执行结果与上例相同。这和前面的<code>try ... finally</code>是一样的，但是代码更佳简洁，并且不必调用<code>f.close()</code>方法。</p>
<h2 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvzmov50uuj305l06lglh.jpg" alt="img"></p>
<p>，这一类单词集合在本数据结构中公用前缀，因此，当我们搜索单词的时候，这一数据结构可以自动帮助我们过滤掉那些前缀不一致的单词。当单词数据库变的很大很大的时候，这一检索方法会帮我们节省大量的时间。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">words = [<span class="string">&#x27;cat&#x27;</span>,<span class="string">&#x27;category&#x27;</span>,<span class="string">&#x27;tree&#x27;</span>,<span class="string">&#x27;trace&#x27;</span>,<span class="string">&#x27;top&#x27;</span>]</span><br><span class="line">trie = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">    t = trie <span class="comment"># 请把这个t理解为指针，这个指针除了用来移动外，也用来建立新的字典。</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> word:</span><br><span class="line">        <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> t:</span><br><span class="line">            t[c] = &#123;&#125; <span class="comment"># 若没有，为下一个字母建立一个新的字典</span></span><br><span class="line">        t = t[c] <span class="comment"># 进入下一层</span></span><br><span class="line">    t[<span class="string">&#x27;#&#x27;</span>] = <span class="string">&#x27;#&#x27;</span> <span class="comment"># 句尾结束符</span></span><br><span class="line">print(trie)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">word</span>):</span></span><br><span class="line">    t = trie</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> word:</span><br><span class="line">        <span class="keyword">if</span> c <span class="keyword">in</span> t: <span class="comment"># 如果我们在本层发现了这个字母，那么，我们进入下一层</span></span><br><span class="line">            t = t[c] <span class="comment"># 关键点依然是把t理解成指针。</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;#&#x27;</span> <span class="keyword">in</span> t: <span class="comment"># 当所有字母都检查完毕的时候，我们需要确定，这个被查询的序列到底是不是一个完整的单词</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>



<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><h2 id="如何杀死-test-py进程"><a href="#如何杀死-test-py进程" class="headerlink" title="如何杀死 test.py进程"></a>如何杀死 test.py进程</h2><p>（我说先用ps查看进程号，然后kill -9 kill掉，然后就问我如何用一行命令杀死）</p>
<p><code>ps -ef | grep flask | grep -v grep | awk &#39;&#123;print $2&#125;&#39; | xargs kill -9</code></p>
<ul>
<li>AWK 是一种处理文本文件的语言，是一个强大的文本分析工具</li>
</ul>
<h2 id="快排的思路"><a href="#快排的思路" class="headerlink" title="快排的思路"></a>快排的思路</h2><h2 id="给定一个a-txt，b-txt文件，里面存有许多ip地址，现在判断有多少个相同的IP"><a href="#给定一个a-txt，b-txt文件，里面存有许多ip地址，现在判断有多少个相同的IP" class="headerlink" title="给定一个a.txt，b.txt文件，里面存有许多ip地址，现在判断有多少个相同的IP"></a>给定一个a.txt，b.txt文件，里面存有许多ip地址，现在判断有多少个相同的IP</h2><p>   方案1：可以估计每个文件安的大小为5G×64=320G，远远大于内存限制的4G。所以不可能将其完全加载到内存中处理。考虑采取分而治之的方法。</p>
<pre><code>遍历文件a，对每个url求取hash(url)%1000，然后根据所取得的值将url分别存储到1000个小文件（记为a0,a1,...,a999）中。这样每个小文件的大约为300M。

遍历文件b，采取和a相同的方式将url分别存储到1000小文件（记为b0,b1,...,b999）。这样处理后，所有可能相同的url都在对应的小文件（a0vsb0,a1vsb1,...,a999vsb999）中，不对应的小文件不可能有相同的url。然后我们只要求出1000对小文件中相同的url即可。

求每对小文件中相同的url时，可以把其中一个小文件的url存储到hash_set中。然后遍历另一个小文件的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。

方案2：如果允许有一定的错误率，可以使用Bloom filter，4G内存大概可以表示340亿bit。将其中一个文件中的url使用Bloom filter映射为这340亿bit，然后挨个读取另外一个文件的url，检查是否与Bloom filter，如果是，那么该url应该是共同的url（注意会有一定的错误率）。

Bloom filter日后会在本BLOG内详细阐述。
</code></pre>
<h2 id="TCP的重传机制、快速重传是怎样的"><a href="#TCP的重传机制、快速重传是怎样的" class="headerlink" title="TCP的重传机制、快速重传是怎样的"></a>TCP的重传机制、快速重传是怎样的</h2><p>重传机制的其中一个方式，就是在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 <code>ACK</code> 确认应答报文，就会重发该数据，也就是我们常说的<strong>超时重传</strong>。</p>
<p>TCP 会在以下两种情况发生超时重传：</p>
<ul>
<li>数据包丢失</li>
<li>确认应答丢失</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/5.jpg" alt="超时重传的两种情况"></p>
<h2 id="30张图解：-TCP-重传、滑动窗口、流量控制、拥塞控制"><a href="#30张图解：-TCP-重传、滑动窗口、流量控制、拥塞控制" class="headerlink" title="30张图解： TCP 重传、滑动窗口、流量控制、拥塞控制"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaolincoding/p/12732052.html">30张图解： TCP 重传、滑动窗口、流量控制、拥塞控制</a></h2><p>相信大家都知道 TCP 是一个可靠传输的协议，那它是如何保证可靠的呢？</p>
<p>为了实现可靠性传输，需要考虑很多事情，例如数据的破坏、丢包、重复以及分片顺序混乱等问题。如不能解决这些问题，也就无从谈起可靠传输。</p>
<p>那么，TCP 是通过序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输的。</p>
<p>今天，将重点介绍 TCP 的<strong>重传机制、滑动窗口、流量控制、拥塞控制。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/3.jpg" alt="img"></p>
<h3 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h3><p>TCP 实现可靠传输的方式之一，是通过序列号与确认应答。</p>
<p>在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回一个确认应答消息，表示已收到消息。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/4.jpg" alt="正常的数据传输">正常的数据传输</p>
<p>但在错综复杂的网络，并不一定能如上图那么顺利能正常的数据传输，万一数据在传输过程中丢失了呢？</p>
<p>所以 TCP 针对数据包丢失的情况，会用<strong>重传机制</strong>解决。</p>
<p>接下来说说常见的重传机制：</p>
<ul>
<li>超时重传</li>
<li>快速重传</li>
<li>SACK</li>
<li>D-SACK</li>
</ul>
<h4 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h4><p>重传机制的其中一个方式，就是在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 <code>ACK</code> 确认应答报文，就会重发该数据，也就是我们常说的<strong>超时重传</strong>。</p>
<p>TCP 会在以下两种情况发生超时重传：</p>
<ul>
<li>数据包丢失</li>
<li>确认应答丢失</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/5.jpg" alt="超时重传的两种情况">超时重传的两种情况</p>
<blockquote>
<p>超时时间应该设置为多少呢？</p>
</blockquote>
<p>我们先来了解一下什么是 <code>RTT</code>（Round-Trip Time 往返时延），从下图我们就可以知道：</p>
<p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/6.jpg" alt="RTT">RTT</p>
<p><code>RTT</code> 就是<strong>数据从网络一端传送到另一端所需的时间</strong>，也就是包的往返时间。</p>
<p>超时重传时间是以 <code>RTO</code> （Retransmission Timeout 超时重传时间）表示。</p>
<p>假设在重传的情况下，超时时间 <code>RTO</code> 「较长或较短」时，会发生什么事情呢？</p>
<p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/7.jpg" alt="超时时间较长与较短">超时时间较长与较短</p>
<p>上图中有两种超时时间不同的情况：</p>
<ul>
<li>当超时时间 <strong>RTO 较大</strong>时，重发就慢，丢了老半天才重发，没有效率，性能差；</li>
<li>当超时时间 <strong>RTO 较小</strong>时，会导致可能并没有丢就重发，于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。</li>
</ul>
<p>精确的测量超时时间 <code>RTO</code> 的值是非常重要的，这可让我们的重传机制更高效。</p>
<p>根据上述的两种情况，我们可以得知，<strong>超时重传时间 RTO 的值应该略大于报文往返 RTT 的值</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/8.jpg" alt="RTO 应略大于 RTT">RTO 应略大于 RTT</p>
<p>至此，可能大家觉得超时重传时间 <code>RTO</code> 的值计算，也不是很复杂嘛。</p>
<p>好像就是在发送端发包时记下 <code>t0</code> ，然后接收端再把这个 <code>ack</code> 回来时再记一个 <code>t1</code>，于是 <code>RTT = t1 – t0</code>。没那么简单，<strong>这只是一个采样，不能代表普遍情况</strong>。</p>
<p>实际上「报文往返 RTT 的值」是经常变化的，因为我们的网络也是时常变化的。也就因为「报文往返 RTT 的值」 是经常波动变化的，所以「超时重传时间 RTO 的值」应该是一个<strong>动态变化的值</strong>。</p>
<p>我们来看看 Linux 是如何计算 <code>RTO</code> 的呢？</p>
<p>估计往返时间，通常需要采样以下两个：</p>
<ul>
<li>需要 TCP 通过采样 RTT 的时间，然后进行加权平均，算出一个平滑 RTT 的值，而且这个值还是要不断变化的，因为网络状况不断地变化。</li>
<li>除了采样 RTT，还要采样 RTT 的波动范围，这样就避免如果 RTT 有一个大的波动的话，很难被发现的情况。</li>
</ul>
<p>RFC6289 建议使用以下的公式计算 RTO：</p>
<p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/9.jpg" alt="RFC6289 建议的 RTO 计算 ">RFC6289 建议的 RTO 计算</p>
<p>其中 <code>SRTT</code> 是计算平滑的RTT ，<code>DevRTR</code> 是计算平滑的RTT 与 最新 RTT 的差距。</p>
<p>在 Linux 下，<strong>α = 0.125，β = 0.25， μ = 1，∂ = 4</strong>。别问怎么来的，问就是大量实验中调出来的。</p>
<p>如果超时重发的数据，再次超时的时候，又需要重传的时候，TCP 的策略是<strong>超时间隔加倍。</strong></p>
<p>也就是<strong>每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送。</strong></p>
<p>超时触发重传存在的问题是，超时周期可能相对较长。那是不是可以有更快的方式呢？</p>
<p>于是就可以用「快速重传」机制来解决超时重发的时间等待。</p>
<h4 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h4><p>TCP 还有另外一种<strong>快速重传（Fast Retransmit）机制</strong>，它<strong>不以时间为驱动，而是以数据驱动重传</strong>。</p>
<p>快速重传机制，是如何工作的呢？其实很简单，一图胜千言。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/10.jpg" alt="快速重传机制">快速重传机制</p>
<p>在上图，发送方发出了 1，2，3，4，5 份数据：</p>
<ul>
<li>第一份 Seq1 先送到了，于是就 Ack 回 2；</li>
<li>结果 Seq2 因为某些原因没收到，Seq3 到达了，于是还是 Ack 回 2；</li>
<li>后面的 Seq4 和 Seq5 都到了，但还是 Ack 回 2，因为 Seq2 还是没有收到；</li>
<li><strong>发送端收到了三个 Ack = 2 的确认，知道了 Seq2 还没有收到，就会在定时器过期之前，重传丢失的 Seq2。</strong></li>
<li>最后，收到了 Seq2，此时因为 Seq3，Seq4，Seq5 都收到了，于是 Ack 回 6 。</li>
</ul>
<p>所以，快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。</p>
<p>快速重传机制只解决了一个问题，就是超时时间的问题，但是它依然面临着另外一个问题。就是<strong>重传的时候，是重传之前的一个，还是重传所有的问题。</strong></p>
<p>比如对于上面的例子，是重传 Seq2 呢？还是重传 Seq2、Seq3、Seq4、Seq5 呢？因为发送端并不清楚这连续的三个 Ack 2 是谁传回来的。</p>
<p>根据 TCP 不同的实现，以上两种情况都是有可能的。可见，这是一把双刃剑。</p>
<p>为了解决不知道该重传哪些 TCP 报文，于是就有 <code>SACK</code> 方法。</p>
<h4 id="SACK-方法"><a href="#SACK-方法" class="headerlink" title="SACK 方法"></a>SACK 方法</h4><p>还有一种实现重传机制的方式叫：<code>SACK</code>（ Selective Acknowledgment 选择性确认）。</p>
<p>这种方式需要在 TCP 头部「选项」字段里加一个 <code>SACK</code> 的东西，它<strong>可以将缓存的地图发送给发送方</strong>，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以<strong>只重传丢失的数据</strong>。</p>
<p>如下图，发送方收到了三次同样的 ACK 确认报文，于是就会触发快速重发机制，通过 <code>SACK</code> 信息发现只有 <code>200~299</code> 这段数据丢失，则重发时，就只选择了这个 TCP 段进行重复。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/11.jpg" alt="选择性确认">选择性确认</p>
<p>如果要支持 <code>SACK</code>，必须双方都要支持。在 Linux 下，可以通过 <code>net.ipv4.tcp_sack</code> 参数打开这个功能（Linux 2.4 后默认打开）。</p>
<h4 id="Duplicate-SACK"><a href="#Duplicate-SACK" class="headerlink" title="Duplicate SACK"></a>Duplicate SACK</h4><p>Duplicate SACK 又称 <code>D-SACK</code>，其主要<strong>使用了 SACK 来告诉「发送方」有哪些数据被重复接收了。</strong></p>
<p>下面举例两个栗子，来说明 <code>D-SACK</code> 的作用。</p>
<p><em>栗子一号：ACK 丢包</em></p>
<p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/12.jpg" alt="ACK 丢包">ACK 丢包</p>
<ul>
<li>「接收方」发给「发送方」的两个 ACK 确认应答都丢失了，所以发送方超时后，重传第一个数据包（3000 ~ 3499）</li>
<li><strong>于是「接收方」发现数据是重复收到的，于是回了一个 SACK = 3000~3500</strong>，告诉「发送方」 3000~3500 的数据早已被接收了，因为 ACK 都到了 4000 了，已经意味着 4000 之前的所有数据都已收到，所以这个 SACK 就代表着 <code>D-SACK</code>。</li>
<li>这样「发送方」就知道了，数据没有丢，是「接收方」的 ACK 确认报文丢了。</li>
</ul>
<p><em>栗子二号：网络延时</em></p>
<p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/13.jpg" alt="网络延时">网络延时</p>
<ul>
<li>数据包（1000~1499） 被网络延迟了，导致「发送方」没有收到 Ack 1500 的确认报文。</li>
<li>而后面报文到达的三个相同的 ACK 确认报文，就触发了快速重传机制，但是在重传后，被延迟的数据包（1000~1499）又到了「接收方」；</li>
<li><strong>所以「接收方」回了一个 SACK=1000~1500，因为 ACK 已经到了 3000，所以这个 SACK 是 D-SACK，表示收到了重复的包。</strong></li>
<li>这样发送方就知道快速重传触发的原因不是发出去的包丢了，也不是因为回应的 ACK 包丢了，而是因为网络延迟了。</li>
</ul>
<p>可见，<code>D-SACK</code> 有这么几个好处：</p>
<ol>
<li>可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了;</li>
<li>可以知道是不是「发送方」的数据包被网络延迟了;</li>
<li>可以知道网络中是不是把「发送方」的数据包给复制了;</li>
</ol>
<p>在 Linux 下可以通过 <code>net.ipv4.tcp_dsack</code> 参数开启/关闭这个功能（Linux 2.4 后默认打开）。</p>
<hr>
<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><blockquote>
<p>引入窗口概念的原因</p>
</blockquote>
<p>我们都知道 TCP 是每发送一个数据，都要进行一次确认应答。当上一个数据包收到了应答了， 再发送下一个。</p>
<p>这个模式就有点像我和你面对面聊天，你一句我一句。但这种方式的缺点是效率比较低的。</p>
<p>如果你说完一句话，我在处理其他事情，没有及时回复你，那你不是要干等着我做完其他事情后，我回复你，你才能说下一句话，很显然这不现实。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/14.jpg" alt="按数据包进行确认应答">按数据包进行确认应答</p>
<p>所以，这样的传输方式有一个缺点：数据包的<strong>往返时间越长，通信的效率就越低</strong>。</p>
<p>为解决这个问题，TCP 引入了<strong>窗口</strong>这个概念。即使在往返时间较长的情况下，它也不会降低网络通信的效率。</p>
<p>那么有了窗口，就可以指定窗口大小，窗口大小就是指<strong>无需等待确认应答，而可以继续发送数据的最大值</strong>。</p>
<p>窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。</p>
<p>假设窗口大小为 <code>3</code> 个 TCP 段，那么发送方就可以「连续发送」 <code>3</code> 个 TCP 段，并且中途若有 ACK 丢失，可以通过「下一个确认应答进行确认」。如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/15.jpg" alt="用滑动窗口方式并行处理">用滑动窗口方式并行处理</p>
<p>图中的 ACK 600 确认应答报文丢失，也没关系，因为可以通过下一个确认应答进行确认，只要发送方收到了 ACK 700 确认应答，就意味着 700 之前的所有数据「接收方」都收到了。这个模式就叫<strong>累计确认</strong>或者<strong>累计应答</strong>。</p>
<blockquote>
<p>窗口大小由哪一方决定？</p>
</blockquote>
<p>TCP 头里有一个字段叫 <code>Window</code>，也就是窗口大小。</p>
<p><strong>这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。</strong></p>
<p>所以，通常窗口的大小是由接收方的窗口大小来决定的。</p>
<p>发送方发送的数据大小不能超过接收方的窗口大小，否则接收方就无法正常接收到数据。</p>
<blockquote>
<p>发送方的滑动窗口</p>
</blockquote>
<p>我们先来看看发送方的窗口，下图就是发送方缓存的数据，根据处理的情况分成四个部分，其中深蓝色方框是发送窗口，紫色方框是可用窗口：</p>
<p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/16.jpg" alt="img"></p>
<ul>
<li>#1 是已发送并收到 ACK确认的数据：1~31 字节</li>
<li>#2 是已发送但未收到 ACK确认的数据：32~45 字节</li>
<li>#3 是未发送但总大小在接收方处理范围内（接收方还有空间）：46~51字节</li>
<li>#4 是未发送但总大小超过接收方处理范围（接收方没有空间）：52字节以后</li>
</ul>
<p>在下图，当发送方把数据「全部」都一下发送出去后，可用窗口的大小就为 0 了，表明可用窗口耗尽，在没收到 ACK 确认之前是无法继续发送数据了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/17.jpg" alt="可用窗口耗尽">可用窗口耗尽</p>
<p>在下图，当收到之前发送的数据 <code>32~36</code> 字节的 ACK 确认应答后，如果发送窗口的大小没有变化，则<strong>滑动窗口往右边移动 5 个字节，因为有 5 个字节的数据被应答确认</strong>，接下来 <code>52~56</code> 字节又变成了可用窗口，那么后续也就可以发送 <code>52~56</code> 这 5 个字节的数据了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/18.jpg" alt="32 ~ 36 字节已确认">32 ~ 36 字节已确认</p>
<blockquote>
<p>程序是如何表示发送方的四个部分的呢？</p>
</blockquote>
<p>TCP 滑动窗口方案使用三个指针来跟踪在四个传输类别中的每一个类别中的字节。其中两个指针是绝对指针（指特定的序列号），一个是相对指针（需要做偏移）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/19.jpg" alt="SND.WND、SND.UN、SND.NXT">SND.WND、SND.UN、SND.NXT</p>
<ul>
<li><code>SND.WND</code>：表示发送窗口的大小（大小是由接收方指定的）；</li>
<li><code>SND.UNA</code>：是一个绝对指针，它指向的是已发送但未收到确认的第一个字节的序列号，也就是 #2 的第一个字节。</li>
<li><code>SND.NXT</code>：也是一个绝对指针，它指向未发送但可发送范围的第一个字节的序列号，也就是 #3 的第一个字节。</li>
<li>指向 #4 的第一个字节是个相对指针，它需要 <code>SND.UNA</code> 指针加上 <code>SND.WND</code> 大小的偏移量，就可以指向 #4 的第一个字节了。</li>
</ul>
<p>那么可用窗口大小的计算就可以是：</p>
<p><strong>可用窗口大 = SND.WND -（SND.NXT - SND.UNA）</strong></p>
<blockquote>
<p>接收方的滑动窗口</p>
</blockquote>
<p>接下来我们看看接收方的窗口，接收窗口相对简单一些，根据处理的情况划分成三个部分：</p>
<ul>
<li>#1 + #2 是已成功接收并确认的数据（等待应用进程读取）；</li>
<li>#3 是未收到数据但可以接收的数据；</li>
<li>#4 未收到数据并不可以接收的数据；</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/20.jpg" alt="接收窗口">接收窗口</p>
<p>其中三个接收部分，使用两个指针进行划分:</p>
<ul>
<li><code>RCV.WND</code>：表示接收窗口的大小，它会通告给发送方。</li>
<li><code>RCV.NXT</code>：是一个指针，它指向期望从发送方发送来的下一个数据字节的序列号，也就是 #3 的第一个字节。</li>
<li>指向 #4 的第一个字节是个相对指针，它需要 <code>RCV.NXT</code> 指针加上 <code>RCV.WND</code> 大小的偏移量，就可以指向 #4 的第一个字节了。</li>
</ul>
<blockquote>
<p>接收窗口和发送窗口的大小是相等的吗？</p>
</blockquote>
<p>并不是完全相等，接收窗口的大小是<strong>约等于</strong>发送窗口的大小的。</p>
<p>因为滑动窗口并不是一成不变的。比如，当接收方的应用进程读取数据的速度非常快的话，这样的话接收窗口可以很快的就空缺出来。那么新的接收窗口大小，是通过 TCP 报文中的 Windows 字段来告诉发送方。那么这个传输过程是存在时延的，所以接收窗口和发送窗口是约等于的关系。</p>
<hr>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>发送方不能无脑的发数据给接收方，要考虑接收方处理能力。</p>
<p>如果一直无脑的发数据给对方，但对方处理不过来，那么就会导致触发重发机制，从而导致网络流量的无端的浪费。</p>
<p>为了解决这种现象发生，<strong>TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。</strong></p>
<p>下面举个栗子，为了简单起见，假设以下场景：</p>
<ul>
<li>客户端是接收方，服务端是发送方</li>
<li>假设接收窗口和发送窗口相同，都为 <code>200</code></li>
<li>假设两个设备在整个传输过程中都保持相同的窗口大小，不受外界影响</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/21.jpg" alt="流量控制">流量控制</p>
<p>根据上图的流量控制，说明下每个过程：</p>
<ol>
<li>客户端向服务端发送请求数据报文。这里要说明下，本次例子是把服务端作为发送方，所以没有画出服务端的接收窗口。</li>
<li>服务端收到请求报文后，发送确认报文和 80 字节的数据，于是可用窗口 <code>Usable</code> 减少为 120 字节，同时 <code>SND.NXT</code> 指针也向右偏移 80 字节后，指向 321，<strong>这意味着下次发送数据的时候，序列号是 321。</strong></li>
<li>客户端收到 80 字节数据后，于是接收窗口往右移动 80 字节，<code>RCV.NXT</code> 也就指向 321，<strong>这意味着客户端期望的下一个报文的序列号是 321</strong>，接着发送确认报文给服务端。</li>
<li>服务端再次发送了 120 字节数据，于是可用窗口耗尽为 0，服务端无法再继续发送数据。</li>
<li>客户端收到 120 字节的数据后，于是接收窗口往右移动 120 字节，<code>RCV.NXT</code> 也就指向 441，接着发送确认报文给服务端。</li>
<li>服务端收到对 80 字节数据的确认报文后，<code>SND.UNA</code> 指针往右偏移后指向 321，于是可用窗口 <code>Usable</code> 增大到 80。</li>
<li>服务端收到对 120 字节数据的确认报文后，<code>SND.UNA</code> 指针往右偏移后指向 441，于是可用窗口 <code>Usable</code> 增大到 200。</li>
<li>服务端可以继续发送了，于是发送了 160 字节的数据后，<code>SND.NXT</code> 指向 601，于是可用窗口 <code>Usable</code> 减少到 40。</li>
<li>客户端收到 160 字节后，接收窗口往右移动了 160 字节，<code>RCV.NXT</code> 也就是指向了 601，接着发送确认报文给服务端。</li>
<li>服务端收到对 160 字节数据的确认报文后，发送窗口往右移动了 160 字节，于是 <code>SND.UNA</code> 指针偏移了 160 后指向 601，可用窗口 <code>Usable</code> 也就增大至了 200。</li>
</ol>
<h4 id="操作系统缓冲区与滑动窗口的关系"><a href="#操作系统缓冲区与滑动窗口的关系" class="headerlink" title="操作系统缓冲区与滑动窗口的关系"></a>操作系统缓冲区与滑动窗口的关系</h4><p>前面的流量控制例子，我们假定了发送窗口和接收窗口是不变的，但是实际上，发送窗口和接收窗口中所存放的字节数，都是放在操作系统内存缓冲区中的，而操作系统的缓冲区，会<strong>被操作系统调整</strong>。</p>
<p>当应用进程没办法及时读取缓冲区的内容时，也会对我们的缓冲区造成影响。</p>
<blockquote>
<p>那操心系统的缓冲区，是如何影响发送窗口和接收窗口的呢？</p>
</blockquote>
<p><em>我们先来看看第一个例子。</em></p>
<p>当应用程序没有及时读取缓存时，发送窗口和接收窗口的变化。</p>
<p>考虑以下场景：</p>
<ul>
<li>客户端作为发送方，服务端作为接收方，发送窗口和接收窗口初始大小为 <code>360</code>；</li>
<li>服务端非常的繁忙，当收到客户端的数据时，应用层不能及时读取数据。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/22.jpg" alt="img"></p>
<p>根据上图的流量控制，说明下每个过程：</p>
<ol>
<li>客户端发送 140 字节数据后，可用窗口变为 220 （360 - 140）。</li>
<li>服务端收到 140 字节数据，<strong>但是服务端非常繁忙，应用进程只读取了 40 个字节，还有 100 字节占用着缓冲区，于是接收窗口收缩到了 260 （360 - 100）</strong>，最后发送确认信息时，将窗口大小通告给客户端。</li>
<li>客户端收到确认和窗口通告报文后，发送窗口减少为 260。</li>
<li>客户端发送 180 字节数据，此时可用窗口减少到 80。</li>
<li>服务端收到 180 字节数据，<strong>但是应用程序没有读取任何数据，这 180 字节直接就留在了缓冲区，于是接收窗口收缩到了 80 （260 - 180）</strong>，并在发送确认信息时，通过窗口大小给客户端。</li>
<li>客户端收到确认和窗口通告报文后，发送窗口减少为 80。</li>
<li>客户端发送 80 字节数据后，可用窗口耗尽。</li>
<li>服务端收到 80 字节数据，<strong>但是应用程序依然没有读取任何数据，这 80 字节留在了缓冲区，于是接收窗口收缩到了 0</strong>，并在发送确认信息时，通过窗口大小给客户端。</li>
<li>客户端收到确认和窗口通告报文后，发送窗口减少为 0。</li>
</ol>
<p>可见最后窗口都收缩为 0 了，也就是发生了窗口关闭。当发送方可用窗口变为 0 时，发送方实际上会定时发送窗口探测报文，以便知道接收方的窗口是否发生了改变，这个内容后面会说，这里先简单提一下。</p>
<p><em>我们先来看看第二个例子。</em></p>
<p>当服务端系统资源非常紧张的时候，操心系统可能会直接减少了接收缓冲区大小，这时应用程序又无法及时读取缓存数据，那么这时候就有严重的事情发生了，会出现数据包丢失的现象。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/23.jpg" alt="img"></p>
<p>说明下每个过程：</p>
<ol>
<li>客户端发送 140 字节的数据，于是可用窗口减少到了 220。</li>
<li><strong>服务端因为现在非常的繁忙，操作系统于是就把接收缓存减少了 120 字节，当收到 140 字节数据后，又因为应用程序没有读取任何数据，所以 140 字节留在了缓冲区中，于是接收窗口大小从 360 收缩成了 100</strong>，最后发送确认信息时，通告窗口大小给对方。</li>
<li>此时客户端因为还没有收到服务端的通告窗口报文，所以不知道此时接收窗口收缩成了 100，客户端只会看自己的可用窗口还有 220，所以客户端就发送了 180 字节数据，于是可用窗口减少到 40。</li>
<li>服务端收到了 180 字节数据时，<strong>发现数据大小超过了接收窗口的大小，于是就把数据包丢失了。</strong></li>
<li>客户端收到第 2 步时，服务端发送的确认报文和通告窗口报文，尝试减少发送窗口到 100，把窗口的右端向左收缩了 80，此时可用窗口的大小就会出现诡异的负值。</li>
</ol>
<p>所以，如果发生了先减少缓存，再收缩窗口，就会出现丢包的现象。</p>
<p><strong>为了防止这种情况发生，TCP 规定是不允许同时减少缓存又收缩窗口的，而是采用先收缩窗口，过段时间再减少缓存，这样就可以避免了丢包情况。</strong></p>
<h4 id="窗口关闭"><a href="#窗口关闭" class="headerlink" title="窗口关闭"></a>窗口关闭</h4><p>在前面我们都看到了，TCP 通过让接收方指明希望从发送方接收的数据大小（窗口大小）来进行流量控制。</p>
<p><strong>如果窗口大小为 0 时，就会阻止发送方给接收方传递数据，直到窗口变为非 0 为止，这就是窗口关闭。</strong></p>
<blockquote>
<p>窗口关闭潜在的危险</p>
</blockquote>
<p>接收方向发送方通告窗口大小时，是通过 <code>ACK</code> 报文来通告的。</p>
<p>那么，当发生窗口关闭时，接收方处理完数据后，会向发送方通告一个窗口非 0 的 ACK 报文，如果这个通告窗口的 ACK 报文在网络中丢失了，那麻烦就大了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/24.jpg" alt="窗口关闭潜在的危险">窗口关闭潜在的危险</p>
<p>这会导致发送方一直等待接收方的非 0 窗口通知，接收方也一直等待发送方的数据，如不采取措施，这种相互等待的过程，会造成了死锁的现象。</p>
<blockquote>
<p>TCP 是如何解决窗口关闭时，潜在的死锁现象呢？</p>
</blockquote>
<p>为了解决这个问题，TCP 为每个连接设有一个持续定时器，<strong>只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。</strong></p>
<p>如果持续计时器超时，就会发送<strong>窗口探测 ( Window probe ) 报文</strong>，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/25.jpg" alt="窗口探测">窗口探测</p>
<ul>
<li>如果接收窗口仍然为 0，那么收到这个报文的一方就会重新启动持续计时器；</li>
<li>如果接收窗口不是 0，那么死锁的局面就可以被打破了。</li>
</ul>
<p>窗口探测的次数一般为 3 次，每次大约 30-60 秒（不同的实现可能会不一样）。如果 3 次过后接收窗口还是 0 的话，有的 TCP 实现就会发 <code>RST</code> 报文来中断连接。</p>
<h4 id="糊涂窗口综合症"><a href="#糊涂窗口综合症" class="headerlink" title="糊涂窗口综合症"></a>糊涂窗口综合症</h4><p>如果接收方太忙了，来不及取走接收窗口里的数据，那么就会导致发送方的发送窗口越来越小。</p>
<p>到最后，<strong>如果接收方腾出几个字节并告诉发送方现在有几个字节的窗口，而发送方会义无反顾地发送这几个字节，这就是糊涂窗口综合症</strong>。</p>
<p>要知道，我们的 <code>TCP + IP</code> 头有 <code>40</code> 个字节，为了传输那几个字节的数据，要达上这么大的开销，这太不经济了。</p>
<p>就好像一个可以承载 50 人的大巴车，每次来了一两个人，就直接发车。除非家里有矿的大巴司机，才敢这样玩，不然迟早破产。要解决这个问题也不难，大巴司机等乘客数量超过了 25 个，才认定可以发车。</p>
<p>现举个糊涂窗口综合症的栗子，考虑以下场景：</p>
<p>接收方的窗口大小是 360 字节，但接收方由于某些原因陷入困境，假设接收方的应用层读取的能力如下：</p>
<ul>
<li>接收方每接收 3 个字节，应用程序就只能从缓冲区中读取 1 个字节的数据；</li>
<li>在下一个发送方的 TCP 段到达之前，应用程序还从缓冲区中读取了 40 个额外的字节；</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/26.png" alt="糊涂窗口综合症">糊涂窗口综合症</p>
<p>每个过程的窗口大小的变化，在图中都描述的很清楚了，可以发现窗口不断减少了，并且发送的数据都是比较小的了。</p>
<p>所以，糊涂窗口综合症的现象是可以发生在发送方和接收方：</p>
<ul>
<li>接收方可以通告一个小的窗口</li>
<li>而发送方可以发送小数据</li>
</ul>
<p>于是，要解决糊涂窗口综合症，就解决上面两个问题就可以了</p>
<ul>
<li>让接收方不通告小窗口给发送方</li>
<li>让发送方避免发送小数据</li>
</ul>
<blockquote>
<p>怎么让接收方不通告小窗口呢？</p>
</blockquote>
<p>接收方通常的策略如下:</p>
<p>当「窗口大小」小于 min( MSS，缓存空间/2 ) ，也就是小于 MSS 与 1/2 缓存大小中的最小值时，就会向发送方通告窗口为 <code>0</code>，也就阻止了发送方再发数据过来。</p>
<p>等到接收方处理了一些数据后，窗口大小 &gt;= MSS，或者接收方缓存空间有一半可以使用，就可以把窗口打开让发送方发送数据过来。</p>
<blockquote>
<p>怎么让发送方避免发送小数据呢？</p>
</blockquote>
<p>发送方通常的策略:</p>
<p>使用 Nagle 算法，该算法的思路是延时处理，它满足以下两个条件中的一条才可以发送数据：</p>
<ul>
<li>要等到窗口大小 &gt;= <code>MSS</code> 或是 数据大小 &gt;= <code>MSS</code></li>
<li>收到之前发送数据的 <code>ack</code> 回包</li>
</ul>
<p>只要没满足上面条件中的一条，发送方一直在囤积数据，直到满足上面的发送条件。</p>
<p>另外，Nagle 算法默认是打开的，如果对于一些需要小数据包交互的场景的程序，比如，telnet 或 ssh 这样的交互性比较强的程序，则需要关闭 Nagle 算法。</p>
<p>可以在 Socket 设置 <code>TCP_NODELAY</code> 选项来关闭这个算法（关闭 Nagle 算法没有全局参数，需要根据每个应用自己的特点来关闭）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setsockopt(sock_fd, IPPROTO_TCP, TCP_NODELAY, (<span class="keyword">char</span> *)&amp;value, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><blockquote>
<p>为什么要有拥塞控制呀，不是有流量控制了吗？</p>
</blockquote>
<p>前面的流量控制是避免「发送方」的数据填满「接收方」的缓存，但是并不知道网络的中发生了什么。</p>
<p>一般来说，计算机网络都处在一个共享的环境。因此也有可能会因为其他主机之间的通信使得网络拥堵。</p>
<p><strong>在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大….</strong></p>
<p>所以，TCP 不能忽略网络上发生的事，它被设计成一个无私的协议，当网络发送拥塞时，TCP 会自我牺牲，降低发送的数据量。</p>
<p>于是，就有了<strong>拥塞控制</strong>，控制的目的就是<strong>避免「发送方」的数据填满整个网络。</strong></p>
<p>为了在「发送方」调节所要发送数据的量，定义了一个叫做「<strong>拥塞窗口</strong>」的概念。</p>
<blockquote>
<p>什么是拥塞窗口？和发送窗口有什么关系呢？</p>
</blockquote>
<p><strong>拥塞窗口 cwnd</strong>是发送方维护的一个的状态变量，它会根据<strong>网络的拥塞程度动态变化的</strong>。</p>
<p>我们在前面提到过发送窗口 <code>swnd</code> 和接收窗口 <code>rwnd</code> 是约等于的关系，那么由于加入了拥塞窗口的概念后，此时发送窗口的值是swnd = min(cwnd, rwnd)，也就是拥塞窗口和接收窗口中的最小值。</p>
<p>拥塞窗口 <code>cwnd</code> 变化的规则：</p>
<ul>
<li>只要网络中没有出现拥塞，<code>cwnd</code> 就会增大；</li>
<li>但网络中出现了拥塞，<code>cwnd</code> 就减少；</li>
</ul>
<blockquote>
<p>那么怎么知道当前网络是否出现了拥塞呢？</p>
</blockquote>
<p>其实只要「发送方」没有在规定时间内接收到 ACK 应答报文，也就是<strong>发生了超时重传，就会认为网络出现了用拥塞。</strong></p>
<blockquote>
<p>拥塞控制有哪些控制算法？</p>
</blockquote>
<p>拥塞控制主要是四个算法：</p>
<ul>
<li>慢启动</li>
<li>拥塞避免</li>
<li>拥塞发生</li>
<li>快速恢复</li>
</ul>
<h4 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h4><p>TCP 在刚建立连接完成后，首先是有个慢启动的过程，这个慢启动的意思就是一点一点的提高发送数据包的数量，如果一上来就发大量的数据，这不是给网络添堵吗？</p>
<p>慢启动的算法记住一个规则就行：<strong>当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1。</strong></p>
<p>这里假定拥塞窗口 <code>cwnd</code> 和发送窗口 <code>swnd</code> 相等，下面举个栗子：</p>
<ul>
<li>连接建立完成后，一开始初始化 <code>cwnd = 1</code>，表示可以传一个 <code>MSS</code> 大小的数据。</li>
<li>当收到一个 ACK 确认应答后，cwnd 增加 1，于是一次能够发送 2 个</li>
<li>当收到 2 个的 ACK 确认应答后， cwnd 增加 2，于是就可以比之前多发2 个，所以这一次能够发送 4 个</li>
<li>当这 4 个的 ACK 确认到来的时候，每个确认 cwnd 增加 1， 4 个确认 cwnd 增加 4，于是就可以比之前多发 4 个，所以这一次能够发送 8 个。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/27.jpg" alt="慢启动算法">慢启动算法</p>
<p>可以看出慢启动算法，发包的个数是<strong>指数性的增长</strong>。</p>
<blockquote>
<p>那慢启动涨到什么时候是个头呢？</p>
</blockquote>
<p>有一个叫慢启动门限 <code>ssthresh</code> （slow start threshold）状态变量。</p>
<ul>
<li>当 <code>cwnd</code> &lt; <code>ssthresh</code> 时，使用慢启动算法。</li>
<li>当 <code>cwnd</code> &gt;= <code>ssthresh</code> 时，就会使用「拥塞避免算法」。</li>
</ul>
<h4 id="拥塞避免算法"><a href="#拥塞避免算法" class="headerlink" title="拥塞避免算法"></a>拥塞避免算法</h4><p>前面说道，当拥塞窗口 <code>cwnd</code> 「超过」慢启动门限 <code>ssthresh</code> 就会进入拥塞避免算法。</p>
<p>一般来说 <code>ssthresh</code> 的大小是 <code>65535</code> 字节。</p>
<p>那么进入拥塞避免算法后，它的规则是：<strong>每当收到一个 ACK 时，cwnd 增加 1/cwnd。</strong></p>
<p>接上前面的慢启动的栗子，现假定 <code>ssthresh</code> 为 <code>8</code>：</p>
<ul>
<li>当 8 个 ACK 应答确认到来时，每个确认增加 1/8，8 个 ACK 确认 cwnd 一共增加 1，于是这一次能够发送 9 个 <code>MSS</code> 大小的数据，变成了<strong>线性增长。</strong></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/28.jpg" alt="拥塞避免">拥塞避免</p>
<p>所以，我们可以发现，拥塞避免算法就是将原本慢启动算法的指数增长变成了线性增长，还是增长阶段，但是增长速度缓慢了一些。</p>
<p>就这么一直增长着后，网络就会慢慢进入了拥塞的状况了，于是就会出现丢包现象，这时就需要对丢失的数据包进行重传。</p>
<p>当触发了重传机制，也就进入了「拥塞发生算法」。</p>
<h4 id="拥塞发生"><a href="#拥塞发生" class="headerlink" title="拥塞发生"></a>拥塞发生</h4><p>当网络出现拥塞，也就是会发生数据包重传，重传机制主要有两种：</p>
<ul>
<li>超时重传</li>
<li>快速重传</li>
</ul>
<p>这两种使用的拥塞发送算法是不同的，接下来分别来说说。</p>
<blockquote>
<p>发生超时重传的拥塞发生算法</p>
</blockquote>
<p>当发生了「超时重传」，则就会使用拥塞发生算法。</p>
<p>这个时候，ssthresh 和 cwnd 的值会发生变化：</p>
<ul>
<li><code>ssthresh</code> 设为 <code>cwnd/2</code>，</li>
<li><code>cwnd</code> 重置为 <code>1</code></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/29.jpg" alt="拥塞发送 —— 超时重传">拥塞发送 —— 超时重传</p>
<p>接着，就重新开始慢启动，慢启动是会突然减少数据流的。这真是一旦「超时重传」，马上回到解放前。但是这种方式太激进了，反应也很强烈，会造成网络卡顿。</p>
<p>就好像本来在秋名山高速漂移着，突然来个紧急刹车，轮胎受得了吗。。。</p>
<blockquote>
<p>发生快速重传的拥塞发生算法</p>
</blockquote>
<p>还有更好的方式，前面我们讲过「快速重传算法」。当接收方发现丢了一个中间包的时候，发送三次前一个包的 ACK，于是发送端就会快速地重传，不必等待超时再重传。</p>
<p>TCP 认为这种情况不严重，因为大部分没丢，只丢了一小部分，则 <code>ssthresh</code> 和 <code>cwnd</code> 变化如下：</p>
<ul>
<li><code>cwnd = cwnd/2</code> ，也就是设置为原来的一半;</li>
<li><code>ssthresh = cwnd</code>;</li>
<li>进入快速恢复算法</li>
</ul>
<h4 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h4><p>快速重传和快速恢复算法一般同时使用，快速恢复算法是认为，你还能收到 3 个重复 ACK 说明网络也不那么糟糕，所以没有必要像 <code>RTO</code> 超时那么强烈。</p>
<p>正如前面所说，进入快速恢复之前，<code>cwnd</code> 和 <code>ssthresh</code> 已被更新了：</p>
<ul>
<li><code>cwnd = cwnd/2</code> ，也就是设置为原来的一半;</li>
<li><code>ssthresh = cwnd</code>;</li>
</ul>
<p>然后，进入快速恢复算法如下：</p>
<ul>
<li>拥塞窗口 <code>cwnd = ssthresh + 3</code> （ 3 的意思是确认有 3 个数据包被收到了）；</li>
<li>重传丢失的数据包；</li>
<li>如果再收到重复的 ACK，那么 cwnd 增加 1；</li>
<li>如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/30.jpg" alt="快速重传和快速恢复">快速重传和快速恢复</p>
<p>也就是没有像「超时重传」一夜回到解放前，而是还在比较高的值，后续呈线性增长。</p>
<h4 id="拥塞算法示意图"><a href="#拥塞算法示意图" class="headerlink" title="拥塞算法示意图"></a>拥塞算法示意图</h4><p>好了，以上就是拥塞控制的全部内容了，看完后，你再来看下面这张图片，每个过程我相信你都能明白：</p>
<p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/31.png" alt="TCP 拥塞控制">TCP 拥塞控制</p>
<h2 id="统计在文件夹-root-下，包含“word”的文件的个数"><a href="#统计在文件夹-root-下，包含“word”的文件的个数" class="headerlink" title="统计在文件夹/root 下，包含“word”的文件的个数"></a>统计在文件夹/root 下，包含“word”的文件的个数</h2><ul>
<li>统计当前目录下文件的个数（不包括目录）</li>
</ul>
<p>``$ ls -l | grep “^-“ | wc -l`</p>
<ul>
<li>统计当前目录下文件的个数（包括子目录）</li>
</ul>
<p>``$ ls -lR| grep “^-“ | wc -l`</p>
<ul>
<li>查看某目录下文件夹(目录)的个数（包括子目录）</li>
</ul>
<p>``$ ls -lR | grep “^d” | wc -l`</p>
<ul>
<li><code>grep &quot;^-&quot;</code><br>  过滤<code>ls</code>的输出信息，只保留一般文件，只保留目录是<code>grep &quot;^d&quot;</code>。</li>
<li><code>wc -l</code><br>  统计输出信息的行数，统计结果就是输出信息的行数，一行信息对应一个文件，所以就是文件的个数。</li>
</ul>
<h2 id="MySQL的调优"><a href="#MySQL的调优" class="headerlink" title="MySQL的调优"></a>MySQL的调优</h2><h2 id="现有100亿个QQ号，如何快速判断某个QQ号是否在其中，存储方式自己考虑，越快越好（运行时间），空间越小越好。"><a href="#现有100亿个QQ号，如何快速判断某个QQ号是否在其中，存储方式自己考虑，越快越好（运行时间），空间越小越好。" class="headerlink" title="现有100亿个QQ号，如何快速判断某个QQ号是否在其中，存储方式自己考虑，越快越好（运行时间），空间越小越好。"></a>现有100亿个QQ号，如何快速判断某个QQ号是否在其中，存储方式自己考虑，越快越好（运行时间），空间越小越好。</h2><p>mapreduce</p>
<p>Len(qq—nums) 5 6 7 8 9 10 11 划分片段</p>
<p>分治 </p>
<p>位图法：40 亿个不重复整数，我们用 40 亿个 bit 来表示，初始位均为 0，那么总共需要内存：4,000,000,000b≈512M。我们读取这 40 亿个整数，将对应的 bit 设置为 1。接着读取要查询的数，查看相应位是否为 1，如果为 1 表示存在，如果为 0 表示不存在。</p>
<p>可以hash一下，拆分成N多库N多表N多机器，比如一台机器分配100万用户，查询毫无压力吧。再说登录并发不算高，谁没事登着玩啊。</p>
<h2 id="迭代器-1"><a href="#迭代器-1" class="headerlink" title="迭代器"></a>迭代器</h2><p>是访问集合元素的一种方式，从集合的第一个元素开始访问，直到所有元素被访问结束。其优点是不需要事先准备好整个迭代过程中的所有元素，仅在迭代到某个元素时才开始计算该元素。适合遍历比较巨大的集合。<strong>iter</strong>()：方法返回迭代器本身， <strong>next</strong>()：方法用于返回容器中下一个元素或数据。</p>
<h2 id="生成器-1"><a href="#生成器-1" class="headerlink" title="生成器"></a>生成器</h2><p>带有yield的函数不再是一个普通函数，而是一个生成器。当函数被调用时，返回一个生成器对象。不像一般函数在生成值后退出，生成器函数在生成值后会自动挂起并暂停他们的执行状态。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;迭代器&#x27;&#x27;&#x27;</span></span><br><span class="line">print(<span class="string">&#x27;for x in iter([1, 2, 3, 4, 5]):&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">iter</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]):</span><br><span class="line">    print(x)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;生成器&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myyield</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">while</span> n&gt;<span class="number">0</span>:</span><br><span class="line">        print(<span class="string">&quot;开始生成...:&quot;</span>)</span><br><span class="line">        <span class="keyword">yield</span> n</span><br><span class="line">        print(<span class="string">&quot;完成一次...:&quot;</span>)</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> myyield(<span class="number">4</span>):</span><br><span class="line">    print(<span class="string">&quot;遍历得到的值:&quot;</span>,i)</span><br></pre></td></tr></table></figure>



<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包可以实现先将一个参数传递给一个函数，而并不立即执行，以达到延迟求值的目的。</p>
<p>满足以下三个条件：必须有一个内嵌函数；内嵌函数必须引用外部函数中变量；外部函数返回值必须是内嵌函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delay_fun</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">caculator</span>():</span></span><br><span class="line">        <span class="keyword">return</span> x+y</span><br><span class="line">    <span class="keyword">return</span> caculator</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;返回一个求和的函数，并不求和&#x27;</span>)</span><br><span class="line">msum = delay_fun(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">print(<span class="string">&#x27;调用并求和:&#x27;</span>)</span><br><span class="line">print(msum())</span><br></pre></td></tr></table></figure>

<h2 id="args-和-kwargs"><a href="#args-和-kwargs" class="headerlink" title="**args 和 *kwargs"></a>*<em>*args 和 *<em>kwargs</em></em></h2><p>这两个是Python中的可变参数，用于接受参数的传递。<em>args表示任何多个无名参数，它是一个元组，**kwargs表示关键字参数，它是一个字典。同时使用</em>args和<strong>kwargs时，必须*args在</strong>kwargs之前</p>
<h2 id="property-和-setter"><a href="#property-和-setter" class="headerlink" title="@property 和 @setter"></a><strong>@property 和 @setter</strong></h2><p>@property负责把一个方法变成属性调用。在对实例操作时，不暴露接口，而是通过getter和setter方法实现。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._score</span><br><span class="line"></span><br><span class="line"><span class="meta">    @score.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(value, <span class="built_in">int</span>):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;score must be an intager&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> value&lt;<span class="number">0</span> <span class="keyword">or</span> value&gt;<span class="number">100</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;score must between 0~100!&#x27;</span>)</span><br><span class="line">        self._score = value</span><br><span class="line"></span><br><span class="line">s = Student()</span><br><span class="line">s.score = <span class="number">60</span></span><br><span class="line">print(s.score)</span><br><span class="line">s.score = <span class="number">999</span></span><br><span class="line">print(s.score)</span><br></pre></td></tr></table></figure>



<h2 id="Python-方法"><a href="#Python-方法" class="headerlink" title="Python 方法"></a>Python 方法</h2><p>Python中有三种方法，实例方法、类方法(@classmethod)、静态方法(@staticmethod)。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        print(<span class="string">&quot;executing foo(%s,%s)&quot;</span> % (self, x))</span><br><span class="line">        print(<span class="string">&#x27;self:&#x27;</span>, self)</span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">class_foo</span>(<span class="params">cls, x</span>):</span></span><br><span class="line">        print(<span class="string">&quot;executing class_foo(%s,%s)&quot;</span> % (cls, x))</span><br><span class="line">        print(<span class="string">&#x27;cls:&#x27;</span>, cls)</span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">static_foo</span>(<span class="params">x</span>):</span></span><br><span class="line">        print(<span class="string">&quot;executing static_foo(%s)&quot;</span> % x)</span><br><span class="line">a = A()</span><br><span class="line">print(a.foo(<span class="number">1</span>))</span><br><span class="line">print(a.class_foo(<span class="number">1</span>))</span><br><span class="line">print(a.static_foo(<span class="number">1</span>))</span><br></pre></td></tr></table></figure>



<h2 id="import之类的知识点"><a href="#import之类的知识点" class="headerlink" title="import之类的知识点"></a>import之类的知识点</h2><p> 模块（Module）和 <strong>包（Package）</strong> </p>
<ul>
<li>模块<ul>
<li>不管是对常见的<code>*.py</code>文件，或是编译优化的<code>*.pyc</code>, <code>*.pyo</code>文件、扩展类型的<code>*.pyd</code>，<code>*.pyw</code>文件来说， 它们是属于Python代码载体的最小单元，这样单独存在的文件我们都称之为“模块”。</li>
</ul>
</li>
<li>包<ul>
<li> import 导入该目录时，会执行 <strong>__init__.py</strong> 里面的代码。</li>
</ul>
</li>
</ul>
<h2 id="Python进程、线程、协程概念"><a href="#Python进程、线程、协程概念" class="headerlink" title="Python进程、线程、协程概念"></a>Python进程、线程、协程概念</h2><h3 id="一、进程"><a href="#一、进程" class="headerlink" title="一、进程"></a>一、进程</h3><h3 id="进程的概念"><a href="#进程的概念" class="headerlink" title="进程的概念"></a>进程的概念</h3><h3 id="1-进程是一个实体。每个进程都有自己的地址空间-CPU分配-。实体空间包括三部分："><a href="#1-进程是一个实体。每个进程都有自己的地址空间-CPU分配-。实体空间包括三部分：" class="headerlink" title="1.进程是一个实体。每个进程都有自己的地址空间(CPU分配)。实体空间包括三部分："></a>1.进程是一个实体。每个进程都有自己的地址空间(CPU分配)。实体空间包括三部分：</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 文本区域：存储处理器执行的代码。</span><br><span class="line">* 数据区域：存储变量或进程执行期间使用的动态分配的内存。</span><br><span class="line">* 堆栈：进程执行时调用的指令和本地变量。</span><br></pre></td></tr></table></figure>

<h3 id="2-进程是一个“执行中的程序”。"><a href="#2-进程是一个“执行中的程序”。" class="headerlink" title="2.进程是一个“执行中的程序”。"></a>2.进程是一个“执行中的程序”。</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">程序是指令与数据的有序集合,程序本身是没有生命的,只有CPU赋予程序生命时(CPU执行程序),它才能成为一个活动的实体,称为“进程”。</span><br></pre></td></tr></table></figure>

<p><strong>概括来说，进程就是一个具有独立功能的程序在某个数据集上的一次运行活动</strong></p>
<h3 id="进程的特点"><a href="#进程的特点" class="headerlink" title="进程的特点"></a>进程的特点</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 动态性：进程是程序的一次执行过程，动态产生，动态消亡。</span><br><span class="line">* 独立性：进程是一个能独立运行的基本单元。是系统分配资源与调度的基本单元。</span><br><span class="line">* 并发性：任何进程都可以与其他进程并发执行。</span><br></pre></td></tr></table></figure>

<h2 id="二、并发与并行"><a href="#二、并发与并行" class="headerlink" title="二、并发与并行"></a>二、并发与并行</h2><p><strong>并发：在操作系统中，某一时间段，几个程序在同一个CPU上运行，但在任意一个时间点上，只有一个程序在CPU上运行。</strong></p>
<p>当有多个线程时，如果系统只有一个CPU，那么CPU不可能真正同时进行多个线程，CPU的运行时间会被划分成若干个时间段，每个时间段分配给各个线程去执行，一个时间段里某个线程运行时，其他线程处于挂起状态，这就是并发。并发解决了程序排队等待的问题，如果一个程序发生阻塞，其他程序仍然可以正常执行。</p>
<p><strong>并行：当操作系统有多个CPU时，一个CPU处理A线程，另一个CPU处理B线程，两个线程互相不抢占CPU资源，可以同时进行，这种方式成为并行。</strong></p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>并发只是在宏观上给人感觉有多个程序在同时运行，但在实际的单CPU系统中，每一时刻只有一个程序在运行，微观上这些程序是分时交替执行。<br>在多CPU系统中，将这些并发执行的程序分配到不同的CPU上处理，每个CPU用来处理一个程序，这样多个程序便可以实现同时执行。</p>
<h2 id="三、线程"><a href="#三、线程" class="headerlink" title="三、线程"></a>三、线程</h2><h3 id="3-1、线程的引入"><a href="#3-1、线程的引入" class="headerlink" title="3.1、线程的引入"></a>3.1、线程的引入</h3><p>60年代，操作系统中拥有资源并独立运行的基本单位是进程，进程是资源的拥有者，进程的创建、撤销、切换花销太大。多CPU处理出现，可以满足多个单位同时运行，但是多个进程并行花销太大。80年代，出现了<strong>轻量级的，能够独立运行的基本单位，线程。</strong></p>
<h3 id="3-2、线程的概念"><a href="#3-2、线程的概念" class="headerlink" title="3.2、线程的概念"></a>3.2、线程的概念</h3><ul>
<li><strong>线程是进程中的一个实体，是被系统独立调度和分派的基本单位。</strong> 线程的实体包括程序，数据，TCB。TCB包括：</li>
</ul>
<ol>
<li>线程状态</li>
<li>线程不运行时，被保存的现场资源</li>
<li>一组执行堆栈</li>
<li>每个线程的局部变量</li>
<li>访问统一进程中的资源</li>
</ol>
<ul>
<li><strong>线程自己不拥有系统资源，只拥有一点运行中必不可少的资源。</strong></li>
<li><strong>同一进程中的多个线程并发执行，这些线程共享进程所拥有的资源。</strong></li>
</ul>
<h3 id="3-3、进程与线程的区别"><a href="#3-3、进程与线程的区别" class="headerlink" title="3.3、进程与线程的区别"></a>3.3、进程与线程的区别</h3><ul>
<li>进程是CPU资源分配的基本单位，线程是独立运行和独立调度的基本单位（CPU上真正运行的是线程）。</li>
<li>进程拥有自己的资源空间，一个进程包含若干个线程，线程与CPU资源分配无关，多个线程共享同一进程内的资源。</li>
<li>线程的调度与切换比进程快很多。</li>
</ul>
<h3 id="四、协程"><a href="#四、协程" class="headerlink" title="四、协程"></a>四、协程</h3><p><strong>协程是一种比线程更加轻量级的存在，最重要的是，协程不被操作系统内核管理，协程是完全由程序控制的。</strong></p>
<p><em>运行效率极高，协程的切换完全由程序控制，不像线程切换需要花费操作系统的开销,线程数量越多，协程的优势就越明显。</em></p>
<p>协程不需要多线程的锁机制，因为只有一个线程，不存在变量冲突。</p>
<p>对于多核CPU，利用多进程+协程的方式，能充分利用CPU，获得极高的性能。</p>
<p>如果一个线程等待某些条件，可以充分利用这个时间去做其它事情，其实这就是：协程方式</p>
<ul>
<li>进程是资源分配的单位</li>
<li>线程是操作系统调度的单位</li>
<li>进程切换需要的资源很最大，效率很低</li>
<li>线程切换需要的资源一般，效率一般（当然了在不考虑GIL的情况下）</li>
<li>协程切换任务资源很小，效率高</li>
<li>多进程、多线程根据cpu核数不一样可能是并行的，但是协程是在一个线程中，所以是并发</li>
</ul>

    </div>

    
    
    
      

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Ashin Wang
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://www.ashin.wang/sxf/" title="sxf">https://www.ashin.wang/sxf/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/leetcode/" rel="prev" title="leetcode">
      <i class="fa fa-chevron-left"></i> leetcode
    </a></div>
      <div class="post-nav-item">
    <a href="/hexo-build/" rel="next" title="Hexo框架搭建+GitHub托管笔记">
      Hexo框架搭建+GitHub托管笔记 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%94%E8%AF%95"><span class="nav-text">笔试</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E9%81%93%E7%BC%96%E7%A8%8B%E9%A2%98"><span class="nav-text">第一道编程题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2%E9%97%AE%E9%A2%98"><span class="nav-text">零钱兑换问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%85%E8%A1%8C%E5%AE%B6%E9%97%AE%E9%A2%98"><span class="nav-text">旅行家问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%A8%E5%B8%88%E5%81%9A%E9%A5%AD-LRU"><span class="nav-text">厨师做饭(LRU)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%96%B9%E6%A1%88%E6%95%B0"><span class="nav-text">小机器人方案数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-text">206. 反转链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%97%E8%A1%A8%E5%88%86%E5%AD%90"><span class="nav-text">列表分子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%92%95%E4%BB%A3%E7%A0%81%EF%BC%8C%E5%BF%AB%E9%80%9F-%E6%8E%92%E5%BA%8F"><span class="nav-text">撕代码，快速[排序]</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-text">插入排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9E%E6%96%87%E6%95%B0"><span class="nav-text">回文数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-text">前中后序遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%EF%BC%8C%E8%AF%BB%E6%95%B0%E6%8D%AE%E5%92%8C%E5%86%99%E6%95%B0%E6%8D%AE"><span class="nav-text">类，读数据和写数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E6%88%90%E9%93%BE%E8%A1%A8%E5%86%8D%E5%8E%BB%E9%87%8D"><span class="nav-text">数组转换成链表再去重</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="nav-text">最长回文子串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E7%94%A8%EF%BC%8B%E5%8F%B7%E5%AE%9E%E7%8E%B0a-b"><span class="nav-text">不用＋号实现a+b</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84%EF%BC%8C%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F"><span class="nav-text">链表结构，链表排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%99%E4%B8%80%E4%B8%AA%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="nav-text">写一个装饰器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#146-LRU-%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6"><span class="nav-text">146. LRU 缓存机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%90%E5%BA%8F%E5%88%97%E7%AE%97%E6%B3%95"><span class="nav-text">子序列算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#232-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="nav-text">232. 用栈实现队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#225-%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88"><span class="nav-text">225. 用队列实现栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#155-%E6%9C%80%E5%B0%8F%E6%A0%88"><span class="nav-text">155. 最小栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-II"><span class="nav-text">40. 组合总和 II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E5%AD%97%E6%95%B0"><span class="nav-text">字符串中所有字符出现字数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="nav-text">运行时间装饰器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%B3%E5%8F%B0%E9%98%B6"><span class="nav-text">跳台阶</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">最大回文字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%9B%E6%89%A321-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F-%E9%93%BE%E8%A1%A8"><span class="nav-text">力扣21 - 合并两个有序[链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E9%80%86%E8%BD%AC%E4%B8%8B%E6%A0%87%E7%94%B1m%E5%88%B0n%E4%B9%8B%E9%97%B4%E7%9A%84%E8%8A%82%E7%82%B9"><span class="nav-text">单链表逆转下标由m到n之间的节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%85%B3%EF%BC%88%E5%90%88%E5%B9%B6%EF%BC%8C%E6%8E%92%E5%BA%8F%EF%BC%8C%E5%8F%8D%E8%BD%AC%EF%BC%89"><span class="nav-text">链表相关（合并，排序，反转）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#99%E4%B9%98%E6%B3%95%E8%A1%A8"><span class="nav-text">99乘法表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#414-%E7%AC%AC%E4%B8%89%E5%A4%A7%E7%9A%84%E6%95%B0"><span class="nav-text">414. 第三大的数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">判断回文字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%94%E5%AD%90%E7%B9%81%E6%AE%96"><span class="nav-text">兔子繁殖</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A0%E9%87%8D%E5%A4%8D%E4%B8%89%E4%BD%8D%E6%95%B0"><span class="nav-text">无重复三位数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1143-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-text">1143. 最长公共子序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Flask-%E5%8A%A0%E6%B3%95"><span class="nav-text">Flask 加法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98%EF%BC%88kmp%E7%AE%97%E6%B3%95%EF%BC%89%E6%88%91%E4%B8%BB%E5%8A%A8%E5%86%99%E4%BA%86%E4%B8%80%E4%B8%8B%E4%BB%A3%E7%A0%81"><span class="nav-text">字符串匹配问题（kmp算法）我主动写了一下代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%BE%E5%87%BA%E4%B8%8D%E5%90%8C%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9B%B8%E5%90%8C%E7%9A%84IP%E5%9C%B0%E5%9D%80"><span class="nav-text">找出不同文件中相同的IP地址</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%AF%94%E8%BE%83"><span class="nav-text">排序算法比较</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F-BubbleSort"><span class="nav-text">1 冒泡排序_BubbleSort</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F-SelectionSort"><span class="nav-text">2 选择排序_SelectionSort</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F-InsertionSort"><span class="nav-text">3 插入排序_InsertionSort</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F-ShellSort"><span class="nav-text">4 希尔排序_ShellSort</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F-MergeSort"><span class="nav-text">5 归并排序_MergeSort</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-QuickSort"><span class="nav-text">6 快速排序_QuickSort</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E5%A0%86%E6%8E%92%E5%BA%8F-HeapSort"><span class="nav-text">7 堆排序_HeapSort</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F-CountingSort"><span class="nav-text">8 计数排序_CountingSort</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-%E6%A1%B6%E6%8E%92%E5%BA%8F-BucketSort"><span class="nav-text">9 桶排序_BucketSort</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F-RadixSort"><span class="nav-text">10 基数排序_RadixSort</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95"><span class="nav-text">面试</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95"><span class="nav-text">数据结构算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hashmap%E5%A4%84%E7%90%86%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E7%9A%84%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95"><span class="nav-text">Hashmap处理哈希冲突的分析方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%80%E6%94%BE%E5%AE%9A%E5%9D%80%E6%B3%95"><span class="nav-text">开放定址法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E8%A1%8C%E6%8E%A2%E6%9F%A5%E6%B3%95"><span class="nav-text">线行探查法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B3%E6%96%B9%E6%8E%A2%E6%9F%A5%E6%B3%95"><span class="nav-text">平方探查法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8C%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0%E6%8E%A2%E6%9F%A5%E6%B3%95"><span class="nav-text">双散列函数探查法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E5%9C%B0%E5%9D%80%E6%B3%95%EF%BC%88%E6%8B%89%E9%93%BE%E6%B3%95%EF%BC%89"><span class="nav-text">链地址法（拉链法）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%8D%E5%93%88%E5%B8%8C%E6%B3%95"><span class="nav-text">再哈希法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BB%BA%E7%AB%8B%E5%85%AC%E5%85%B1%E6%BA%A2%E5%87%BA%E5%8C%BA"><span class="nav-text">建立公共溢出区</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%8C%E5%A4%A7%E5%A0%86%EF%BC%8C%E5%B0%8F%E5%A0%86%EF%BC%8C%E5%A0%86%E6%8E%92%E5%BA%8F%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-text">堆排序，大堆，小堆，堆排序的原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%9F%E8%AE%A1%E4%B8%80%E7%AF%87%E8%AE%BA%E6%96%87%EF%BC%8C%E5%89%8D%E9%9D%A2%E5%87%BA%E7%8E%B0%E5%89%8D%E5%8D%81%E7%9A%84%E5%8D%95%E8%AF%8D%E3%80%82Counter-List"><span class="nav-text">统计一篇论文，前面出现前十的单词。Counter(), List</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%83%E7%BB%84%E5%92%8C%E5%88%97%E8%A1%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">元组和列表的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-text">装饰器的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Python2%E5%92%8CPython3%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">Python2和Python3之间的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Python%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-text">Python的优缺点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8F%90%E9%AB%98Python%E8%BF%90%E8%A1%8C%E6%95%88%E7%8E%87%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-text">提高Python运行效率的方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A4%E5%88%AB%E4%B8%A4%E4%B8%AA%E7%B1%BB%E5%88%AB%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">判别两个类别的字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tcp%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E7%9A%84%E4%B8%89%E4%B8%AA%E6%B5%81%E7%A8%8B"><span class="nav-text">tcp保证数据传输的三个流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="nav-text">tcp 三次握手</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="nav-text">为什么三次握手</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="nav-text">四次挥手</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E5%8E%9F%E5%9B%A0"><span class="nav-text">四次挥手原因</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CLOSE-WAIT%E7%8A%B6%E6%80%81%E7%9A%84%E5%90%AB%E4%B9%89%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%87%BA%E7%8E%B0%E8%BF%87%E5%A4%9AC-W%E7%8A%B6%E6%80%81%EF%BC%8C%E8%AF%A5%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86"><span class="nav-text">CLOSE-WAIT状态的含义，如果服务端出现过多C-W状态，该如何处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E5%87%BA%E7%8E%B0%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-text">1.1 出现的原因</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E5%A4%A7%E9%87%8Ftime-wait%E7%9A%84%E5%8D%B1%E5%AE%B3"><span class="nav-text">1.2.大量time_wait的危害</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E5%A4%A7%E9%87%8Ftime-wait%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-text">1.3.大量time_wait解决方案</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C-%E5%A4%A7%E9%87%8Fclose-wait%E7%9A%84%E5%87%BA%E7%8E%B0"><span class="nav-text">二. 大量close_wait的出现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E5%87%BA%E7%8E%B0%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-text">2.1 出现的原因和解决方案</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B"><span class="nav-text">常见的网络模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E4%B8%89%E7%BA%A7%E8%BD%AC%E5%8F%91"><span class="nav-text">二、三级转发</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-UDP"><span class="nav-text">TCP&#x2F;UDP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#python%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-text">python垃圾回收</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%85%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="nav-text">浅、深拷贝</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10%E4%BA%BF%E4%B8%AA%E6%95%B0%E5%8F%96%E6%9C%80%E5%A4%A7%E7%9A%8410%E4%B8%AA%E6%80%8E%E4%B9%88%E5%8F%96%EF%BC%8C%E8%AF%B4%E4%B8%89%E7%A7%8D%E6%96%B9%E6%A1%88"><span class="nav-text">10亿个数取最大的10个怎么取，说三种方案</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#linux%E5%91%BD%E4%BB%A4%E8%AF%B4%E5%87%A0%E4%B8%AA"><span class="nav-text">linux命令说几个</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E7%9B%AE%E7%9A%84"><span class="nav-text">分库分表目的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Python%E9%94%81"><span class="nav-text">Python锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E5%99%A8"><span class="nav-text">生成器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E6%93%8D%E4%BD%9C%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-text">数组链表的区别，操作的复杂度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%99%E4%B8%80%E4%B8%AA%E6%8E%92%E5%BA%8F%EF%BC%88%E9%9A%8F%E6%84%8F%EF%BC%89%EF%BC%8C%E5%8F%8A%E6%9C%89%E5%85%B3%E8%AF%A5%E6%8E%92%E5%BA%8F%E7%9A%84%E4%B8%80%E7%B3%BB%E5%88%97%E9%97%AE%E9%A2%98"><span class="nav-text">写一个排序（随意），及有关该排序的一系列问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%89%B9%E6%80%A7%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="nav-text">数据库的特性，如何实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mysql%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0"><span class="nav-text">mysql索引的原理及实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTPS%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%AE%89%E5%85%A8%E6%80%A7"><span class="nav-text">HTTPS如何实现安全性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SSL-%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95"><span class="nav-text">SSL 加密算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Python-%E7%BB%8F%E5%B8%B8%E4%BD%BF%E7%94%A8%E7%9A%84%E5%8C%85"><span class="nav-text">Python 经常使用的包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9F%A5%E9%81%93dict%E5%92%8Cset%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%90%97%EF%BC%9F"><span class="nav-text">知道dict和set的底层原理吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%AE%E8%AF%BE%E4%BD%99%E7%94%9F%E6%B4%BB%E5%B9%B2%E4%BB%80%E4%B9%88%EF%BC%9F%EF%BC%88%E5%BC%BA%E8%B0%83%E9%99%A4%E4%BA%86%E5%AD%A6%E4%B9%A0%EF%BC%89"><span class="nav-text">问课余生活干什么？（强调除了学习）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%EF%BC%8Cb-%E6%A0%91%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%8C%E4%B8%8Ehash%E7%B4%A2%E5%BC%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%BC%82%E5%90%8C"><span class="nav-text">数据库索引，b+树的特点，与hash索引有什么异同</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%91%E7%8E%B0%E6%9F%90%E4%B8%80%E4%B8%AA%E8%A1%A8%E6%9F%A5%E8%AF%A2%E5%BE%88%E6%85%A2%E5%8F%AF%E8%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8E%9F%E5%9B%A0"><span class="nav-text">数据库发现某一个表查询很慢可能有哪些原因</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80-%E8%AE%BE%E8%AE%A1%E6%88%96%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98"><span class="nav-text">一.设计或编码问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C-%E6%9C%BA%E5%99%A8%E8%B5%84%E6%BA%90%E9%97%AE%E9%A2%98"><span class="nav-text">二. 机器资源问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89-%E9%AB%98%E5%B9%B6%E5%8F%91%E9%87%8F%E5%AF%BC%E8%87%B4"><span class="nav-text">三. 高并发量导致</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10%E4%BA%BF%E4%B8%AAurl%E6%80%8E%E4%B9%88%E6%9F%A5%E8%AF%A2%E6%9F%90%E4%B8%80%E4%B8%AAurl%E6%98%AF%E5%90%A6%E5%9C%A8%E5%85%B6%E4%B8%AD"><span class="nav-text">10亿个url怎么查询某一个url是否在其中</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E7%94%A8%E6%95%A3%E5%88%97%E8%A1%A8"><span class="nav-text">为什么不能用散列表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="nav-text">布隆过滤器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Python%E4%BA%86%E8%A7%A3%E5%93%AA%E4%BA%9B%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="nav-text">Python了解哪些底层原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E8%BF%87%E9%AB%98"><span class="nav-text">如果进程内存使用过高</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8-new-%E8%BF%99%E7%A7%8D%E9%AD%94%E6%B3%95%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%EF%BC%8C%E5%86%99%E4%BC%AA%E4%BB%A3%E7%A0%81"><span class="nav-text">用__new__()这种魔法函数实现单例，写伪代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%BA%E6%99%AF%E9%A2%98%EF%BC%9A%E8%AE%BE%E8%AE%A1%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%AA%E5%BC%80%E4%BA%86%E4%B8%80%E4%B8%AA%E7%AB%AF%E5%8F%A3%EF%BC%8C%E4%BD%86%E8%A6%81%E5%9C%A8%E4%B8%80%E5%88%86%E9%92%9F%E5%86%85%E5%A4%84%E7%90%86%E4%B8%8A%E4%B8%87%E7%9A%84%E8%AF%B7%E6%B1%82%EF%BC%8C%E7%94%A8Python%E8%AF%A5%E5%A4%84%E7%90%86%E8%BF%99%E7%A7%8D%E4%B8%8A%E4%B8%87%E7%BA%A7%E7%9A%84%E8%AF%B7%E6%B1%82"><span class="nav-text">场景题：设计服务器，服务器只开了一个端口，但要在一分钟内处理上万的请求，用Python该处理这种上万级的请求</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E5%85%A8%E8%BF%87%E7%A8%8B"><span class="nav-text">浏览器输入URL全过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B7%E6%B1%82%E7%9A%84%E5%93%8D%E5%BA%94%E9%80%9F%E5%BA%A6%E8%BF%87%E6%85%A2"><span class="nav-text">请求的响应速度过慢</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE%E5%BA%93%E6%85%A2%E6%9F%A5%E8%AF%A2"><span class="nav-text">如何分析数据库慢查询</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E9%87%8C%E7%9A%84%E6%AF%8F%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E6%9C%80%E5%A4%9A%E5%8F%AF%E4%BB%A5%E7%94%B3%E8%AF%B7%E5%A4%9A%E5%B0%91%E7%9A%84%E7%A9%BA%E9%97%B4"><span class="nav-text">程序里的每一个进程最多可以申请多少的空间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%BF%87%E5%A4%9A%E5%8D%8F%E7%A8%8B%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%8D%A1%E6%AD%BB%EF%BC%8C%E6%83%B3%E8%A6%81%E5%AE%9A%E4%BD%8D%E5%87%BA%E9%94%99%E7%9A%84%E7%82%B9%EF%BC%8C%E6%80%8E%E6%A0%B7%E5%88%A4%E6%96%AD%E6%95%B4%E4%B8%AA%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E5%86%B5"><span class="nav-text">多线程过多协程，如果卡死，想要定位出错的点，怎样判断整个进程的状况</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#namespace%E5%92%8Centrypoint"><span class="nav-text">namespace和entrypoint</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#slots-%EF%BC%88%EF%BC%89%E6%98%AF%E7%94%A8%E6%9D%A5%E5%AE%9A%E4%B9%89%E4%BB%80%E4%B9%88%E7%9A%84"><span class="nav-text">__slots__（）是用来定义什么的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Python%E5%8D%8F%E7%A8%8B%E5%8E%9F%E7%90%86"><span class="nav-text">Python协程原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Django%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E6%80%9D%E7%BB%B4%EF%BC%8C%E8%AE%BE%E8%AE%A1%E6%9C%BA%E5%88%B6"><span class="nav-text">Django框架设计思维，设计机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Mysql%E4%B8%ADB%E6%A0%91%E5%92%8CB-%E6%A0%91%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%92%8C%E5%8C%BA%E5%88%AB"><span class="nav-text">Mysql中B树和B+树的使用场景和区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E4%B8%80%E5%BC%A0%E8%A1%A8%EF%BC%8C%E8%BF%99%E5%BC%A0%E8%A1%A8%E6%9C%80%E5%A4%9A%E5%8F%AF%E4%BB%A5%E5%AD%98%E5%A4%9A%E5%B0%91%E6%9D%A1%E6%95%B0%E6%8D%AE%EF%BC%8C%E8%BF%99%E6%98%AF%E7%94%B1%E4%BB%80%E4%B9%88%E5%86%B3%E5%AE%9A%E7%9A%84"><span class="nav-text">定义一张表，这张表最多可以存多少条数据，这是由什么决定的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E5%BA%93%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%8C%E6%98%AF%E5%90%A6%E7%94%A8%E5%88%B0%E4%BA%86%E4%B8%BB%E4%BB%8E%E6%9C%BA%E5%88%B6"><span class="nav-text">项目中如何保证数据库高可用，是否用到了主从机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D%E9%A1%B9%E7%9B%AE%EF%BC%8C%E7%94%A8%E6%88%B7%E9%87%8F%E5%A2%9E%E5%8A%A0%E5%90%8E%EF%BC%8C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E5%9E%8B%E5%8F%AF%E4%BB%A5%E4%BB%8E%E5%93%AA%E4%BA%9B%E5%9C%B0%E6%96%B9%E8%BF%9B%E8%A1%8C%E6%94%B9%E8%BF%9B%EF%BC%8C%E6%9C%89%E5%8F%82%E8%80%83%E4%B8%9A%E7%95%8C%E5%85%B6%E4%BB%96%E7%B1%BB%E4%BC%BC%E9%9C%80%E6%B1%82%E7%9A%84%E5%B8%B8%E8%A7%81%E5%81%9A%E6%B3%95%E5%90%97%EF%BC%88%E6%97%A0%EF%BC%89%EF%BC%8C%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%BE%97%E5%88%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E6%94%B6%E8%8E%B7"><span class="nav-text">介绍项目，用户量增加后，系统原型可以从哪些地方进行改进，有参考业界其他类似需求的常见做法吗（无），项目中得到的最大收获</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8%EF%BC%8C%E5%A4%9A%E4%B8%AA%E8%A3%85%E9%A5%B0%E5%99%A8%E9%A1%BA%E5%BA%8F%E9%97%AE%E9%A2%98"><span class="nav-text">装饰器，多个装饰器顺序问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%83%E7%B1%BB"><span class="nav-text">元类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E6%96%B9%E6%B3%95%E5%92%8C%E6%99%AE%E9%80%9A%E6%96%B9%E6%B3%95%E5%92%8C%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%EF%BC%8C%E5%B9%B3%E6%97%B6%E6%80%8E%E4%B9%88%E7%94%A8%E7%9A%84"><span class="nav-text">类方法和普通方法和实例方法，平时怎么用的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text">数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%9F%E5%88%97%E5%92%8C%E5%85%83%E7%BB%84%E5%8C%BA%E5%88%AB"><span class="nav-text">队列和元组区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-text">垃圾回收</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#is%E5%92%8C-%E5%8C%BA%E5%88%AB"><span class="nav-text">is和&#x3D;&#x3D;区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#io%E7%9A%84%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="nav-text">io的多路复用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="nav-text">进程通信方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="nav-text">进程状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">数组和链表的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%BA%86%E8%A7%A3%E9%82%A3%E4%BA%9B%EF%BC%9F%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%9F"><span class="nav-text">排序算法了解那些？时间复杂度？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%A3%E6%8E%92%E4%B8%80%E4%B8%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%90%A7"><span class="nav-text">口排一下快速排序吧</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%EF%BC%8C%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%EF%BC%8C%E8%83%BD%E5%90%A6%E7%94%A8kill%E6%9D%80%E6%8E%89%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%EF%BC%8C%E6%80%8E%E4%B9%88%E6%9F%A5%E7%9C%8B%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="nav-text">孤儿进程，僵尸进程，能否用kill杀掉僵尸进程，怎么查看僵尸进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B"><span class="nav-text">孤儿进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="nav-text">僵尸进程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#top%E5%91%BD%E4%BB%A4"><span class="nav-text">top命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#netstat%E5%91%BD%E4%BB%A4"><span class="nav-text">netstat命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1ACID"><span class="nav-text">事务ACID</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E7%9A%84%E9%97%AE%E9%A2%98-%E5%8A%A0%E9%94%81-%EF%BC%8C%E5%8A%A0%E4%BB%80%E4%B9%88%E9%94%81"><span class="nav-text">开发过程中多进程共享文件的问题(加锁)，加什么锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%B1%E4%BF%A1%E6%9C%8D%E8%BF%99%E5%9C%A8%E9%98%B2%E6%8A%A4%E5%A2%99%E9%82%A3%E6%9C%89%E9%BB%91%E5%90%8D%E5%8D%95%EF%BC%8C%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%8C%B9%E9%85%8D%E4%B8%80%E4%B8%AA%EF%BC%88hash%E8%A1%A8%EF%BC%89%E5%A6%82%E6%9E%9C%E6%95%B0%E9%87%8F%E5%BE%88%E5%A4%A7%E5%91%A2%EF%BC%88%E5%88%86%E6%B2%BB%EF%BC%8C%E5%9C%A8hash%EF%BC%89"><span class="nav-text">深信服这在防护墙那有黑名单，如何快速匹配一个（hash表）如果数量很大呢（分治，在hash）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%BF%9B%E7%A8%8B%E5%8D%8F%E7%A8%8B"><span class="nav-text">多线程进程协程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%AE%9E%E4%BE%8B%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="nav-text">静态实例类方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E5%99%A8%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-text">生成器迭代器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-1"><span class="nav-text">垃圾回收</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%97%E8%A1%A8%E5%85%83%E7%BB%84"><span class="nav-text">列表元组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#python%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-text">python的数据结构有哪些</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#python%E5%88%87%E7%89%87"><span class="nav-text">python切片</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%83%E7%BB%84%E5%92%8C%E5%88%97%E8%A1%A8%E7%9A%84%E5%BC%82%E5%90%8C"><span class="nav-text">元组和列表的异同</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%8B%E6%92%95%E5%BF%AB%E6%8E%92%EF%BC%8C%E5%B9%B6%E8%A7%A3%E9%87%8A"><span class="nav-text">手撕快排，并解释</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#python%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6"><span class="nav-text">python的内存管理机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%91%E7%94%9F%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5"><span class="nav-text">发生内存泄漏如何排查</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0%E8%BF%9B%E7%A8%8B%EF%BC%8C%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%92%8C%E5%8D%8F%E7%A8%8B"><span class="nav-text">简述进程，线程，和协程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Python%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%EF%BC%8C%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="nav-text">Python垃圾回收机制，内存机制？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Mysql%E8%AF%AD%E5%8F%A5%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%EF%BC%9FB%E6%A0%91%E5%92%8CB%EF%BC%8B%E6%A0%91%E5%8C%BA%E5%88%AB"><span class="nav-text">Mysql语句如何优化？B树和B＋树区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#new-%E5%92%8C-init-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">__new__和__init__的区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-new-%E5%87%BD%E6%95%B0"><span class="nav-text">1. __ new__函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-init"><span class="nav-text">2. __ init__()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BA%E7%8E%B0bug%E6%80%8E%E4%B9%88%E5%8E%BB%E6%89%BE%E5%88%B0%E5%8E%9F%E5%9B%A0%EF%BC%9F"><span class="nav-text">出现bug怎么去找到原因？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%87%E6%B2%B3%E9%97%AE%E9%A2%98%EF%BC%8CABCD%E5%9B%9B%E4%B8%AA%E4%BA%BA%EF%BC%8C%E5%8D%95%E7%8B%AC%E8%BF%87%E6%B2%B3%E5%88%86%E5%88%AB%E9%9C%80%E8%A6%811%EF%BC%8C2%EF%BC%8C5%EF%BC%8C10%EF%BC%8C%E6%9C%80%E5%A4%9A%E4%B8%A4%E4%B8%AA%E4%BA%BA%E5%90%8C%E6%97%B6%E8%BF%87%EF%BC%8C%E5%B9%B6%E4%B8%94%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E6%89%8B%E7%94%B5%E7%AD%92%EF%BC%8C%E6%AF%8F%E6%AC%A1%E9%83%BD%E9%9C%80%E8%A6%81%E7%94%B5%E7%AD%92%EF%BC%8C%E4%B8%A4%E4%BA%BA%E8%BF%87%E6%B2%B3%E6%8C%89%E6%85%A2%E7%9A%84%E6%97%B6%E9%97%B4%E7%AE%97%EF%BC%8C%E9%97%AE%E6%9C%80%E5%B0%91%E5%87%A0%E5%88%86%E9%92%9F%EF%BC%9F%EF%BC%8817%E5%88%86%E9%92%9F%EF%BC%89%E5%A6%82%E6%9E%9C%E6%9C%89n%E4%B8%AA%E4%BA%BA%E8%BF%87%E6%B2%B3%EF%BC%8C%E6%AF%8F%E4%B8%AA%E4%BA%BA%E8%BF%87%E6%B2%B3%E7%9A%84%E6%97%B6%E9%97%B4%E4%B8%8D%E5%AE%9A%EF%BC%8C%E6%80%8E%E4%B9%88%E7%94%A8%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="nav-text">过河问题，ABCD四个人，单独过河分别需要1，2，5，10，最多两个人同时过，并且只有一个手电筒，每次都需要电筒，两人过河按慢的时间算，问最少几分钟？（17分钟）如果有n个人过河，每个人过河的时间不定，怎么用算法实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8E%E4%B8%80%E4%BA%BF%E4%B8%AAip%E6%89%BE%E5%87%BA%E6%8C%87%E5%AE%9A%E7%9A%84IP%E3%80%82"><span class="nav-text">从一亿个ip找出指定的IP。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84%EF%BC%8C%E5%AD%97%E5%85%B8%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="nav-text">列表和元组，字典的底层实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B4%E4%BA%86%E8%A7%A3web%E5%B8%B8%E8%A7%81%E7%9A%84%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E3%80%81%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%EF%BC%89"><span class="nav-text">说了解web常见的漏洞原理、利用方式）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4SMB%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%B8%8D%E6%98%AF%E5%BE%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="nav-text">说说SMB协议（不是很了解）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%E4%BA%86%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE%EF%BC%88%E5%8D%8F%E8%AE%AE%E7%9B%B8%E5%85%B3%EF%BC%89"><span class="nav-text">详细介绍了自己的一个项目（协议相关）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%8F%E8%AE%AE%E5%B8%B8%E8%A7%81%E7%9A%84%E6%94%BB%E5%87%BB"><span class="nav-text">协议常见的攻击</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFSQL%E6%B3%A8%E5%85%A5"><span class="nav-text">什么是SQL注入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#b%E6%A0%91%E3%80%81b-%E6%A0%91%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="nav-text">b树、b+树、红黑树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%AB%E6%8E%92%E5%92%8C%E5%86%92%E6%B3%A1%E7%9A%84%E6%AF%94%E8%BE%83%EF%BC%88%E5%8F%A3%E8%BF%B0%E5%88%86%E5%88%AB%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%89"><span class="nav-text">快排和冒泡的比较（口述分别怎么实现的）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Try-except-else-finally%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%8Ctry%E4%B8%AD%E4%BD%BF%E7%94%A8return%E4%BA%86%E8%BF%98%E4%BC%9A%E4%B8%8D%E4%BC%9A%E6%89%A7%E8%A1%8Celse-finally"><span class="nav-text">Try except else finally中的问题，try中使用return了还会不会执行else  finally</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-text">python内存管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E6%9C%89%E7%94%A8%E8%BF%87%E4%B9%88%EF%BC%9F%EF%BC%88staticmethod%E5%92%8C%E8%87%AA%E5%B7%B1%E5%86%99%E7%9A%84%E6%97%B6%E9%97%B4%E6%88%B3%E8%A3%85%E9%A5%B0%E5%99%A8%EF%BC%89"><span class="nav-text">装饰器有用过么？（staticmethod和自己写的时间戳装饰器）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E4%B8%80%E6%AD%A5%EF%BC%9A-staticmethod%E8%AE%B2%E4%B8%80%E4%B8%8B%EF%BC%9F%E5%92%8C%E5%85%B6%E4%BB%96%E7%B1%BB%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">进一步： staticmethod讲一下？和其他类成员函数的区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E8%BF%87%E4%BB%80%E4%B9%88%E5%BA%93%EF%BC%9F%E5%90%84%E8%87%AA%E7%94%A8%E6%9D%A5%E5%B9%B2%E4%BB%80%E4%B9%88%EF%BC%9F%EF%BC%88%E7%AD%94%EF%BC%9Anumpy%EF%BC%8Cos%EF%BC%8Csys%EF%BC%8Cre%EF%BC%8Ccollections%EF%BC%89"><span class="nav-text">用过什么库？各自用来干什么？（答：numpy，os，sys，re，collections）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#re%E7%94%A8%E8%BF%87%EF%BC%9F%E8%AE%B2%E8%AE%B2%E7%94%A8%E8%BF%87%E5%93%AA%E4%BA%9B%E6%AD%A3%E5%88%99%EF%BC%9F%EF%BC%88re-search-amp-re-match%EF%BC%89"><span class="nav-text">re用过？讲讲用过哪些正则？（re.search &amp; re.match）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8A%E9%9D%A2%E4%B8%A4%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">上面两者的区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%EF%BC%9F%E8%AF%A6%E7%BB%86%E8%AF%B4%E4%B8%80%E4%B8%8B%EF%BC%9F"><span class="nav-text">深浅拷贝？详细说一下？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#set%E4%BA%86%E8%A7%A3%E4%B9%88%EF%BC%9F%E5%92%8Clist%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%BA%95%E5%B1%82%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F%EF%BC%88%E5%93%88%E5%B8%8Cmap%EF%BC%89"><span class="nav-text">set了解么？和list的区别？底层如何实现的？（哈希map）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E4%BA%86%E8%A7%A3%E4%B9%88%EF%BC%9F%E9%A1%B9%E7%9B%AE%E9%87%8C%E9%9D%A2%E6%9C%89%E6%B2%A1%E6%9C%89%E6%B6%89%E5%8F%8A%E5%88%B0%EF%BC%9F"><span class="nav-text">类的继承了解么？项目里面有没有涉及到？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP%E5%92%8CUDP%E8%BF%99%E4%B8%AA%E7%9F%A5%E9%81%93%E7%9A%84%E5%90%A7%EF%BC%9F"><span class="nav-text">TCP和UDP这个知道的吧？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%90%91%E5%90%8C%E4%B8%80%E4%B8%AA%E4%B8%BB%E6%9C%BA%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E7%9A%84%E6%97%B6%E5%80%99%E8%BF%98%E9%9C%80%E8%A6%81%E7%94%A8ARP%E5%90%97%EF%BC%9F%EF%BC%88%E4%B8%8D%E7%94%A8%EF%BC%8C%E6%9C%89%E7%BC%93%E5%AD%98%EF%BC%89"><span class="nav-text">第二次向同一个主机发送数据的时候还需要用ARP吗？（不用，有缓存）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E8%BF%9B%E7%A8%8B%E4%BA%86%E8%A7%A3%E5%98%9B%EF%BC%9F%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6%EF%BC%9F%E9%80%9A%E8%AE%AF%E6%96%B9%E5%BC%8F%EF%BC%9F%EF%BC%88%E7%BB%8F%E5%85%B8%E5%85%AB%E8%82%A1%E6%96%87%EF%BC%89%E9%A1%B9%E7%9B%AE%E9%87%8C%E9%9D%A2%E6%9C%89%E5%AE%9E%E7%8E%B0%E8%BF%99%E4%BA%9B%E9%80%9A%E8%AE%AF%E6%96%B9%E5%BC%8F%E5%98%9B%EF%BC%9F%EF%BC%88%EF%BC%9F%EF%BC%9F%EF%BC%9F%EF%BC%89"><span class="nav-text">线程进程了解嘛？进程的调度？通讯方式？（经典八股文）项目里面有实现这些通讯方式嘛？（？？？）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#python%E7%94%A8%E5%93%AA%E4%B8%AA%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9F%EF%BC%88import-thread%EF%BC%89%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%9C%89%E6%B6%89%E5%8F%8A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%98%9B%EF%BC%9F%EF%BC%88%E6%97%A0%C2%B7%C2%B7%C2%B7%EF%BC%89"><span class="nav-text">python用哪个模块实现多线程？（import thread）项目中有涉及多线程嘛？（无···）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%86%E8%A7%A3%E5%98%9B%EF%BC%9F%EF%BC%88%E6%9C%AC%E7%A7%91%E8%BD%AF%E5%B7%A5%EF%BC%89%E8%AE%B2%E4%B8%80%E4%B8%8B%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%88%E9%80%81%E5%88%86%E9%A2%98%EF%BC%89%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE%E7%9A%84%E8%AF%9D%E4%BA%8C%E8%80%85%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%9F"><span class="nav-text">数据结构了解嘛？（本科软工）讲一下数组和链表的区别？（送分题）插入数据的话二者的复杂度？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E5%92%8C%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E4%BA%86%E8%A7%A3%E5%98%9B%EF%BC%9F%E9%82%A3%E4%BA%9B%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%98%AFnlogn%EF%BC%9F"><span class="nav-text">排序和查找算法了解嘛？那些排序算法复杂度是nlogn？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%A0%E8%A7%89%E5%BE%97Python%E8%AF%AD%E8%A8%80%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E6%80%A7%E5%91%A2%EF%BC%9F"><span class="nav-text">你觉得Python语言有什么特性呢？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E9%87%8A%E6%80%A7%E8%AF%AD%E8%A8%80%E5%92%8C%E7%BC%96%E8%AF%91%E6%80%A7%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">解释性语言和编译性语言的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%89%E4%BA%86%E8%A7%A3Python%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%90%97%EF%BC%9F%EF%BC%88%E5%9B%9E%E7%AD%94%E4%B8%8D%E4%BA%86%E8%A7%A3%EF%BC%8C%E5%8F%AA%E7%9F%A5%E9%81%93Python%E8%A7%A3%E9%87%8A%E5%99%A8%EF%BC%89%EF%BC%8C%E9%82%A3%E4%BD%A0%E8%AF%B4%E4%B8%80%E4%B8%8B%E8%A7%A3%E9%87%8A%E5%99%A8%E5%90%A7"><span class="nav-text">有了解Python虚拟机吗？（回答不了解，只知道Python解释器），那你说一下解释器吧</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E9%87%8A%E5%99%A8%E4%B8%BB%E8%A6%81%E7%9A%84%E5%8A%9F%E8%83%BD%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">解释器主要的功能是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CPython"><span class="nav-text">CPython</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IPython"><span class="nav-text">IPython</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PyPy"><span class="nav-text">PyPy</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Jython"><span class="nav-text">Jython</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IronPython"><span class="nav-text">IronPython</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GIL%E9%94%81%E6%9C%89%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%8C%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B"><span class="nav-text">GIL锁有了解吗，解释一下</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%8F%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">协程和线程之间的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">进程切换和线程切换的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Python%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E4%B8%AD%E6%9C%89%E4%B8%89%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%82%E6%95%B0%EF%BC%8C%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%8C%BA%E5%88%AB%EF%BC%88%E5%90%AC%E9%A2%98%E6%B2%A1%E5%90%AC%E6%B8%85%E6%A5%9A%EF%BC%8C%E4%BB%A5%E4%B8%BA%E9%97%AE%E7%9A%84%E4%B8%89%E7%A7%8D%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B%EF%BC%8C%E9%9D%A2%E8%AF%95%E5%AE%98%E6%8C%87%E6%AD%A3%E4%BA%86%E9%97%AE%E7%9A%84%E6%98%AF%E4%B8%89%E7%A7%8D%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%EF%BC%8C%E5%8F%8D%E5%BA%94%E8%BF%87%E6%9D%A5%E5%90%8E%E5%B0%B1%E9%87%8D%E7%AD%94%E4%BA%86%E4%B8%80%E4%B8%8B%EF%BC%89"><span class="nav-text">Python函数声明中有三种类型的参数，说一下区别（听题没听清楚，以为问的三种函数类型，面试官指正了问的是三种参数类型，反应过来后就重答了一下）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BD%A0%E7%9F%A5%E9%81%93%E7%9A%84Django%E7%BB%84%E4%BB%B6"><span class="nav-text">说一下你知道的Django组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Python%E4%B8%AD%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%98%AF%E6%80%8E%E4%B9%88%E7%94%A8%E7%9A%84"><span class="nav-text">Python中的迭代器是怎么用的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%A0%E6%98%AF%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84"><span class="nav-text">你是怎么理解线程安全的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="nav-text">有哪些进程间通信方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%97%E8%A1%A8%E5%8E%BB%E9%87%8D"><span class="nav-text">列表去重</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0set%E7%B1%BB%EF%BC%8C%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E5%8E%BB%E5%AE%9E%E7%8E%B0"><span class="nav-text">自己实现set类，应该如何去实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%89%E5%86%99%E8%BF%87%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%90%97%EF%BC%88%E5%9B%9E%E7%AD%94%E6%B2%A1%E5%86%99%E8%BF%87%EF%BC%89%EF%BC%8C%E9%82%A3%E4%BD%A0%E5%B9%B3%E6%97%B6%E6%98%AF%E6%80%8E%E4%B9%88%E8%B0%83%E8%AF%95%E7%9A%84%EF%BC%88%E5%9B%9E%E7%AD%94%E7%9A%84%E6%89%93%E6%96%AD%E7%82%B9debug%EF%BC%89%EF%BC%8C%E6%9C%89%E5%9C%A8Linux%E4%B8%8A%E8%B0%83%E8%AF%95%E8%BF%87%E5%90%97%EF%BC%88%E6%97%A0%EF%BC%89"><span class="nav-text">有写过单元测试吗（回答没写过），那你平时是怎么调试的（回答的打断点debug），有在Linux上调试过吗（无）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BF%99%E4%B8%80%E5%9D%97%E4%BD%A0%E6%AF%94%E8%BE%83%E7%86%9F%E6%82%89%E5%93%AA%E4%B8%AA%EF%BC%8C%E6%88%96%E8%80%85%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9E%E7%AD%94%E9%83%BD%E8%BF%98%E5%8F%AF%E4%BB%A5%EF%BC%89%EF%BC%8C%E9%82%A3%E4%B9%88%E6%A0%91%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%88%E7%AD%94%E4%BA%86%E4%B8%80%E4%BA%9B%E5%9C%BA%E6%99%AF%EF%BC%89%EF%BC%8C%E6%AF%94%E5%A6%82%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B8%80%E8%88%AC%E4%BC%9A%E5%9C%A8%E5%93%AA%E9%87%8C%E4%BD%BF%E7%94%A8%E5%91%A2%EF%BC%88%E4%B8%8D%E7%9F%A5%E9%81%93%EF%BC%89"><span class="nav-text">数据结构这一块你比较熟悉哪个，或者算法（回答都还可以），那么树的使用场景有哪些（答了一些场景），比如红黑树一般会在哪里使用呢（不知道）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8100%E4%B8%AA%E6%95%B0%E4%B8%AD%E6%89%BE%E7%AC%ACK%E5%A4%A7%E7%9A%84%E6%95%B0%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="nav-text">在100个数中找第K大的数，如何实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Python%E8%BF%98%E6%9C%89%E5%93%AA%E4%BA%9B%E6%98%AF%E4%BD%A0%E6%AF%94%E8%BE%83%E7%86%9F%E6%82%89%E7%9A%84%EF%BC%8C%E6%98%AF%E6%88%91%E5%88%9A%E6%89%8D%E6%B2%A1%E6%9C%89%E9%97%AE%E5%88%B0%E7%9A%84%EF%BC%9F"><span class="nav-text">Python还有哪些是你比较熟悉的，是我刚才没有问到的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux%E5%86%85%E6%A0%B8%E7%86%9F%E6%82%89%E5%90%97%EF%BC%88%E4%B8%8D%E7%86%9F%E6%82%89%EF%BC%89%EF%BC%8CLinux%E5%B8%B8%E8%A7%84%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%8D%E5%A4%AA%E7%94%A8%EF%BC%89"><span class="nav-text">Linux内核熟悉吗（不熟悉），Linux常规使用（不太用）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E8%BF%99%E4%B8%80%E5%9D%97%E7%86%9F%E6%82%89%E5%90%97%EF%BC%8C%E6%88%91%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8A%E8%BE%93%E5%85%A5URL%EF%BC%8C%E5%AE%83%E7%9A%84%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84"><span class="nav-text">网络这一块熟悉吗，我在浏览器上输入URL，它的请求过程是怎样的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IP%E5%B1%82%E5%88%86%E7%89%87%E9%87%8D%E7%BB%84%E6%98%AF%E7%94%A8%E6%9D%A5%E5%81%9A%E4%BB%80%E4%B9%88%E7%9A%84"><span class="nav-text">IP层分片重组是用来做什么的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%98%AF%E6%80%8E%E4%B9%88%E5%81%9A%E7%9A%84"><span class="nav-text">TCP拥塞控制是怎么做的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E8%BD%AF%E9%93%BE%E6%8E%A5%E7%9F%A5%E9%81%93%E6%98%AF%E4%BB%80%E4%B9%88%E5%90%97%EF%BC%88%E4%B8%8D%E7%9F%A5%E9%81%93%EF%BC%89"><span class="nav-text">文件系统中的软链接知道是什么吗（不知道）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8E%B0%E5%9C%A8%E6%9C%89%E4%B8%80%E4%B8%AA%E4%BB%BB%E5%8A%A1%EF%BC%8C%E6%9C%80%E5%A4%9A%E5%8F%AA%E6%9C%8910%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%9C%A8%E6%89%A7%E8%A1%8C%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="nav-text">现在有一个任务，最多只有10个线程在执行，如何实现？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Python%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%94%81%E6%98%AF%E4%B8%8D%E6%98%AF%E6%AF%94%E8%BE%83%E5%B0%91%EF%BC%9F%EF%BC%88%E6%98%AF%E7%9A%84%EF%BC%89"><span class="nav-text">Python中使用锁是不是比较少？（是的）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E6%88%91%E4%B8%A4%E4%B8%AA%E4%B8%BB%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8D%E9%80%9A%E4%BA%86%EF%BC%8C%E8%AF%A5%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5%EF%BC%9F"><span class="nav-text">如果我两个主机网络不通了，该如何排查？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%94%A8nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86"><span class="nav-text">为什么需要用nginx反向代理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#nginx%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="nav-text">nginx如何实现负载均衡</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E8%AE%BA%E6%96%87%EF%BC%8C%E4%BD%A0%E8%A7%89%E5%BE%97%E5%AF%BC%E5%B8%88%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E5%BF%AB%E9%80%9F%E6%83%B3%E5%88%B0%E4%BD%A0%E6%83%B3%E4%B8%8D%E5%88%B0%E7%9A%84idea%EF%BC%8C%E5%AF%BC%E5%B8%88%E6%98%AF%E5%A6%82%E4%BD%95%E8%BE%BE%E5%88%B0%E8%BF%99%E6%A0%B7%E7%9A%84%E9%AB%98%E5%BA%A6%E7%9A%84"><span class="nav-text">通过论文，你觉得导师为什么能快速想到你想不到的idea，导师是如何达到这样的高度的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%BA%E6%99%AF%E9%A2%98%EF%BC%8C%E5%8F%8C%E5%8D%81%E4%B8%80%E9%AB%98%E5%B9%B6%E5%8F%91%EF%BC%8C%E9%98%BF%E9%87%8C%E6%9E%B6%E6%9E%84%E5%B8%88%E6%8E%A8%E5%87%BA%E7%9A%84%E4%BA%A7%E5%93%81%E6%98%AF%E6%80%8E%E4%B9%88%E5%81%9A%E7%9A%84"><span class="nav-text">场景题，双十一高并发，阿里架构师推出的产品是怎么做的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D%E8%87%AA%E5%B7%B1%E7%9A%84%E6%8A%80%E6%9C%AF%E4%BC%98%E5%8A%BF"><span class="nav-text">介绍自己的技术优势</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%B7%B1%E6%83%B3%E8%A6%81%E8%BE%BE%E5%88%B0%E7%9A%84%E7%A8%8B%E5%BA%A6"><span class="nav-text">自己想要达到的程度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E6%B6%89%E5%8F%8A%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%9A%84%E9%A1%B9%E7%9B%AE%EF%BC%8C%E5%AD%A6%E4%B9%A0%E8%83%BD%E5%8A%9B%E5%A6%82%E4%BD%95"><span class="nav-text">如果涉及其他语言的项目，学习能力如何</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%99%A4%E4%BA%86Python%E5%A4%96%E8%BF%98%E9%9C%80%E8%A6%81%E4%BB%80%E4%B9%88%E6%8A%80%E8%83%BD"><span class="nav-text">除了Python外还需要什么技能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E6%96%B9%E6%B3%95%E5%93%AA%E4%B8%AA%E6%9B%B4%E5%BF%AB"><span class="nav-text">字符串拼接方法哪个更快</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E5%8C%BA%E5%88%AB"><span class="nav-text">指针和引用区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E5%8F%8A%E5%BA%94%E7%94%A8"><span class="nav-text">红黑树及应用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E7%94%A8%E5%88%B0%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">项目用到哪些数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E5%90%84%E6%9C%89%E5%95%A5%E7%89%B9%E7%82%B9"><span class="nav-text">python数据结构有哪些，各有啥特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E5%8E%9F%E7%90%86%EF%BC%8C%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3"><span class="nav-text">哈希表原理，哈希冲突怎么解决</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">二叉树的定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9F%A5%E6%89%BE%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-text">二叉树查找方式有哪些</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E6%AF%94%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9"><span class="nav-text">二叉树和其他数据结构相比有什么特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#B-%E6%A0%91%E6%9C%89%E4%BB%80%E4%B9%88%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">B+树有什么应用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E5%9B%BE%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-text">二叉树和图有什么区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9F%A5%E9%81%93%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%90%97"><span class="nav-text">知道最小生成树吗</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%85%83%E7%B1%BB"><span class="nav-text">什么是元类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">堆和栈的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%80%E5%B0%8F%E5%A0%86"><span class="nav-text">什么是最小堆</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%98%AF%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98%E7%9A%84"><span class="nav-text">动态规划是怎么解决问题的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#python%E5%86%85%E7%BD%AE%E7%9A%84%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-text">python内置的算法有哪些</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%BA%E7%94%9F%E4%B8%AD%E6%9C%80%E9%87%8D%E8%A6%81%E7%9A%84%E7%AE%97%E6%B3%95%E6%98%AF%E5%93%AA%E4%B8%AA"><span class="nav-text">人生中最重要的算法是哪个</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E5%85%B8%E3%80%81%E5%85%83%E7%BB%84%E3%80%81%E5%88%97%E8%A1%A8%E7%9A%84in%E6%96%B9%E6%B3%95%E5%93%AA%E4%B8%AA%E6%9B%B4%E5%BF%AB"><span class="nav-text">字典、元组、列表的in方法哪个更快</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#open%E5%92%8Cwith-open%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">open和with open的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E5%85%B8%E6%A0%91"><span class="nav-text">字典树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-text">迭代器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%9D%80%E6%AD%BB-test-py%E8%BF%9B%E7%A8%8B"><span class="nav-text">如何杀死 test.py进程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%AB%E6%8E%92%E7%9A%84%E6%80%9D%E8%B7%AF"><span class="nav-text">快排的思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AAa-txt%EF%BC%8Cb-txt%E6%96%87%E4%BB%B6%EF%BC%8C%E9%87%8C%E9%9D%A2%E5%AD%98%E6%9C%89%E8%AE%B8%E5%A4%9Aip%E5%9C%B0%E5%9D%80%EF%BC%8C%E7%8E%B0%E5%9C%A8%E5%88%A4%E6%96%AD%E6%9C%89%E5%A4%9A%E5%B0%91%E4%B8%AA%E7%9B%B8%E5%90%8C%E7%9A%84IP"><span class="nav-text">给定一个a.txt，b.txt文件，里面存有许多ip地址，现在判断有多少个相同的IP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP%E7%9A%84%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6%E3%80%81%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84"><span class="nav-text">TCP的重传机制、快速重传是怎样的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#30%E5%BC%A0%E5%9B%BE%E8%A7%A3%EF%BC%9A-TCP-%E9%87%8D%E4%BC%A0%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E3%80%81%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E3%80%81%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="nav-text">30张图解： TCP 重传、滑动窗口、流量控制、拥塞控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6"><span class="nav-text">重传机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0"><span class="nav-text">超时重传</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0"><span class="nav-text">快速重传</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SACK-%E6%96%B9%E6%B3%95"><span class="nav-text">SACK 方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Duplicate-SACK"><span class="nav-text">Duplicate SACK</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="nav-text">滑动窗口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="nav-text">流量控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BC%93%E5%86%B2%E5%8C%BA%E4%B8%8E%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-text">操作系统缓冲区与滑动窗口的关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AA%97%E5%8F%A3%E5%85%B3%E9%97%AD"><span class="nav-text">窗口关闭</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B3%8A%E6%B6%82%E7%AA%97%E5%8F%A3%E7%BB%BC%E5%90%88%E7%97%87"><span class="nav-text">糊涂窗口综合症</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="nav-text">拥塞控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%85%A2%E5%90%AF%E5%8A%A8"><span class="nav-text">慢启动</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D%E7%AE%97%E6%B3%95"><span class="nav-text">拥塞避免算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%A5%E5%A1%9E%E5%8F%91%E7%94%9F"><span class="nav-text">拥塞发生</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E6%81%A2%E5%A4%8D"><span class="nav-text">快速恢复</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%A5%E5%A1%9E%E7%AE%97%E6%B3%95%E7%A4%BA%E6%84%8F%E5%9B%BE"><span class="nav-text">拥塞算法示意图</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%9F%E8%AE%A1%E5%9C%A8%E6%96%87%E4%BB%B6%E5%A4%B9-root-%E4%B8%8B%EF%BC%8C%E5%8C%85%E5%90%AB%E2%80%9Cword%E2%80%9D%E7%9A%84%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="nav-text">统计在文件夹&#x2F;root 下，包含“word”的文件的个数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL%E7%9A%84%E8%B0%83%E4%BC%98"><span class="nav-text">MySQL的调优</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8E%B0%E6%9C%89100%E4%BA%BF%E4%B8%AAQQ%E5%8F%B7%EF%BC%8C%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%88%A4%E6%96%AD%E6%9F%90%E4%B8%AAQQ%E5%8F%B7%E6%98%AF%E5%90%A6%E5%9C%A8%E5%85%B6%E4%B8%AD%EF%BC%8C%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%E8%87%AA%E5%B7%B1%E8%80%83%E8%99%91%EF%BC%8C%E8%B6%8A%E5%BF%AB%E8%B6%8A%E5%A5%BD%EF%BC%88%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4%EF%BC%89%EF%BC%8C%E7%A9%BA%E9%97%B4%E8%B6%8A%E5%B0%8F%E8%B6%8A%E5%A5%BD%E3%80%82"><span class="nav-text">现有100亿个QQ号，如何快速判断某个QQ号是否在其中，存储方式自己考虑，越快越好（运行时间），空间越小越好。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8-1"><span class="nav-text">迭代器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E5%99%A8-1"><span class="nav-text">生成器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%AD%E5%8C%85"><span class="nav-text">闭包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#args-%E5%92%8C-kwargs"><span class="nav-text">**args 和 *kwargs</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#property-%E5%92%8C-setter"><span class="nav-text">@property 和 @setter</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Python-%E6%96%B9%E6%B3%95"><span class="nav-text">Python 方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#import%E4%B9%8B%E7%B1%BB%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="nav-text">import之类的知识点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Python%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B%E6%A6%82%E5%BF%B5"><span class="nav-text">Python进程、线程、协程概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E8%BF%9B%E7%A8%8B"><span class="nav-text">一、进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text">进程的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E8%BF%9B%E7%A8%8B%E6%98%AF%E4%B8%80%E4%B8%AA%E5%AE%9E%E4%BD%93%E3%80%82%E6%AF%8F%E4%B8%AA%E8%BF%9B%E7%A8%8B%E9%83%BD%E6%9C%89%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4-CPU%E5%88%86%E9%85%8D-%E3%80%82%E5%AE%9E%E4%BD%93%E7%A9%BA%E9%97%B4%E5%8C%85%E6%8B%AC%E4%B8%89%E9%83%A8%E5%88%86%EF%BC%9A"><span class="nav-text">1.进程是一个实体。每个进程都有自己的地址空间(CPU分配)。实体空间包括三部分：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E8%BF%9B%E7%A8%8B%E6%98%AF%E4%B8%80%E4%B8%AA%E2%80%9C%E6%89%A7%E8%A1%8C%E4%B8%AD%E7%9A%84%E7%A8%8B%E5%BA%8F%E2%80%9D%E3%80%82"><span class="nav-text">2.进程是一个“执行中的程序”。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-text">进程的特点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C"><span class="nav-text">二、并发与并行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%BA%E5%88%AB"><span class="nav-text">区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E7%BA%BF%E7%A8%8B"><span class="nav-text">三、线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%BC%95%E5%85%A5"><span class="nav-text">3.1、线程的引入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text">3.2、线程的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3%E3%80%81%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">3.3、进程与线程的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E5%8D%8F%E7%A8%8B"><span class="nav-text">四、协程</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Ashin Wang"
      src="https://tva1.sinaimg.cn/large/006y8mN6ly1g74lvmm1zhj3074074q4r.jpg">
  <p class="site-author-name" itemprop="name">Ashin Wang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">68</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">86</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/AshinWang" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;AshinWang" rel="noopener" target="_blank"><i class="fa fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ashin Wang</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="//cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script>
<script src="/js/algolia-search.js"></script>














  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '4d1a5c237f1ecba513f0',
      clientSecret: 'f403fbb98b9afbee3a250673d6f741dda22ba1e2',
      repo        : 'AshinWang.github.io',
      owner       : 'AshinWang',
      admin       : ['AshinWang'],
      id          : '1e9a5e3e9ea215c04e68fcbde0f4e621',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
